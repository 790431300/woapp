var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(a) {
	return document.createElement(a)
};
cc._addEventListener = function(a, b, c, d) {
	a.addEventListener(b, c, d)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(a, b, c) {
	if (a) if (a instanceof Array) for (var d = 0, e = a.length; d < e && !1 !== b.call(c, a[d], d); d++);
	else for (d in a)
	if (!1 === b.call(c, a[d], d)) break
};
cc.extend = function(a) {
	var b = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
	cc.each(b, function(b) {
		for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d])
	});
	return a
};
cc.isFunction = function(a) {
	return "function" === typeof a
};
cc.isNumber = function(a) {
	return "number" === typeof a || "[object Number]" === Object.prototype.toString.call(a)
};
cc.isString = function(a) {
	return "string" === typeof a || "[object String]" === Object.prototype.toString.call(a)
};
cc.isArray = function(a) {
	return Array.isArray(a) || "object" === typeof a && "[object Array]" === Object.prototype.toString.call(a)
};
cc.isUndefined = function(a) {
	return "undefined" === typeof a
};
cc.isObject = function(a) {
	return "object" === typeof a && "[object Object]" === Object.prototype.toString.call(a)
};
cc.isCrossOrigin = function(a) {
	if (!a) return cc.log("invalid URL"), !1;
	var b = a.indexOf("://");
	if (-1 === b) return !1;
	b = a.indexOf("/", b + 3);
	return (-1 === b ? a : a.substring(0, b)) !== location.origin
};
cc.AsyncPool = function(a, b, c, d, e) {
	var f = this;
	f._srcObj = a;
	f._limit = b;
	f._pool = [];
	f._iterator = c;
	f._iteratorTarget = e;
	f._onEnd = d;
	f._onEndTarget = e;
	f._results = a instanceof Array ? [] : {};
	cc.each(a, function(a, b) {
		f._pool.push({
			index: b,
			value: a
		})
	});
	f.size = f._pool.length;
	f.finishedSize = 0;
	f._workingSize = 0;
	f._limit = f._limit || f.size;
	f.onIterator = function(a, b) {
		f._iterator = a;
		f._iteratorTarget = b
	};
	f.onEnd = function(a, b) {
		f._onEnd = a;
		f._onEndTarget = b
	};
	f._handleItem = function() {
		var a = this;
		if (!(0 === a._pool.length || a._workingSize >= a._limit)) {
			var b = a._pool.shift(),
				c = b.value,
				d = b.index;
			a._workingSize++;
			a._iterator.call(a._iteratorTarget, c, d, function(b) {
				a.finishedSize++;
				a._workingSize--;
				var c = Array.prototype.slice.call(arguments, 1);
				a._results[this.index] = c[0];
				a.finishedSize === a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
			}.bind(b), a)
		}
	};
	f.flow = function() {
		if (0 === this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
		else for (var a = 0; a < this._limit; a++) this._handleItem()
	}
};
cc.async = {
	series: function(a, b, c) {
		a = new cc.AsyncPool(a, 1, function(a, b, f) {
			a.call(c, f)
		}, b, c);
		a.flow();
		return a
	},
	parallel: function(a, b, c) {
		a = new cc.AsyncPool(a, 0, function(a, b, f) {
			a.call(c, f)
		}, b, c);
		a.flow();
		return a
	},
	waterfall: function(a, b, c) {
		var d = [],
			e = [null],
			f = new cc.AsyncPool(a, 1, function(b, f, n) {
				d.push(function(b) {
					d = Array.prototype.slice.call(arguments, 1);
					a.length - 1 === f && (e = e.concat(d));
					n.apply(null, arguments)
				});
				b.apply(c, d)
			}, function(a) {
				if (b) {
					if (a) return b.call(c, a);
					b.apply(c, e)
				}
			});
		f.flow();
		return f
	},
	map: function(a, b, c, d) {
		var e = b;
		"object" === typeof b && (c = b.cb, d = b.iteratorTarget, e = b.iterator);
		a = new cc.AsyncPool(a, 0, e, c, d);
		a.flow();
		return a
	},
	mapLimit: function(a, b, c, d, e) {
		a = new cc.AsyncPool(a, b, c, d, e);
		a.flow();
		return a
	}
};
cc.path = {
	join: function() {
		for (var a = arguments.length, b = "", c = 0; c < a; c++) b = (b + ("" === b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
		return b
	},
	extname: function(a) {
		return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
	},
	mainFileName: function(a) {
		if (a) {
			var b = a.lastIndexOf(".");
			if (-1 !== b) return a.substring(0, b)
		}
		return a
	},
	basename: function(a, b) {
		var c = a.indexOf("?");
		0 < c && (a = a.substring(0, c));
		c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
		if (!c) return null;
		c = c[2];
		return b && a.substring(a.length - b.length).toLowerCase() === b.toLowerCase() ? c.substring(0, c.length - b.length) : c
	},
	dirname: function(a) {
		return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
	},
	changeExtname: function(a, b) {
		b = b || "";
		var c = a.indexOf("?"),
			d = "";
		0 < c && (d = a.substring(c), a = a.substring(0, c));
		c = a.lastIndexOf(".");
		return 0 > c ? a + b + d : a.substring(0, c) + b + d
	},
	changeBasename: function(a, b, c) {
		if (0 === b.indexOf(".")) return this.changeExtname(a, b);
		var d = a.indexOf("?"),
			e = "";
		c = c ? this.extname(a) : "";
		0 < d && (e = a.substring(d), a = a.substring(0, d));
		d = a.lastIndexOf("/");
		return a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
	}
};
cc.loader = {
	_jsCache: {},
	_register: {},
	_langPathCache: {},
	_aliases: {},
	resPath: "",
	audioPath: "",
	cache: {},
	getXMLHttpRequest: function() {
		return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
	},
	_getArgs4Js: function(a) {
		var b = a[0],
			c = a[1],
			d = a[2],
			e = ["", null, null];
		if (1 === a.length) e[1] = b instanceof Array ? b : [b];
		else if (2 === a.length)"function" === typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
		else if (3 === a.length) e[0] = b || "", e[1] = c instanceof
		Array ? c : [c], e[2] = d;
		else throw Error("arguments error to load js!");
		return e
	},
	loadJs: function(a, b, c) {
		var d = this,
			e = d._jsCache,
			f = d._getArgs4Js(arguments),
			k = f[0],
			m = f[1],
			f = f[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? d._loadJs4Dependency(k, m, 0, f) : cc.async.map(m, function(a, b, c) {
			a = cc.path.join(k, a);
			if (e[a]) return c(null);
			d._createScript(a, !1, c)
		}, f)
	},
	loadJsWithImg: function(a, b, c) {
		var d = this._loadJsImg(),
			e = this._getArgs4Js(arguments);
		this.loadJs(e[0], e[1], function(a) {
			if (a) throw Error(a);
			d.parentNode.removeChild(d);
			if (e[2]) e[2]()
		})
	},
	_createScript: function(a, b, c) {
		var d = document,
			e = cc.newElement("script");
		e.async = b;
		this._jsCache[a] = !0;
		cc.game.config.noCache && "string" === typeof a ? this._noCacheRex.test(a) ? e.src = a + "&_t=" + (new Date - 0) : e.src = a + "?_t=" + (new Date - 0) : e.src = a;
		cc._addEventListener(e, "load", function() {
			e.parentNode.removeChild(e);
			this.removeEventListener("load", arguments.callee, !1);
			c()
		}, !1);
		cc._addEventListener(e, "error", function() {
			e.parentNode.removeChild(e);
			c("Load " + a + " failed!")
		}, !1);
		d.body.appendChild(e)
	},
	_loadJs4Dependency: function(a, b, c, d) {
		if (c >= b.length) d && d();
		else {
			var e = this;
			e._createScript(cc.path.join(a, b[c]), !1, function(f) {
				if (f) return d(f);
				e._loadJs4Dependency(a, b, c + 1, d)
			})
		}
	},
	_loadJsImg: function() {
		var a = document,
			b = a.getElementById("cocos2d_loadJsImg");
		if (!b) {
			b = cc.newElement("img");
			cc._loadingImage && (b.src = cc._loadingImage);
			a = a.getElementById(cc.game.config.id);
			a.style.backgroundColor = "transparent";
			a.parentNode.appendChild(b);
			var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
			c || (c = {
				width: a.width,
				height: a.height
			});
			b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px";
			b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 + "px";
			b.style.position = "absolute"
		}
		return b
	},
	loadTxt: function(a, b) {
		if (cc._isNodeJs) require("fs").readFile(a, function(a, c) {
			a ? b(a) : b(null, c.toString())
		});
		else {
			var c = this.getXMLHttpRequest(),
				d = "load " + a + " failed!";
			c.open("GET", a, !0);
			/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function() {
				4 === c.readyState && (200 === c.status ? b(null, c.responseText) : b({
					status: c.status,
					errorMessage: d
				}, null))
			}) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset=utf-8"), c.onload = function() {
				4 === c.readyState && (200 === c.status ? b(null, c.responseText) : b({
					status: c.status,
					errorMessage: d
				}, null))
			}, c.onerror = function() {
				b({
					status: c.status,
					errorMessage: d
				}, null)
			});
			c.send(null)
		}
	},
	_loadTxtSync: function(a) {
		if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
		var b = this.getXMLHttpRequest();
		b.open("GET", a, !1);
		/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset=utf-8");
		b.send(null);
		return 4 === !b.readyState || 200 !== b.status ? null : b.responseText
	},
	loadCsb: function(a, b) {
		var c = new XMLHttpRequest,
			d = "load " + a + " failed!";
		c.open("GET", a, !0);
		c.responseType = "arraybuffer";
		c.onload = function() {
			var a = c.response;
			a && (window.msg = a);
			4 === c.readyState && (200 === c.status ? b(null, c.response) : b({
				status: c.status,
				errorMessage: d
			}, null))
		};
		c.onerror = function() {
			b({
				status: c.status,
				errorMessage: d
			}, null)
		};
		c.send(null)
	},
	loadJson: function(a, b) {
		this.loadTxt(a, function(c, d) {
			if (c) b(c);
			else {
				try {
					var e = JSON.parse(d)
				} catch (f) {
					throw Error("parse json [" + a + "] failed : " + f);
				}
				b(null, e)
			}
		})
	},
	_checkIsImageURL: function(a) {
		return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
	},
	loadImg: function(a, b, c) {
		var d = {
			isCrossOrigin: !0
		};
		void 0 !== c ? d.isCrossOrigin = null === b.isCrossOrigin ? d.isCrossOrigin : b.isCrossOrigin : void 0 !== b && (c = b);
		var e = this.getRes(a);
		if (e) return c && c(null, e), e;
		e = new Image;
		d.isCrossOrigin && "file://" !== location.origin && (e.crossOrigin = "Anonymous");
		var f = function() {
				this.removeEventListener("load", f, !1);
				this.removeEventListener("error", m, !1);
				c && c(null, e)
			},
			k = this,
			m = function() {
				this.removeEventListener("error", m, !1);
				e.crossOrigin && "anonymous" === e.crossOrigin.toLowerCase() ? (d.isCrossOrigin = !1, k.release(a), cc.loader.loadImg(a, d, c)) : "function" === typeof c && c("load image failed")
			};
		cc._addEventListener(e, "load", f);
		cc._addEventListener(e, "error", m);
		e.src = a;
		return e
	},
	_loadResIterator: function(a, b, c) {
		var d = this,
			e = null,
			f = a.type;
		f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e));
		if (b = d.getRes(e)) return c(null, b);
		b = null;
		f && (b = d._register[f.toLowerCase()]);
		if (!b) return cc.error("loader for [" + f + "] not exists!"), c();
		f = e;
		cc._urlRegExp.test(e) || (f = b.getBasePath ? b.getBasePath() : d.resPath, f = d.getUrl(f, e));
		cc.game.config.noCache && "string" === typeof f && (f = d._noCacheRex.test(f) ? f + ("&_t=" + (new Date - 0)) : f + ("?_t=" + (new Date - 0)));
		b.load(f, e, a, function(a, b) {
			a ? (cc.log(a), d.cache[e] = null, delete d.cache[e], c({
				status: 520,
				errorMessage: a
			}, null)) : (d.cache[e] = b, c(null, b))
		})
	},
	_noCacheRex: /\?/,
	getUrl: function(a, b) {
		var c = this._langPathCache,
			d = cc.path;
		if (void 0 !== a && void 0 === b) {
			b = a;
			var e = d.extname(b),
				e = e ? e.toLowerCase() : "";
			a = (e = this._register[e]) ? e.getBasePath ? e.getBasePath() : this.resPath : this.resPath
		}
		b = cc.path.join(a || "", b);
		if (b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
			if (c[b]) return c[b];
			d = d.extname(b) || "";
			b = c[b] = b.substring(0, b.length - d.length) + "_" + cc.sys.language + d
		}
		return b
	},
	load: function(a, b, c) {
		var d = this,
			e = arguments.length;
		if (0 === e) throw Error("arguments error!");
		3 === e ? "function" === typeof b && (b = "function" === typeof c ? {
			trigger: b,
			cb: c
		} : {
			cb: b,
			cbTarget: c
		}) : 2 === e ? "function" === typeof b && (b = {
			cb: b
		}) : 1 === e && (b = {});
		a instanceof Array || (a = [a]);
		e = new cc.AsyncPool(a, 0, function(a, c, e, n) {
			d._loadResIterator(a, c, function(a) {
				var c = Array.prototype.slice.call(arguments, 1);
				b.trigger && b.trigger.call(b.triggerTarget, c[0], n.size, n.finishedSize);
				e(a, c[0])
			})
		}, b.cb, b.cbTarget);
		e.flow();
		return e
	},
	_handleAliases: function(a, b) {
		var c = this._aliases,
			d = [],
			e;
		for (e in a) {
			var f = a[e];
			c[e] = f;
			d.push(f)
		}
		this.load(d, b)
	},
	loadAliases: function(a, b) {
		var c = this,
			d = c.getRes(a);
		d ? c._handleAliases(d.filenames, b) : c.load(a, function(a, d) {
			c._handleAliases(d[0].filenames, b)
		})
	},
	register: function(a, b) {
		if (a && b) {
			if ("string" === typeof a) return this._register[a.trim().toLowerCase()] = b;
			for (var c = 0, d = a.length; c < d; c++) this._register["." + a[c].trim().toLowerCase()] = b
		}
	},
	getRes: function(a) {
		return this.cache[a] || this.cache[this._aliases[a]]
	},
	release: function(a) {
		var b = this.cache,
			c = this._aliases;
		delete b[a];
		delete b[c[a]];
		delete c[a]
	},
	releaseAll: function() {
		var a = this.cache,
			b = this._aliases,
			c;
		for (c in a) delete a[c];
		for (c in b) delete b[c]
	}
};
cc.formatStr = function() {
	var a = arguments,
		b = a.length;
	if (1 > b) return "";
	var c = a[0],
		d = !0;
	"object" === typeof c && (d = !1);
	for (var e = 1; e < b; ++e) {
		var f = a[e];
		if (d) for (;;) {
			var k = null;
			if ("number" === typeof f && (k = c.match(/(%d)|(%s)/))) {
				c = c.replace(/(%d)|(%s)/, f);
				break
			}
			c = (k = c.match(/%s/)) ? c.replace(/%s/, f) : c + ("    " + f);
			break
		} else c += "    " + f
	}
	return c
};
(function() {
	var a = window,
		b, c;
	cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (b = "webkitHidden", c = "webkitvisibilitychange") : (b = "msHidden", c = "msvisibilitychange") : (b = "mozHidden", c = "mozvisibilitychange") : (b = "hidden", c = "visibilitychange");
	var d = function() {
			cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
		},
		e = function() {
			cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
			cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
		};
	b ? cc._addEventListener(document, c, function() {
		document[b] ? d() : e()
	}, !1) : (cc._addEventListener(a, "blur", d, !1), cc._addEventListener(a, "focus", e, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function() {
		e()
	});
	"onpageshow" in window && "onpagehide" in window && (cc._addEventListener(a, "pagehide", d, !1), cc._addEventListener(a, "pageshow", e, !1));
	c = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(a, b) {
	for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
		try {
			d = a.getContext(c[e], b)
		} catch (f) {}
		if (d) break
	}
	return d
};
cc._initSys = function(a, b) {
	cc._RENDER_TYPE_CANVAS = 0;
	cc._RENDER_TYPE_WEBGL = 1;
	cc.sys = {};
	var c = cc.sys;
	c.LANGUAGE_ENGLISH = "en";
	c.LANGUAGE_CHINESE = "zh";
	c.LANGUAGE_FRENCH = "fr";
	c.LANGUAGE_ITALIAN = "it";
	c.LANGUAGE_GERMAN = "de";
	c.LANGUAGE_SPANISH = "es";
	c.LANGUAGE_DUTCH = "du";
	c.LANGUAGE_RUSSIAN = "ru";
	c.LANGUAGE_KOREAN = "ko";
	c.LANGUAGE_JAPANESE = "ja";
	c.LANGUAGE_HUNGARIAN = "hu";
	c.LANGUAGE_PORTUGUESE = "pt";
	c.LANGUAGE_ARABIC = "ar";
	c.LANGUAGE_NORWEGIAN = "no";
	c.LANGUAGE_POLISH = "pl";
	c.OS_IOS = "iOS";
	c.OS_ANDROID = "Android";
	c.OS_WINDOWS = "Windows";
	c.OS_MARMALADE = "Marmalade";
	c.OS_LINUX = "Linux";
	c.OS_BADA = "Bada";
	c.OS_BLACKBERRY = "Blackberry";
	c.OS_OSX = "OS X";
	c.OS_WP8 = "WP8";
	c.OS_WINRT = "WINRT";
	c.OS_UNKNOWN = "Unknown";
	c.UNKNOWN = -1;
	c.WIN32 = 0;
	c.LINUX = 1;
	c.MACOS = 2;
	c.ANDROID = 3;
	c.IPHONE = 4;
	c.IPAD = 5;
	c.BLACKBERRY = 6;
	c.NACL = 7;
	c.EMSCRIPTEN = 8;
	c.TIZEN = 9;
	c.WINRT = 10;
	c.WP8 = 11;
	c.MOBILE_BROWSER = 100;
	c.DESKTOP_BROWSER = 101;
	c.BROWSER_TYPE_WECHAT = "wechat";
	c.BROWSER_TYPE_ANDROID = "androidbrowser";
	c.BROWSER_TYPE_IE = "ie";
	c.BROWSER_TYPE_QQ = "qqbrowser";
	c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
	c.BROWSER_TYPE_UC = "ucbrowser";
	c.BROWSER_TYPE_360 = "360browser";
	c.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
	c.BROWSER_TYPE_BAIDU = "baidubrowser";
	c.BROWSER_TYPE_MAXTHON = "maxthon";
	c.BROWSER_TYPE_OPERA = "opera";
	c.BROWSER_TYPE_OUPENG = "oupeng";
	c.BROWSER_TYPE_MIUI = "miuibrowser";
	c.BROWSER_TYPE_FIREFOX = "firefox";
	c.BROWSER_TYPE_SAFARI = "safari";
	c.BROWSER_TYPE_CHROME = "chrome";
	c.BROWSER_TYPE_LIEBAO = "liebao";
	c.BROWSER_TYPE_QZONE = "qzone";
	c.BROWSER_TYPE_SOUGOU = "sogou";
	c.BROWSER_TYPE_UNKNOWN = "unknown";
	c.isNative = !1;
	var d = window,
		e = d.navigator,
		f = document,
		k = f.documentElement,
		m = e.userAgent.toLowerCase();
	c.isMobile = -1 !== m.indexOf("mobile") || -1 !== m.indexOf("android");
	c.platform = c.isMobile ? c.MOBILE_BROWSER : c.DESKTOP_BROWSER;
	var n = e.language,
		n = (n = n ? n : e.browserLanguage) ? n.split("-")[0] : c.LANGUAGE_ENGLISH;
	c.language = n;
	var n = c.BROWSER_TYPE_UNKNOWN,
		p = m.match(/sogou|qzone|liebao|micromessenger|qqbrowser|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || m.match(/chrome|safari/i);
	p && 0 < p.length ? (n = p[0], "micromessenger" === n ? n = c.BROWSER_TYPE_WECHAT : "safari" === n && m.match(/android.*applewebkit/) ? n = c.BROWSER_TYPE_ANDROID : "trident" === n ? n = c.BROWSER_TYPE_IE : "360 aphone" === n && (n = c.BROWSER_TYPE_360)) : m.indexOf("iphone") && m.indexOf("mobile") && (n = "safari");
	c.browserType = n;
	n = m.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
	m = m.match(/android/i) || e.platform.match(/android/i) ? !0 : !1;
	p = c.OS_UNKNOWN; - 1 !== e.appVersion.indexOf("Win") ? p = c.OS_WINDOWS : n ? p = c.OS_IOS : -1 !== e.appVersion.indexOf("Mac") ? p = c.OS_OSX : -1 !== e.appVersion.indexOf("X11") && -1 === e.appVersion.indexOf("Linux") ? p = c.OS_UNIX : m ? p = c.OS_ANDROID : -1 !== e.appVersion.indexOf("Linux") && (p = c.OS_LINUX);
	c.os = p;
	c._supportMultipleAudio = -1 < [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_BAIDU_APP, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE].indexOf(c.browserType);
	(function(a, c) {
		var e = c[b.renderMode] - 0;
		if (isNaN(e) || 2 < e || 0 > e) e = 0;
		var f = [a.OS_ANDROID],
			k = [],
			m = cc.newElement("canvas");
		cc._renderType = cc._RENDER_TYPE_CANVAS;
		cc._supportRender = !1;
		var n = d.WebGLRenderingContext;
		if (2 === e || 0 === e && n && -1 === f.indexOf(a.os) && -1 === k.indexOf(a.browserType)) try {
			cc.create3DContext(m, {
				stencil: !0,
				preserveDrawingBuffer: !0
			}) && (cc._renderType = cc._RENDER_TYPE_WEBGL, cc._supportRender = !0)
		} catch (p) {}
		if (1 === e || 0 === e && !1 === cc._supportRender) try {
			m.getContext("2d"), cc._renderType = cc._RENDER_TYPE_CANVAS, cc._supportRender = !0
		} catch (r) {}
	})(c, a);
	c._canUseCanvasNewBlendModes = function() {
		var a = document.createElement("canvas");
		a.width = 1;
		a.height = 1;
		a = a.getContext("2d");
		a.fillStyle = "#000";
		a.fillRect(0, 0, 1, 1);
		a.globalCompositeOperation = "multiply";
		var b = document.createElement("canvas");
		b.width = 1;
		b.height = 1;
		var c = b.getContext("2d");
		c.fillStyle = "#fff";
		c.fillRect(0, 0, 1, 1);
		a.drawImage(b, 0, 0, 1, 1);
		return 0 === a.getImageData(0, 0, 1, 1).data[0]
	};
	c._supportCanvasNewBlendModes = c._canUseCanvasNewBlendModes();
	try {
		c._supportWebAudio = !(!d.AudioContext && !d.webkitAudioContext && !d.mozAudioContext)
	} catch (r) {
		c._supportWebAudio = !1
	}
	try {
		var s = c.localStorage = d.localStorage;
		s.setItem("storage", "");
		s.removeItem("storage");
		s = null
	} catch (u) {
		s = function() {
			cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
		}, c.localStorage = {
			getItem: s,
			setItem: s,
			removeItem: s,
			clear: s
		}
	}
	s = c.capabilities = {
		canvas: !0
	};
	cc._renderType === cc._RENDER_TYPE_WEBGL && (s.opengl = !0);
	if (void 0 !== k.ontouchstart || void 0 !== f.ontouchstart || e.msPointerEnabled) s.touches = !0;
	void 0 !== k.onmouseup && (s.mouse = !0);
	void 0 !== k.onkeyup && (s.keyboard = !0);
	if (d.DeviceMotionEvent || d.DeviceOrientationEvent) s.accelerometer = !0;
	c.garbageCollect = function() {};
	c.dumpRoot = function() {};
	c.restartVM = function() {};
	c.cleanScript = function(a) {};
	c.isObjectValid = function(a) {
		return a ? !0 : !1
	};
	c.dump = function() {
		var a;
		a = "" + ("isMobile : " + this.isMobile + "\r\n");
		a += "language : " + this.language + "\r\n";
		a += "browserType : " + this.browserType + "\r\n";
		a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
		a += "os : " + this.os + "\r\n";
		a += "platform : " + this.platform + "\r\n";
		cc.log(a)
	};
	c.openURL = function(a) {
		window.open(a)
	}
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(a, b, c) {
	if (!cc._setupCalled) {
		cc._setupCalled = !0;
		var d = window,
			e = cc.$(a) || cc.$("#" + a),
			f;
		cc.game._setAnimFrame();
		"CANVAS" === e.tagName ? (b = b || e.width, c = c || e.height, f = cc.container = cc.newElement("DIV"), a = cc._canvas = e, a.parentNode.insertBefore(f, a), a.appendTo(f), f.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" !== e.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || e.clientWidth, c = c || e.clientHeight, f = cc.container = e, a = cc._canvas = cc.$(cc.newElement("CANVAS")), e.appendChild(a));
		a.addClass("gameCanvas");
		a.setAttribute("width", b || 480);
		a.setAttribute("height", c || 320);
		a.setAttribute("tabindex", 99);
		a.style.outline = "none";
		e = f.style;
		e.width = (b || 480) + "px";
		e.height = (c || 320) + "px";
		e.margin = "0 auto";
		e.position = "relative";
		e.overflow = "hidden";
		f.top = "100%";
		cc._renderType === cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
			stencil: !0,
			preserveDrawingBuffer: !0,
			antialias: !cc.sys.isMobile,
			alpha: !0
		}));
		cc._renderContext ? (d.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = new cc.CanvasContextWrapper(a.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
		cc._gameDiv = f;
		cc.log(cc.ENGINE_VERSION);
		cc._setContextMenuEnable(!1);
		cc.sys.isMobile && (b = cc.newElement("style"), b.type = "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
		cc.view = cc.EGLView._getInstance();
		cc.inputManager.registerSystemEvent(cc._canvas);
		cc.director = cc.Director._getInstance();
		cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
		cc.winSize = cc.director.getWinSize();
		cc.saxParser = new cc.SAXParser;
		cc.plistParser = new cc.PlistParser
	}
};
cc._checkWebGLRenderMode = function() {
	if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw Error("This feature supports WebGL render mode only.");
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(a) {
	cc._isContextMenuEnable = a;
	cc._canvas.oncontextmenu = function() {
		if (!cc._isContextMenuEnable) return !1
	}
};
cc.game = {
	DEBUG_MODE_NONE: 0,
	DEBUG_MODE_INFO: 1,
	DEBUG_MODE_WARN: 2,
	DEBUG_MODE_ERROR: 3,
	DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
	DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
	DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
	EVENT_HIDE: "game_on_hide",
	EVENT_SHOW: "game_on_show",
	EVENT_RESIZE: "game_on_resize",
	_eventHide: null,
	_eventShow: null,
	_onBeforeStartArr: [],
	CONFIG_KEY: {
		engineDir: "engineDir",
		dependencies: "dependencies",
		debugMode: "debugMode",
		showFPS: "showFPS",
		frameRate: "frameRate",
		id: "id",
		renderMode: "renderMode",
		jsList: "jsList",
		classReleaseMode: "classReleaseMode"
	},
	_prepareCalled: !1,
	_prepared: !1,
	_paused: !0,
	_intervalId: null,
	_lastTime: null,
	_frameTime: null,
	config: null,
	onStart: null,
	onStop: null,
	setFrameRate: function(a) {
		this.config[this.CONFIG_KEY.frameRate] = a;
		this._intervalId && window.cancelAnimationFrame(this._intervalId);
		this._paused = !0;
		this._setAnimFrame();
		this._runMainLoop()
	},
	_setAnimFrame: function() {
		this._lastTime = new Date;
		this._frameTime = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
		cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || 60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
	},
	_stTime: function(a) {
		var b = (new Date).getTime(),
			c = Math.max(0, cc.game._frameTime - (b - cc.game._lastTime)),
			d = window.setTimeout(function() {
				a()
			}, c);
		cc.game._lastTime = b + c;
		return d
	},
	_ctTime: function(a) {
		window.clearTimeout(a)
	},
	_runMainLoop: function() {
		var a = this,
			b, c = cc.director;
		c.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
		b = function() {
			a._paused || (c.mainLoop(), a._intervalId && window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(b))
		};
		window.requestAnimFrame(b);
		a._paused = !1
	},
	restart: function() {
		cc.director.popToSceneStackLevel(0);
		cc.audioEngine && cc.audioEngine.end();
		cc.game.onStart()
	},
	run: function(a) {
		var b = this,
			c = function() {
				a && (b.config[b.CONFIG_KEY.id] = a);
				b._prepareCalled || b.prepare(function() {
					b._prepared = !0
				});
				cc._supportRender && (b._checkPrepare = setInterval(function() {
					b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
				}, 10))
			};
		document.body ? c() : cc._addEventListener(window, "load", function() {
			this.removeEventListener("load", arguments.callee, !1);
			c()
		}, !1)
	},
	_initConfig: function() {
		var a = this.CONFIG_KEY,
			b = function(b) {
				b[a.engineDir] = b[a.engineDir] || "frameworks/cocos2d-html5";
				null == b[a.debugMode] && (b[a.debugMode] = 0);
				b[a.frameRate] = b[a.frameRate] || 60;
				null == b[a.renderMode] && (b[a.renderMode] = 1);
				return b
			};
		if (document.ccConfig) this.config = b(document.ccConfig);
		else try {
			for (var c = document.getElementsByTagName("script"), d = 0; d < c.length; d++) {
				var e = c[d].getAttribute("cocos");
				if ("" === e || e) break
			}
			var f, k, m;
			if (d < c.length) {
				if (f = c[d].src) m = /(.*)\//.exec(f)[0], cc.loader.resPath = m, f = cc.path.join(m, "project.json");
				k = cc.loader._loadTxtSync(f)
			}
			k || (k = cc.loader._loadTxtSync("project.json"));
			var n = JSON.parse(k);
			this.config = b(n || {})
		} catch (p) {
			cc.log("Failed to read or parse project.json"), this.config = b({})
		}
		cc._initSys(this.config, a)
	},
	_jsAddedCache: {},
	_getJsListOfModule: function(a, b, c) {
		var d = this._jsAddedCache;
		if (d[b]) return null;
		c = c || "";
		var e = [],
			f = a[b];
		if (!f) throw Error("can not find module [" + b + "]");
		b = cc.path;
		for (var k = 0, m = f.length; k < m; k++) {
			var n = f[k];
			if (!d[n]) {
				var p = b.extname(n);
				p ? ".js" === p.toLowerCase() && e.push(b.join(c, n)) : (p = this._getJsListOfModule(a, n, c)) && (e = e.concat(p));
				d[n] = 1
			}
		}
		return e
	},
	prepare: function(a) {
		var b = this,
			c = b.config,
			d = b.CONFIG_KEY,
			e = c[d.engineDir],
			f = cc.loader;
		if (!cc._supportRender) throw Error("The renderer doesn't support the renderMode " + c[d.renderMode]);
		b._prepareCalled = !0;
		var k = c[d.jsList] || [];
		cc.Class ? f.loadJsWithImg("", k, function(c) {
			if (c) throw Error(c);
			b._prepared = !0;
			a && a()
		}) : (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function(d, f) {
			if (d) throw Error(d);
			var p = c.modules || [],
				r = f.module,
				s = [];
			cc._renderType === cc._RENDER_TYPE_WEBGL ? p.splice(0, 0, "shaders") : 0 > p.indexOf("core") && p.splice(0, 0, "core");
			for (var u = 0, t = p.length; u < t; u++) {
				var w = b._getJsListOfModule(r, p[u], e);
				w && (s = s.concat(w))
			}
			s = s.concat(k);
			cc.loader.loadJsWithImg(s, function(c) {
				if (c) throw Error(c);
				b._prepared = !0;
				a && a()
			})
		}))
	}
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind ||
function(a) {
	if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	var b = Array.prototype.slice.call(arguments, 1),
		c = this,
		d = function() {},
		e = function() {
			return c.apply(this instanceof d && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
		};
	d.prototype = this.prototype;
	e.prototype = new d;
	return e
};
cc._urlRegExp = RegExp("", "i");
console.log("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\¡-\￿0-9]-*)*[a-z\¡-\￿0-9]+)(?:\\.(?:[a-z\¡-\￿0-9]-*)*[a-z\¡-\￿0-9]+)*(?:\\.(?:[a-z\¡-\￿]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$");
cc._LogInfos = {
	ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
	ActionManager_removeAction: "cocos2d: removeAction: Target not found",
	ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
	ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
	ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
	ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
	configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
	configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
	configuration_loadConfigFile_2: "Please load the resource first : %s",
	Director_resume: "cocos2d: Director: Error in gettimeofday",
	Director_setProjection: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
	Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
	Director_popScene: "running scene should not null",
	Director_pushScene: "the scene should not null",
	arrayVerifyType: "element type is wrong!",
	Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
	Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
	Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
	Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
	Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
	Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
	Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
	Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
	Node_getRotation: "RotationX != RotationY. Don't know which one to return",
	Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
	Node_addChild: "An Node can't be added as a child of itself.",
	Node_addChild_2: "child already added. It can't be added again",
	Node_addChild_3: "child must be non-null",
	Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
	Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
	Node_removeChildByTag: "argument tag is an invalid tag",
	Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
	Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
	Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
	Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
	Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
	Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
	Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
	Node_reorderChild: "child must be non-null",
	Node_runAction: "cc.Node.runAction(): action must be non-null",
	Node_schedule: "callback function must be non-null",
	Node_schedule_2: "interval must be positive",
	Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
	AtlasNode_initWithTileFile: "",
	AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
	_EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
	_EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
	_EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
	_EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
	EventListener_create: "Invalid parameter.",
	__getListenerID: "Don't call this method if the event is for touch.",
	eventManager__forceAddEventListener: "Invalid scene graph priority!",
	eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
	eventManager_removeListeners: "Invalid listener type!",
	eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
	eventManager_addListener_2: "Invalid parameters.",
	eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
	eventManager_addListener_4: "The listener has been registered, please don't register it again.",
	LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
	LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
	LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
	EGLView_setDesignResolutionSize: "Resolution not valid",
	EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
	inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
	swap: "cc.swap is being modified from original macro, please check usage",
	checkGLErrorDebug: "WebGL error %s",
	animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
	animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
	animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
	animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
	animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
	animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
	animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
	animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
	Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
	Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
	Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
	Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
	Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
	Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
	Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
	Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
	Sprite_initWithSpriteFrameName1: " is null, please check.",
	Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
	Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
	Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
	Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
	Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
	Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
	Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
	Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
	Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	Sprite_setSpriteFrame: "Invalid spriteFrameName",
	Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
	Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
	SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
	SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
	SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
	SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
	SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
	SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
	spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
	spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
	spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
	spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
	spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
	spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
	spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
	CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
	CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
	CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
	CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
	CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
	CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
	CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
	TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
	TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
	TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
	TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
	TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
	TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
	TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
	TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
	TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
	TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
	TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
	TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
	TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
	TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
	textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
	textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
	textureCache_addPVRImage: "addPVRImage does not support on HTML5",
	textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
	textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
	textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
	textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
	textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
	Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
	Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
	Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
	Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
	Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
	Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
	Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
	Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
	Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
	Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
	Texture2D_initWithData: "NSInternalInconsistencyException",
	MissingFile: "Missing file: %s",
	radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
	RectWidth: "Rect width exceeds maximum margin: %s",
	RectHeight: "Rect height exceeds maximum margin: %s",
	EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
	EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
	if (cc._canvas) {
		var b = cc._logList,
			c = document;
		if (!b) {
			var d = c.createElement("Div"),
				b = d.style;
			d.setAttribute("id", "logInfoDiv");
			cc._canvas.parentNode.appendChild(d);
			d.setAttribute("width", "200");
			d.setAttribute("height", cc._canvas.height);
			b.zIndex = "99999";
			b.position = "absolute";
			b.top = "0";
			b.left = "0";
			b = cc._logList = c.createElement("textarea");
			c = b.style;
			b.setAttribute("rows", "20");
			b.setAttribute("cols", "30");
			b.setAttribute("disabled", !0);
			d.appendChild(b);
			c.backgroundColor = "transparent";
			c.borderBottom = "1px solid #cccccc";
			c.borderRightWidth = "0px";
			c.borderLeftWidth = "0px";
			c.borderTopWidth = "0px";
			c.borderTopStyle = "none";
			c.borderRightStyle = "none";
			c.borderLeftStyle = "none";
			c.padding = "0px";
			c.margin = 0
		}
		b.value = b.value + a + "\r\n";
		b.scrollTop = b.scrollHeight
	}
};
cc._formatString = function(a) {
	if (cc.isObject(a)) try {
		return JSON.stringify(a)
	} catch (b) {
		return ""
	} else return a
};
cc._initDebugSetting = function(a) {
	var b = cc.game;
	if (a !== b.DEBUG_MODE_NONE) {
		var c;
		a > b.DEBUG_MODE_ERROR ? (c = cc._logToWebPage.bind(cc), cc.error = function() {
			c("ERROR :  " + cc.formatStr.apply(cc, arguments))
		}, cc.assert = function(a, b) {
			if (!a && b) {
				for (var f = 2; f < arguments.length; f++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[f]));
				c("Assert: " + b)
			}
		}, a !== b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
			c("WARN :  " + cc.formatStr.apply(cc, arguments))
		}), a === b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
			c(cc.formatStr.apply(cc, arguments))
		})) : console && console.log.apply && (cc.error = function() {
			return console.error.apply(console, arguments)
		}, cc.assert = function(a, b) {
			if (!a && b) {
				for (var c = 2; c < arguments.length; c++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
				throw Error(b);
			}
		}, a !== b.DEBUG_MODE_ERROR && (cc.warn = function() {
			return console.warn.apply(console, arguments)
		}), a === b.DEBUG_MODE_INFO && (cc.log = function() {
			return console.log.apply(console, arguments)
		}))
	}
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.loader.loadBinary = function(a, b) {
	var c = this,
		d = this.getXMLHttpRequest(),
		e = "load " + a + " failed!";
	d.open("GET", a, !0);
	cc.loader.loadBinary._IEFilter ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
		if (4 === d.readyState && 200 === d.status) {
			var a = cc._convertResponseBodyToText(d.responseBody);
			b(null, c._str2Uint8Array(a))
		} else b(e)
	}) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset=x-user-defined"), d.onload = function() {
		4 === d.readyState && 200 === d.status ? b(null, c._str2Uint8Array(d.responseText)) : b(e)
	});
	d.send(null)
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function(a) {
	if (!a) return null;
	for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = a.charCodeAt(c) & 255;
	return b
};
cc.loader.loadBinarySync = function(a) {
	var b = this.getXMLHttpRequest(),
		c = "load " + a + " failed!";
	b.open("GET", a, !1);
	a = null;
	if (cc.loader.loadBinary._IEFilter) {
		b.setRequestHeader("Accept-Charset", "x-user-defined");
		b.send(null);
		if (200 !== b.status) return cc.log(c), null;
		(b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
	} else {
		b.overrideMimeType && b.overrideMimeType("text/plain; charset=x-user-defined");
		b.send(null);
		if (200 !== b.status) return cc.log(c), null;
		a = this._str2Uint8Array(b.responseText)
	}
	return a
};
window.Uint8Array = window.Uint8Array || window.Array;
if (cc.loader.loadBinary._IEFilter) {
	var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n',
		myVBScript = cc.newElement("script");
	myVBScript.type = "text/vbscript";
	myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
	document.body.appendChild(myVBScript);
	cc._convertResponseBodyToText = function(a) {
		for (var b = {}, c = 0; 256 > c; c++)
		for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
		c = IEBinaryToArray_ByteStr(a);
		a = IEBinaryToArray_ByteStr_Last(a);
		return c.replace(/[\s\S]/g, function(a) {
			return b[a]
		}) + a
	}
};
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=";
cc._loaderImage = "data:image/jpg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjFDRUZEN0Y3QjgxNTExRTVBRkE1OUZFMUZGMEE1RUNBIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjFDRUZEN0Y2QjgxNTExRTVBRkE1OUZFMUZGMEE1RUNBIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAwMDAwMDAwMDAwEBAQEBAQECAQECAgIBAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD/8AAEQgAyACgAwERAAIRAQMRAf/EALsAAQACAwEBAQADAAAAAAAAAAAHCQYICgUDBAECCwEBAAICAwEBAQAAAAAAAAAAAAcIBgkDBAUCAQoQAAAGAgEDAwMBBQYEBwAAAAECAwQFBgAHERITCCEUCTEiFUFRYTIWCnFSIzMkF4FiokPwkcFCklMYEQACAQMDAgQDBgIGBwYHAQABAgMAEQQSBQYhBzFBEwhRYSJxgZEyIxShFUJSYnKSM/CxwYLCQySyY3OTFhei0lODszQnCf/aAAwDAQACEQMRAD8A7+MUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilfNVVJBJRZdVNFFIhlFVVTlTSTTKHJjqKHECEIUA5EREAAM45poseJp52VIUBLMxAVQOpJJsAB5k9BX0iPI4jjBaRjYAC5J+AA8TWpe//ACjr+u6POv8AXExV7jeWHaFpC9UjKsBQ7oJv3JnELw0VWjkRFXsmdIioBBKA9XBRrn3E9yvbrjOK+3cc3jbc3lzSrFHEpkmiDFgrepLADEpXr0eZLsNN79K9/duB9xMXjOVyPA2md8fFgMzhwEf0lF3dISRLKUW76EW7KDYjpVatZ+RPfMZYWktYl69Z657gikhXCQbCLKswMYBXTjJRimR+2dlREewoqdwQDgAnIoHIDDW1e4vuBi7sk26HGydv1gPD6Sx/TexCOv1Kw8i+sA+KkdKr3FzrdkIy3KTYoGrSoA1r4/Sw63t+U+HhcHrVi8P5u6vk0mjhWCuLNq9bpOUXINIh0kCayZVExMVKYKtwJTevBREB/TMkg98XbFc58Ddtt3zFkjkZGb0seRVKmxvpydVrjyU1c3D7Hcj3XZ8bfNmzNvyMHLxo54jqkQtHKgdT1isDY2IJFiCPKpxqO9NVXZRJtB3CNB+sIFJGSgqw0gdQf+0ihJptgdqfuQMrk3cM7/8AaLnkiY2wb1ijcX6CCfVjTE/1VScJ6jfKIvWGb5245px5Wl3HAl/bL4yR2lQD4loy2kf3wtS1kx1hFMUpilMUpilMUpilMUpilMUpilMUpilMUqDdzb0reoo8qS5Ql7U/QMpFV9BQCiBOTEK/lVg6hZRwHKIF9BUXMUSkDgDnJAXfD3A8V7L7esGUP3vLsmMvj4SNpJW5X1p3sfRh1AgHSzyMrLGpCyNHI3AO2+786yS8R/b7LE1pJ2Fxe19Ea9NcliCRcBAQWIuoar7YO4L9st0opZZxwaPFQTt4JgY7KDaByAkKmwTOJVzp8eii5lVv+fNTvcfvT3F7p5TS8q3CQ7cWumJCTFiR/ALCCQ5Hk8pkk/t1cXjHBOMcRhCbRjKMm1jM9nmb43cjoD/VQKv9moy5HnkBHq555/Xn/wBecikgWsfy1mSsysGW+sHpUMTlPgJyadsK01WQk0D9Uy7brFTrkY4VAVOwuiJFBWk1imAfbthJ08gKhiAIcy5s3Ld82XZ4s7kUivtjr/08bKTlzKvTUrXGmFSLerNq1WIjDW6Uj552V7ec+5zmce7X4s2PyuBwdyyYZAmy4E0n1+lLEVYy50gIY4eCY9GoPkPCGAbEYrYligUEIkG8c6axXXHlQcorpOBI0UOgJTuU1jCVQBIPr0CAfszKty4DsG9zSboZMiLKyrSlkZWS7qGuEK2I6+GofbUOcT9yfcrt9gY/EFxtsy9o2jViCKeKSOYrju0ZDTpISrgqbH0yBYXU9bz5ATbSxRLWWZlOmm4A5FW6olFVq5RMKbhsoYv2mFNQPQwehiiA/rkIb5s+VsG6S7VllWkjsQy30ujC6OL9RceIPgbithPb3nW0dyeIYnMNlWSLGyQyvDIQZIJ4m0TQuV+lijj6XHR0KsLXtW0Gq/JK+a4Xasnjxe0VUgkTWhJVc6q7VuAjz+GkVOtdioTn7UzdxuIenbAeDBYDtF7oe4XbLIhwM6eTd+IBgHxchyzxp5/tp2u8RHkh1QnqNCk6xj/NO0vGuVxPkY8a4W9EEiWNQFZv+9jFlcHzYWf+0QLG0yk3eu7Br7Sy1h77yOdCdI5Tk7Tpk7SAvfYvm4iYUHSPWAiHIlMQxTkMYhimHbXwHn3Ge5fGYOV8Tn9bbZujKbCWGUAF4J0BPpzR3GpbkEFXRnjdHamnIuO7rxbdZNn3iP08tOoI6q6m+mSNrDUjW6HoQQVYBgVGW5mdeHTFKYpTFKYpTFKYpTFKYpTFKYpUR7l2zFakqp5d0CbqZfis0rsScw/658QgGOssBDFUBgxBQplhAS8iYpAMUxyiELd8+8u0dmOHtvOSEn5Dklo8HFJsZpgBd3t9Qx4AyvO48AUjU+pLGDnXAOD5vOd6GDFqj22KzZEoH5EJNgL9DI9iEHyZiCqNVO9lskzb5ySsdgeqv5aVcHcunCoh9R4KmikUAKRJu3SKVNJMoAVNMoFKAAABmlDknJN75fvuTyXkmQ+VveZKZJZG8SegAVR9KIigJHGoCRoqogCqBV8dq2vA2Tb4tq2uNYcCBNKKPIeZJ8WYm5ZjcsxLEkk14WeHXoV5E+rLIwskpBNgdzHtjkj0RORMO+pwmCwmUMQg+2KYVOnnk3Txnq7JFtc2748e9yeltPqAytYn6R102AJ+sgLe1gDc1h3cLL5fg8I3PI4BijM5p+1ZcOIsqD1X+gS3dlU+iCZQl7uUCjqa/rX4ZCAh2UWgInMgn3Hbgw8rPJBce6+erqcAZRZw5MYwiPI8cB9Az933dpt93abc5wAHayIPyxxL9McajwCqgAAHzNfHbvhWB274Zg8T28l3x49eRM3WTJzJf1MrKlewLyzTMzFmubWANgKwS160TmXq8rDvEmD50fuPGrohzMXSwhwZymolyq1XU4Dr9DEMPrwA8iObcX7iSbRhpte7QvPhRC0boQJEXyQhujqP6PUMB0uQBav/AHd9r2NzffJ+X8LzYdu33LfXk486M2LPLaxmR4/rglew9QaXjdvr0qxYtktHgXtcgQjpAyBnRn712f2ygrIlKschUgKoYiYiIppAIhx6COY9zPe8TkG+HcMEOMUQRoNY0tdQS1xc+ZsOvUCpO7C9vt77ZdvhxrkTY7bu245WQ/ouZIwsrKIwrlUJJRAWGkWYkday/MUqZq2R8YtmOqLsSNiXLk4Vy3uEISSbGNwii+dKlSiZMAESkIo1eHAhzmHpK3VVHjnjizvtS7o5Xb3udjbTkyEcZ32WPEyEP5VlYlcWcf1WSVxG7eHoyuWvpQrE/eHiUPJOKS5sSX3Xb1aaMjxKAXmjPxDINQHjrRQPE3twzcvVHKYpTFKYpTFKYpTFKYpTFKYpX45GQZREe+lZJykzjoxm5kH7tYRKi1Zs0TuHThUQARBNFFMxh9PoGdPcdwwtp2+fddylSHbsaF5ZZGNlSONS7ux8lVQSfkK58bGnzMmPDxUL5MrqiKPFmYhVUfMkgCqWtvbKkdpXaTsbsyiUeU4soGOOb7Y6GbnODRISgc5PcrdQqrmARAyyhungvSAaLe8/dLcu7nO8rlOWXXbATFhwn/kYqk+mtuv6j9ZZjc3ldgCEVFXYJwbiOJwvj8W0QAHKtrnkH/MlI+o/3V6Kg8lUX+okmL8imswpilMUpilMUpilMUr6oKqoLoronMksiqRVJQn8aahDAYhy/wDMUwAIZywzy4syZOOxSeNgysOhDKbgg+RBAINfEkaSxtFINUbAgj4gixH3ir5a/JfmYGEmOAL+WiI2S6QEBAPfMkXXACUAAQDu/p6Z/Qvx7c/51sGDvIFhl4cM3/mxq/8AxVrU3PE/YbjkYP8A9Gd4/wDAxX/ZXr57FdKmKUxSmKUxSmKUxSmKUxStN/MfYB4Gmx1Ij1xTf29cy8mKZuFE4GNUTUMibpMVRL8lICmUDByU6SCpBAQNlI/e53Gfj3B8XgW3vp3He5S01j1XDxyrMpt1HrTGNR5NGkyG4Jqe+wnGF3Lf5uRZK3xsBAI7+BmkBAPwOiMMfiGZGHUVWNmqergUxSmKUxSmKUxSmKUxSmKVdnpZ6EhqXXTjrFQQqEG1McR5EVGLFJipyP7QUbiH/DN7/Y3PG5dnOM5WrWf5JiIT/aihWJh9zIR91a8+4GP+15vusNrD9/MwHydy4/EMDUnZKtYhTFKYpTFKYpTFKYpTFKYpVNPlTsOKkdl3ewT09DwFTo6C0Q5nrFLx8FX4GIrRVvzEjLTcs5ZxcZHJyXuljLLKppgQweo+nOlb3Ocqy+f98dzg29ZcmPClXbsaONWkdjj3WRI0QFnLZTTsoUE/V8r1entZtmNxft7iz5rLF66HKlZugHq2KE/C0QjB+FifDw5ivLD+o98JtDyEpU9EwFr8trnHGcNlJqtPi680yg/QHtikjeJuLk7Lam3cEeFo6GKzVKXlJ0cogI5x2+9lfc7lcMe4csmx+Pba9iEkX9xmFT5mBGWOI2/oyTawejRg3rGOR9+eP7bIcfZYnzZRe7A6I/y/1yD1VvNUkRgOjdapsvH9UX5uy8morrzTHjDr6F4EEY6Rqd3vsmA9ZhAy8zNXtmgqboEAHoZpFEQ5AA54yym1exDtbjQBd43LfMzK82WWCBfuRIGI+9zUX5ffzlsx048GJHGPiJC33lJI1P8AgFb5/FJ85XmD5ueZGuPGbb+vPH81SvEbepSXtlHqNrqNrrjOl0Ky24rmPD+cpmBfi8fwyDZQjhoBQSWMYpgOBcib3Ae1btx2v7a5vOOO5m7/AMxxXgVIp5YpYpDNkRRWb9FJF0q7MCr+IAItesz7cd2uTcm5Pj7BuEWIMWUSFnUShhojdlF2kcdXCjwH2+R6qsoDVlqYpUT79vli1ToPeu16hCxdltmq9ObJ2VWq3OqvEISwTNGqcpZmkPLrRyreRSjnwxokVFBRNbpH7TFH1zIeIbThcg5dtPH9ylkg2/P3LGxpJIwC8aTyrEXQMCupdVxqBHxFePyDOyNs2PM3HECtkwY0sihvAsiMyg/awA++uJOS/qe/kNcvll42i+KkOwMsc6EYnqezSBUUBMIkQO9k9jOny4kL6CfrKYfr6ZtEg9i3ZyOIJNl7/JLbqxyolufjZcYKPstVR5u/HM5ZTIsWEi38As1v/wA9bE6Y/qoNvx7tg08ivFbVl2ijLdEnO6esVp1lYkG5jDy4ZxNmd7DrrxwkUf8AKMDYqg/9wuYbyb2EcbmjeThu/wCfi5FvpTMjiyYyfgXiGPIoPx+oj4Gvb2z3Cb1FIP5thwSxhSP0mZOvkxD+oWt8Nag+FxXRR4Y/Kt4SedhG0Rp3Z41faSjUXLnR23EGNK2UIkS7rglY5kHtX2ERsQDCYIZ+4dgUOo7ZMMpp3M9v/dDtQWyeR4P7jYQ1hnYhabG8bD1fpWXHv0t60aoSbByam/indDi3LGXHxZTDuB/5Un0ufy+A6g3JPRGcKq3Zh0rp/wDE2fCa03EtDH6l65KTEGsA8dRQ91+WbFEOAEAI0lSFDn9C5sn9nXIhvvY/Cw2bVPteXk4jfH/M/cJ+EWQij5Cqzd7ts/l/Pp5wLR5cMUw/w+m34tGx++tlctLUR0xSmKUxSmKUxSmKUxSvLm5NOFhZeYVDqSiYt/JqF/vJsGiro4fUPqVIc8vfN0j2TZMzepusOHiyzt5dIo2kPX7FrubfiNn58GAn555kjH2uwUf665q/KXREP5eeP+9vHW2qI9jelCsVUbSTggKkiLq5FOaoVmApuS9dd2BGxr7keQ6URAeQEc0J8Q53ufD+f4HcVGZ9wxNxGVL5GVHZv3SH/wAaGSVD/erYPybYMTduLz7E1lxTj6FveyBVsrWHVjGBrUebKvjX+WjXPHrelz2FYNUUfUWxb3saqz0hWbDT6NT5+4TsTNxUm4hn7J6wrrCRWbi2kmiiRjmACAYg+vADm9zN5jxTbNmh5Buu44WJsuRCssc080cMbo6h1ZWkZQbqQbDrY1r/AIdl3bJzn23Fxp5s6NyrJGjOwZSVIIUE9CCKsKo3wWfKtfEkHLTxFuFXZuUU3CbrYll1/rsQTV4EgHYXG2Q8sRQCjyYgt+ogfxAA8cw9u3ur7BbQxSXkWPPIDa2PFkZHh8GhidLfPVY+VZft/avnm5//AK2AwA8dckSEfarOGB+Vr+VXu/Cv8PXmR4S+YKfkF5G1rXteprPT+y6nHowGzKldLGS1XFjHxMYkaIrjyQFFt7I7oVXHc6EwDjkRMADVD3N+5Dtr3O7cHiHC58ybcn3HGlYyY0sMfpQlmY6pAtzq0WW1z91S12v7Zcn4/wAnG57xEkcCQm31EnV6kZtcDT+UN4NXVdmv+rP0xSsJ2fWFrxqvbFFbAkLy9ao2bSI8q5ypoHk7dRZ+uxhF1T/YggeQkkgOob7SEETD6AOetsGem08g2/dpL+liZ+NO1up0xTxyNYeZ0qbDzPSvK3zDm3HaMjBx7erLGVFzYdfHr9l6/wA+iT/p7fldj0DrI+O8HLiQom7EPurSjpwcQDnpImrfm/Ucf2c/XNwUHvD9v8z6G3mWP5vhZoH4jHNUtfsv3FRC/wCxUgf9/AP+1IK1X2n8VHyO6XjlpjYfhnvmNh2xDKOZeEpL67RTVIhypmVdSVHGxsmyJTGD71FCl49eePXM+2Hv72X5LMMfZ+S7S+Q3gjzLA5PwCz+mxPyAJrF8zgvL8EM0+35JVfzFF9UL9piLgD5mt3P6fHxJW318hlfu9vgF1KR4kRbrd1nbyTExW5dgwsghCakgH6S4EVbSJNhvEJQqZi9XahFwEA6RyLveB3DXiXZ2ba9umA3TkMgwoirdf27qXy5Ft0KnHBiJB8Z1rK+z/HDvXMo5Z1P7fC/Ua9x+oOiAG3R1OqVb9CYiPOv9RHwhsZvf3qrLKiczptHWJsUw/cB2qykfJKDybk4q+9bc8B6dPr9QyCfYRyTRm8g4dI30vFBmRLfw0M0E5t89eOL/ACH3SZ7itr1Y+272g6q8kDH+8BJGPu0yfjVhObJaq5TFKYpTFKYpTFKYpTFKi7droWeo9jLFESiaozLbkBEB4eNFGY8CH6iC+RN33yzhdmeTzgkE7LlJ0/72No/+Pr8qzLt5CJ+c7TGeoGdE3+Bg3+yqUAEQEBKIlEBAQMURAQEPUBAQ9QEBzRJ49D4VsJrzq9DwlQRmG9OgYGno2KZkrHZE6nCRlbCyWOacnezNhsZoZqyPPTsu9UMs5duxWcLKmExjCI5z5mVl7iY23GabJaGJY4/VdpPTjQaUjj1k6I0UAKiWVQLAV04tvwYHaSGGNHeQyEhQLufzP/eY9WI6sepua9ARER5H1EfURH6iOcFdymKUxSmKUxSmKV927py0UBZo5Xaql/hVbrKIKB+8DpGKYB/458siOLOAR8xevl0SRDHIA0Z8QRcH7Qa8NvAV1lOT1pYVutxtptacWjbLRGQERG2O2IwYOywidpnGLNvJWIsMEg49r7xVYW/fU6BDrNz25MzNmxYcCaed8DHLGKJpHaOIvbWYkYlY9eldegDVpF72FdeHCxMaWSeCJEnltrYAAtpuFBPwW50jwFzbxNbT+J0qMbumBbip2yTMdORSnrwCgfi3EkkkYf2HcxyfAfqYAyzHs83g7V302/HL6Y87Ey8dvgf0WnVfveBbfPp51F/e3C/d9vsmUC7Y80Mg+X6gjJ+5ZD91W35uTqj1MUpilMUpilMUpilMUqLt2tDPdR7GRKBjCWozLngociPsmh3g8AH7kMibvvhtn9muTY6Alhs2S9h4/pRmX/grMu3k4x+c7VITYfvol/xsE/4qpPzRJWwmmKUxSmKUxSmKUxSmKUxSmKVL2glTI7k16YvPJrE2S9P0KuRVE/8AaHQcf/Hpk0+3WdsfvfxqRPE7kq/c6Oh/gx/061gnc1BJwHdVPh+1J/wlWH8RV0eby61/0xSmKUxSmKUxSmKUxSvwSschLxkjEuuRbSbB5HOADjkUHrdRstxz6c9tUc8/dttx942rJ2jKv+1yseSF7eOiVCjfwY12cPKkwsuLNh/zYZFdftRgw/iKogm4l5AzMrByBO2+h5F7GPCf3HTByo1cFDn6gVVIQz+fHfdmzeOb5mcf3FdO4YOVLjyD4PC7Rt911NvlWybb86Dc8CDcsU3xsiFJFP8AZdQw/ga8zPJruVr95YeQUN4oeMu8vJSdgnFqY6aoL21N6q2dKMDWeecv46u1SAcSSKDpWKjJO0TbNN67KmodszFVQhTHKUo5j294fk9wec7VwnFlGPLuWWsRlI1elGFaSWQKSA7LEjlEJAZ9KkgEmsb5bv68Z4/k70ylzDGSAPNrHSD8LmwvY6b6ipAIrj48bP6lTzGW8iqgHkPCarueh7jcYmDttJpuvmFPnKRXZyTQYKzWvLHHqOZ53L1hJyDlJrMLySUmVEW6p0zqg5S2Pc29knbZeGZP/o6XPxuV42M7xTzZDTJPIilgmRGwEYSUjSWhWMxkhwGC6Gq7sXfDlP8APIm3QxPtssoVkVWHpqzC5S7EnT8GLEi6hkJDDuRetRZPHTQVCqi2XVQ7pSmIVUEziQFAIb7iAoAc8D6hzwOaro3EiBx0uL1cON/UjWS1tSg26G1xe1x0/CvzZ9V918XTtlGsZKWk1FkYuFipWdlVm6XfcpRUHHOpaTUaoCIAu6IwZqCmTkAOfgP1z7iilnmTHgAM8siooJsNTsFW58hqIufIV18rITFx2yH/ACqPn4+Avbra5F7eVcK94/qbvNp7vF7btd1HUFd0Q1sJ/wAFpKwUhlOvJGmouulFpa9igslcT2uQjy8uHse6Zt0HJ+UG4JFAg7W9q9jfa+Liq7dvORuM3K2h/UzY5igWYjqYsexh9JW/KkiuxUfU+o3FOczvpy2Td2y8P0k20SXWEqTdAempgfzW8dNlv4qet+13R22q/v8A0jpzfNTjpKGrO6dZU7Z0JCTB01ZaCa22HbyKsDIrolKi6dQj46rQy5ABNwCIKl+04ZrA5Xx3L4hyncuJ7g6SZu2Z02M7p0RzC5UOoPUBwAwU9VvpPUVbbYN3j33Z8bdoxpXIhSTT5rrUOAfnZhe1wDcAkC5lHPAr2KnvxliFZfdVOAnonHLSEs4Pxz0JsIx4qn6fT/Eddsn7urnLD+1XZZt677bIIwTFivPkubE2WKCQqT8LyGNbmwuw+wxn3fzkwe32eW/PMqRL8y8ig/guo/YD9tXDZutqiFMUpilMUpilMUpilMUpilVp+YGrF4exp7Jimwmh7F2Gs72iiJWE8gl2k3CpQACpIS7RIogIAPLhNUTiBlCAbVr71e0mRsfJ07pbREW2TdCseXpHSHLRQqO1vBMmNR1tYTRuWbVMgNuOxHM4s/aW4jmuBn4l2huerwsSzKPnExPn+RlsLIxrSrKLVYOon3U10jaNfXjUu/Jak/7f7OqEzTrtUbVZ2kG4matPtBavUyEReIzsW7TA5HDJ4iUizV0kkukbrIUcy3heFzs7xi8i4DhbjPuuBkpLDNjY7yoksbXH1aTEw6FXQkhlLIwsTX7JxLO5ht823Y+BlZuHKrIxjid1+oFSA4Gm9iQbMGFzYqbEUSeKvwDfHprryDru5YLyKs/kdHUaysrlr/TMy/ojOPJNwz9OSr6l2f194Wcv0bBP0EljMm0fFoyBkQK5AzcyqClsu5Xum765HDZuO73xw8ffKhaHIzfRyfyOumQQ+opix2dSVDvLIyXvGQ4VhDeN7a24lu67vvkO4x4cMgeNZoiqhlYFfUcRhGt4+KrqA1B1up6N1llXCyrhdQyq66h1llT/AMaiqphOoofgADqOcwiP78o8qqqhVFlAsPsqYVVUUIgAQCwA8AB4AfKvnn7X1X1QE4KlFNNNU33cpLJEXQVT6Dd5JyioApLNVEeoFSn+wyYmA32858uVC3YkD4g2IN+lj43va1ut7W61xyKjRlZPyEWP39Onnf4W63tbrXMVtL4Dfi0e79kL858p5vV2vZKyHsEv46QE7S38awFR2Lp/U6xsMqr+WrdTWWEUkklmL18ybGFNNwYSkULsD4z7lfc1Nw1NuwuIz7luiQCNNyfHyELdLLLJjsEWWW3Usrojt1KWJBic+1Hct43I7nteDuv8nd9XprCVFj1shdVITyABvbwZelujvXbjWf8AKEBXNQPqUpQqNXIGp1eAosqwfxNUqddjGkLXIVuzbOVnjGOjYtmigmZcpRP08mMJxERo3yXA5VgbtLkcyxs/H3vMnklkfLikjeaaRi8r6mUK7MxZiEJt8LVMD7Dmcahi2rMxMjDSNAkaSxsnRRYKpYBTYDoqkgAWAAArNc8KuOrL/EHVTqtQr3YU42M3kbQ0SaQKCxDEWQr3cI5VeGKYQEoTLhJIyYCUB7KBTgIlVDNpnss7RZnGNiyO5e/wmLdN2hEWIjAh0wtQkMpBsR+6kVGQEf5UUcikrL0qL315pDu24RcW25w+JhuXmINwZ7FQnw/SUsD1/O7KQClbpZeiq/UxSmKUxSmKUxSo/qe1tbXqfuNUp94rVhs+vphaBu1djJVqvN1mVQBPuNpeLA4PWpOpXoKqJOydQpyFOJyHKXrQ5mLkSPDBIrSxsQwB6gjobjx6HpfwvcXuDWRbvxLk2w7dhbvvOBlY21bjCJcaZ42EU8Zv1jktpY9Llb6gCGIAZSZAzs1jtMUry5uEirHEyEFOMUJKJlGyjR8ycFEyS6Kn7yiU6aqZgAyahBKdM5QMUQMACHkb9sOz8o2bJ4/v+PHlbPlxGOWJxdWU/ZYqwNmR1IdHCujKygju7duGbtOdFuW3SNDmwuGR18QR/AgjoQbhgSCCCRVX21vF+5UKQXmaizc3CqJre5Q9siLqZjUin7hW0pGtyis7SSKHAuUCCmYpRMcqXIFzUx3p9o/NuDZGRufDop944YdRDRDVmY6EElZoVGqQIP8AnQqQQNTpF4VcXhPePYOS4yYG+umBvZGk6jphkPheNz0Qk/0HIIPRWfxqiHY/x5TExbZ+yVDajFc07LyEq8bbMipZ9ZGrp+6VdLM1LJGC5NJtmiqopomXRSVIkUpRD0zIOJe7XD2jZMbYOTbBNFJhwpCP5fJFHARGoTV+2lC+k7abyKrMpck+dXz4/wB+sPF2uDb912xwIYkRThuiwsqqAGET20FgLsFYqTcjxryal8c84nNR0ndNrwsc0j3jZ6U2vIeXTtYHbLEWKEZPSwskIZYwkAAcEIoqnyIlKIgGdzf/AHhbY+2zYXG9hyZp5o2S2fNEcWzAr+pBFraYC9/TYqrWsTau1unf/CbEkx9o2uaSWRCv/VSIYOot9caajIOv5SQD4E1aUY3UID93oUhOTnFRQwEIUgHWVMAGWWOBeTnEAE5xEw/XKOAWHl4k9BYdTewHkB4AeQsPKq1AW/Hy6Dr8B5AeQ8h0r+uftftYdsOlMtk0S2a/kpaagmFuiFYh1M11yDWZjyHVRXKs0OfhJYhlEAKsgcQTcIGOmYQAwjmRcR5Jk8N5Tgcsw8fGysrb8gSrDkLqhkIBWzgdQbMSjr9UbhXW5FetsG8Tce3vF33HihnnxZQ4jlF426EWYeI6G6sOqsAw6iqzXvxx3pmudKv7P125jQN/gGf16xw7wE/0Fy1ZEfswWAPr21BLz9Munje8Ti+TEJN22Td0zLfVoyMeZL/2Wcxvb4alv8asVD7gNklQNnbbnrkeemWKRb/Jm0tb7RetmvFb497dUtmRF4RtL65WqII8IygNeQkhDwDgH7ZVmcLpNSShVn8OiRcT+1ORFqdUCmOf7QzF+X93+Vd/Nmm7bduOLZeRBksnqSzlciSHSwcNFoAx8RmK6f3EsoKrdV/NUad0u/8AseXxqXacqCLB2qbTqly5FeUaWDf9NEgNpDYDWupwtwB1NX1ae8RWMGuzsWzFWsxIoHI4a1ZsPeiGypBA6R5ZyPSEooQeBMgQAbdReDGWIIhk4dlfZjt+wZEPJe6zwZ+5IQyYEf14qN4qchyB+4YecQUQXFmM6m1a+ed988ncY32vh6yY+K3RslukrDzEa9fSB8nJ9S3gIzW74ABQApQApSgAAAAAAAAHAAAB6AABl9gAoCqLKKrsSSbnxr+c/a/KYpTFKYpTFKgLyi3pD+NmhNmbmlwQXNTq44WgY1cxyknLdInTiqhBG7XKxUZWxvWySyhAEUG5lFRDpTMIefuueu24EmW1tSr9IPmx6L8Ol+pt1sCRUhdquBZnc7uDtfCcPUozckCVxa8WOgMmRL16Exwq7KpI1uFQdWFcNFSvu31NsM7xRrVbkdzWm3qPWNirUg8YWmaudumBUX7a8adFVdxYJmQEFUeBSWFUSGIJR6cgyHIyjliaF3/cs17gnUST8upJ/Emt8e8cf4aOIvsO/YmGeE4mEEaGdVeCLGxo7LcSXAEMSDSx+pdIbVqF671tVxF4gda0SG2ZZi3PYcbVYRrdrSmyYRyM5aE2CITT5uyjGjFig2Uf9YJARFPlMAEQ6hHJ6w0yI8WNMtteSEGo/FvPw/D5+Nfz98szNi3Dk+fm8Yxf2XHJcuVsaDU7mKAufSUtIzuWCW1XZvquAbWrPs7NY9TFKYpUdW7UuuL0KilnqMS/dqAYDSSaJmEqPIcAIykedq/P0/UAMoJef0yNOZdnO2PcAtJyvZcLJy28ZgpiyPvnhMcpt5AuRfyrKtj5vyzjgCbPnTxQD/lk64//AC3DIPuUGtfpvws129OdSFnrNBmN9EVFGMq0T9RH7CLNWzsfqH8S5vplcN+9i/bPPcy7FuG7bex/olosiMfYHjWT8ZTUobd7guVY6hNwxsPJA8wHjY/erFfwQVHbvwaeAc4sNjNlE+R7ZXdZVROAfoBzoza4CP7wKH9mRrmewTNDsdv5PE0fkJMFlPyuVymH3gD7KymD3GQED9ztLhvPTkAj7gYh/rr8Cfg7YBNwtf4chP7ycK9VN/8AAz1EP+rPPi9g/Iy1puRYSp8VxZWP4GVf9ddl/cXtgH6e2TlvnKg/joP+qsmi/ByNIJTTWwXrkvUHWlGQCDE3R+oEXdSUgAGH9opiAfszKtq9g21RkNvnJMiVb9VgxEi6fDVJNN1+ejp8DXj5nuLzGBG37XEht4yTM/X7Fjj/ANdTDWvFHTtfOms5iJCyuEwKJVLDIqLpdYfUwso9OOYqgP8AdUTOXj/zyauL+0DslxtlmycLI3TKW31Zk7Ot/iYohDCwPweNhWCbt3r57ugKRZEWJEfKCMKf8b+o4+0MK2Bi4iJg2acdCxkfEMEf8plGs27Fqn6AX7G7ZNJIo8FAOeOfTLHbTs20bDhJtux4uPh7dH+WKCNIo1+xECqPwqMMzOzdxnOVuE0s+S3i8jM7H7WYk16OelXVpilMUpilMUpilMUrmT+cnySCwXaj+L9df9cZREm2w9jJoHKJFLhOR6qNPhnJegqqa0HVXqz4wAYySpZlERDrSDiMec7l6k6bbGfpj+pv7xHQfcpv/v8AyraN7D+2R27Ys/upuUdsrcC2HhkjwxonByJF62IlyEWIXAZTjPb6XN4Q+GPxsDbXkW83HYGAOKZoNo2l2XuEinbSGy50jptU0CgoBesa6yQdSonTEwoOkWYmAAUDno8M2z93uP7uQXhgGr/eJ+j7eoLdDcFBfo1Z372O5p4f21Thm3Sad75C7RtY/UuFFpbIPS/+cxjgsbakaWx+k11t5Llafqp+8tfllp2kLlOaw1LUUNm3KsPl4m0T8nJnjqVBTLXqTfQzX2BFpGxyUW6L2XhUztEG6xTpgqdQihCQjzTvPgcezn2nZYBmZ0RIkctpiRgSCnQFnZSPqtpUeAYm4F4+ynss37uFsOPy/muc20bDmRrLjwxxiTLmiaxSVg5VII5F+uIsJHdSr+mEZWbWDXHzbXAk+0R23p2sOawu4Im9f68kJaOm41sYfvdN4yxv5djMKpB9ETOmQH/+0v64htff/NGQBveBEcQnqYGYOo+IWQsHPy1J9tS9yr//AD82Nttd+E77lpu6qSiZqRvFI3krSQJG8QP9cRy2/qnyvs11sKobXo9Z2NQplCfqFui0ZeElG4HT7zdUTpKoOW6xSOGMiwdpKN3TZUpF2zlJRJQpVCGKFjts3PB3nb4t022RZcGZAyMPMfZ4gg3DA2KsCCAQRWt3lXF984VyLM4pyWBsbfMGdopozY2YdQysLq8bqQ8ciEpJGyyIzKwJzTO/XgUxSmKUxSmKUxSmKUxSmKUxSmKUxSmKVHe3NnVrTGsb3ta4L+3rdBrMrZZPpOQi7okc2Oq3jWfX9qkjLO+21bE+qjhYhQ9Rzq5uVHg4kmXL+SNSbdBc+Si/S7GwHzIrJOH8W3Pm3KcDiWzLq3PcMqOBPgpdgC7fBI1u7nyRSfKuBrZ+xrLt7Yt32jcXHubPfrNLWmZMUxhQQdSztRwDBmUxjdqPjEDEbNkw+1NukQoegBkB5eRJl5L5EpvI7Ek/aSTa/gLnoPIdPAV/QZxbje2cO43g8V2VdO17fixwR/ErGoXW3xdzd3J6lmJPU1eF8dfyUeKfjFqGuaUttO2NV3zuUkbHd9kt4+MskLLWyYWQRcSTyOi3hLE0iY6GZtWaAN2jtbstCiYgnMYw5xxzku17ZiDCmSRWLEs4sQSeguOh6KAOl+o8OtUT9yPtj7td0+ZZPONnzdtyoEhSHGwmd4ZY8eMEhFd1MLO8jPIxeSNdUhAYKAKvb2luuD//AC5szemqrLF2mLZ6iutxpdlr7pCTjnL2PrkkvGOklUxMTljKIlBwkcAUROmcihSnKYoZbv27jE4xm7zgMGaLDlkQjqNSoxH4MOoPUWINUK4XwTOl7u7R2+5diy4mTLveLjZUMwKOqPPGsikH+shOgi4YMrKSCDXKP4X+PTXyp8hq5rSwzj+IrrhrNWi3yrE6R5xaHhUPcOGcUq9TcoBKy79dFHvrEVKgmoosJFRTBM9L+BcZXmXJ4try5HXHZXllYEayqi5sTf6mYgFje2otY2tW5/v53Pm7N9sMvlm148U26I8WPixuCIVklOlWkCFT6cUauwRSuplSO6qxYbzfI58eOsfG3W1d23p+SsbeL/mZhUbPWLJJpTJRGVZSTuOnYmRO2bPUlE3EaKLluoZYqgLEOmKQJnKpIXdLtjtHFdpi3vY2lEIlWORHbV+YHS6mwIII0svUG4ItY3rt7V/dBy/utyvK4TzqLFfM/Zvk4+RBGYj+m8avDJGGZCCr60dQhUoVbXrUpIPxT+STjW+lt2VObRfy8dW7VXpqjMCGKogjLXKPmEZtkqqqoQ8fFg6rzZ0YpOoDKOFjEJ1mOI4Tt/fTb+zXb/Lzd1gnzZ5c0R4UKGytO8LuVlkN/RhtECWVHa5YrGxJrHPeT2nj5d3A4/vO3vHj5WVgzRZchHUx4rxei4Uf5kmmd4hcrZI41ZgoW2yFfWuktE7K3KexS8bIV9ePcNX7Ny8aGc2S3TyTNyRkqmb26aTWLXdiokXnoIomXgoGKI0v45NzreNk5V3yk3LNxtw26eIxzRSSRF87cMuNJFjKnSFixpZWdB0VZIlHQ9Ix3SPj+Fn7RwBcSCXGykcMjqr6cfGhZlLXFyXlRAreJKufKvhuOdk30nSJFeZdvH7/AFjSnkm8LInWXcv12KpnCjtRJY4g8+gH6uDgIfcHOcHe7kO7bjuuw7nPmyzbjkcT2uSeT1i7PM0TF2kKsf1PDUGswP5heuTgW24eLibjix46R40e8Zaxp6dlVA4ChQR+T4W6fCtgpfa9grWwNjxJrY7CtQGp2oV+JTdkcRoWF3S6qyj+wJDGExyS8mdU3BxHqAw/XLJbz3e5JxnuTynZzu8w4ptvDFbExhIHh/dPtm3xQhSLm/7mcuSr6tWrr4gxdg8L2vduL7RnDCj/AJxlb4RNKVKyeiuXku9/K3pRhQCtrW6edaw6w2lLa1tKdnQZknnCTF2zbNJN+/TbIqPAImd0AILB1qFQA5AA4GLwoI8dQFEKm9qe7e79q+VjlkEC7jkR48kaRzyzBEMmkGQBG+pggZAGBWzk21BSJj5fwvD5htH8leQ40byoxaNELHTey/UOgLWJIIP028CRU90b5DwsW0YDX01rkjKPl7CzqS09HTSy7lGYkZBKPavE4daO9Y1N0uUihPcCt08qF54BI2yLt37nM3lOTtWJv+0xYzbiUUvBM8gQzNaI6GjBI6qHAYkXLAm2mtcHKt92zZu4GdxHbVml2zCzWxDNIAsjSx/S7CNbj0/Vuq3IYr9ZA6A/LbvyOVuCWg0tQRLe390ZUlkC0R81BDHHbmYFiyseDImci663Pd5L/h9on94QD2OYe5LbMB4F4dCuZf1PW9dJYtBGjRp8NWq76unTSPjWL7lzeCIoNtUSXvq1hlt4Wt9vW/wsK9RP5Da6vqFxaGkG3ebPi02a0zT+iXaV9ui8sIRZDN55VqqC6gRyqa3QHI9YmAOQKI5219xW2ScObdYIBJymJIzLj2kWFS8oQhZSDqspBHxN/gbcg5pCdsOQEB3BfFOum2vSDqt4lbNp6kHp1A1V6uqfkP1fYYN662solr+eTl1GrCJjI+y2Ru6iQaMlEpJR+yh1EkFFHiqyQpG4EpUgN9DBnY4t7j+K5u2y5PLj/L85JSFjjjnnDRhVOu6RnqWLLo/N9IsDcVzbZzLAyUtnkQzl7AAMwIsLEtaw63HU9LXPSq3XflT8jc4/k5Wk/wC6MvUHkrKnrclGaGjH8e8h05FyixVaPC6/cg4S7CYABu4ceQ9REectHgtx/ccKHcNvnjnwp4lkSSOYMrK6hh1BNmF7Mp6qwKkXFa89w7te6+Tcck7ZHvJ29cmVYyNlQqUWRlUq37M6lsPpa51CxuawWa87vPDXs6ya3m1TcFI9lCTLXbrq2rQBpCOOssgRZVi4qURKGYOVmqqfdRUTETEMBDgYoiHeTCwGH0C6/JiT+PUfwrF9w9xXuM4zuEcPIcyfGy9IkEOVt+PDrQkgEo2PHIUYqw1Ky3IIDAjpvJ5m+Ru1iePHjvvLV18d68kLa1jiXas16UinYpu7jVWthj+83cJPHgtYpxCO00VTAmYCOSgqUDmAodHEgi/cSQSjUBexIt+U9fs/Hy86sL337oczXthxjuHxHcZNryc1I/3cEMkbWbLx1mjuCGYrG0UioxCm0g1gMbDCtUeVm77T4P7buTDaIf71atvCEglJzCFXkJKWo7gkE4dNvx0vHqMlSoNnUicgggdURZgUo8mAA+5caJM9EK/9Ow8OviQRa4N/zWPwsbV4HDO8fP8AePb3vW+427//ANA2fcA4klEDySYh9F2BSWMoQEafTZS94hY3Nqnn43fKjZHkAntKv7ZsqNisVZPXJmCclh4KFUGElCyTKRQ7EFHxqCxGL5igYTnTE4C6AOoQ4AOLcMaODS0Qspv8fEfb8v8AT4yL7V+8PKu5S7xtvNMtcrdcQwSwsIooj6MgdXFoUjU6XRepF/r8SOg1F+dHyFVhKXrnxogXpknd4dE2Rf00VOk5qpXXqrOoRTkn3dxrM2xuu9/9olVhE+BEDCGRZzrcTHFHtsZ6sNbfZeyj5gkMT8Cqmt5HsL7cpnb3uXdDPS8WAhwsQkdPXmTVkyL/AGo8dli8/pyW6AgGueLVWodmbwuLOg6mpc3erc9brvE4iFQTMZuwaimVzJST10q2jYiMbnVIQ7l2sigCihCdfWcpRjvEw8nOmEGIheU+Q/06D4k9B51sd5bzHi/BNlfkPL86DA2eNgpklJ6u35URFDPI5sSEjVnsGa2lSRIW9fEzyJ8aPxKm7dXzVKYzix2sRNGdw89Xnz1NIzg0enYK1Iy8QnJ+3IZQGyixFzJkMYpBKUwh2M7adw22xzImRW8CbEfipIv8r3t1rHOBd3u2/c/1l4NusGdkY66pI9MkUyKTbWYpkjkKXsNYUoCQCQSAdvvjD8knlK2W+8Xb1IvXmifKVvI6xmocVznJWrxdYxaswFmg0TJLkbuLAs8TiJApe0RVNdu4VE3siFH1NgzVkMmx5hJ23NRonH/iLouPgetr/A9b6VtD/uk7ax71xiLuvx6NE7g8RdM+KWwHrYuK4nmglNxqEOk5MN9RUrLGovOSMEYTO0/BTyfkjwclCOL7p60y0GusmdOVq9mjV2yrJ02fN2T3rGMn4R8AqNxWSesFj9JhRdockrjHNvHbrlz/ALZ4zuWDKyHwZHUixDWPVXQi4urqT/QdekqZWDw33GdoYhuEWQvGd9xI5lBHpZOPIrhlZCykCSGVCFfS0U0fUa4ZfqlXy/8AkD2h5eQtaqU5X4Cj0uuyIT5q/ALvXykxYytHDBvKSkm/EqhkY5m8cEbN0k0iF9yoZUVTdoUvZ5x3L3fm2PFhZEUeNt8Ta9CEsXksQGZjbooJ0qALEkkt0thfY72zcQ7IZ+Xve35WTuPIMqL0fWmVUEUBZXaOONLi7siGSRmYnQoQRguHsf8AEDxwr+uvD2vXq/XCAjP92rgnsR2rBKozk6pU2dfCNrFGiE2rlSPc2k75N2u77iiRItR4KLoAO1VLmH91+Aca/wDaPaNw5tusG27K26NnTGMCbNnVcaSKHDwYgdDzyhzraV0ix2YPLdY2Bq33t7p7pyfvpl8d4zgZMx2TAOComBhgGS0/qZGZKSA642j01i0hmyEjDw9JkI2A1ZHWLZNVu9MVtqNJ1bCMFJkPyRIZKIQnXcsgpX2k/PKsmz45HLlMwnWFTq4bgBScAQmQL2k2zlHdLiHIOFS7zFsHaLboP3H6/wC1XHXNmyFbChysp4kmdWdWMsuvUPTjUKA0cdRvzPK2niO9bbvyYL7jzTKk9P8AT9UyGBIiJ3hhDsgIUgIlrHUxJuGasdHQEhyIE2lpJXjnjt7Eaev7wA7In1/fxmOH26bjf6OW8Db7N5j/ANsQr1P/AHOxf6WzciX7cFv/AJ6yeB8e41GJtE7aNh12Qja9CrS7mL1nLR1tn1GbVduLl4s2VWYNkY9qmbqOYxx9QAeS8BzlfHvbbtkGz7vyDl3JdtyNt2zBbIfH2PIg3DLeKNlMsjo7wokMQs1yxuepKaVD+PufdHLkzsLbdm2rKiysrIESybhFJjQh2B0IrAOxdzceAt5arkrHNne6pa00sJRyT8pPPbI3kH07aYeNj3jOHaxzhBOMjRj38iUqbl657iwicgn7ZA4EC85GHLs/s/g8F/knAl3HM5FNuizy5WfjQQyx40cDouPCYZZhoklf1JDqUsVQFbAGsv2PF5rlcjGbyI40G2LimNIceWR0aV5FJlkDpH1VBpXobXPXrWc+Gc744zl6UjZqqJR29GE1LKwc7MnOrHzBWiHtiBAFTejHEmmjVsosHuGpHQciZJU4l4Jdj2k4/AMLaMLbN2Bm53qfIxpZdWlYpEBEEF2Kq8S62sV1Es7RsR9K0F7g8n4ryvutueRj7YmBvkGQ+NI1wRlS4rMjZJ0kKZHVAbugkCoASxXUdRNk0PVNF8s31DlElofUkPcK2zmk3EjLO1msE4iId5MmPIod+ZN1rOVTgJBMqUDAUB9OcxrkvH+JbB3bfj+SGg4hBmQrIC7sViMcbSfWNTm5J8LsAbDqKgvOxNuxOSNiTAjbllUMCW/KVUtcj6vMkW6+Hl1relWpeD1T1Hs7ZNGhldiVtpGQ1Zt8PGWedWk0W89aYNOLcFZWB60cQ7tGVbJLNnfSmcxUVSJGMAqFGeW2jsXtHD925PsMJ3LbI4EgyYknlLhZZ4tB0yspjcOqskllb6XCH8wrLDj8TxdunzsRfWg0qjqHJP1uoXox+k6gNJNj0IHmK0pJa/CQVC9zVO6SJicOvouMQoJSCP3dJTOCCcQD6AJg5/aGQh/Nux9+u1b4B8siK4+y5AuPK5+01i4yeJ6vqxsoJf8Arg2H3m5/H76x975nbv8AHXZsHRa5czzegoWZhZ6oxEnUK0lJy+op2QJNtIpaXPBozIyjSIdqx6rkioCD1scxPtAAzYJwLA4lJwPa5OGxsmwPgIYAzOXuQSTLrJId5CXdSLgNawNjVPeYd+e7XbHunLxzcNyXL4fjbikqIcXGDS7bLIJFiWQRLIXjx2OP6gYAzxMQdAtUJbjtC3mH5nHSgXbl7A3a/wBeoVRcJkXKDWlMHbWETlm7d0QizNBZim4llSHKUUzrqCYAHkMzKNf2uESOkixk9f69ul/lqsD8hURc23d++HfkJhO8m1Z+64+HAV1C2EkixGRQwumqISZBuPod2JHS1Th5R/HbszX7Xb+6ouXoK1AhpuYsUXV4dzPBY2VOdT4IxqajZautokXsPDOk1XvDroEEVTEMcekDcWPuETlILPrIVbm1i3QfHoCb26dBWfd3Pa/y7jMG+8+xZ9rbjeNPPkJBEZhOmIZSUGkwCMyRQlTL+pZirsGJsDqD43eONm8m7hL0eoWWp16ciq+tZSktjiWbISLBq/Yx7sjFSKiZY53TZWSSMJDFLymImAftHjs5GQuMgdwSpNulvG1/49fwqFO1fazdu7e+T8e2PLwsbcYMU5FsgyAOiukbaTHHJ9StIlwQOhuPA1eP4M+Dll8XrJcLnd7jAz8/YoBKsx0XVfyR4lnF/kmso/evHUsyjXLt8s5YtyJFK3IRAgKcmOKgATx83MXJVURbBSTc+PW34Dp9/n4Ctg/t59vm7dod0z995BnY+TuWXjrAkeP6nprGHEjMzSLGzOWChRoAQBup1m3P98wkvIyXnls1o+7vtq/WdZw0OCgmEn4xWiQlgUMgBvQqQzE67AePTrA3685BHMGZt+mU/lUJb/y0Nv43++v6UvZnh42L2A2uWC3q5OVmyyfHWMqSEX/+3DH9xq1T4H6pVmuhtw3dqk1Uuk1toKzMue2HvkK5XKhXJOvsxUNycrQ8jZZFUALwUxxHnkShxlfA4YRgzZAt65k0n5KACPxJP22F/Cqm+/zd92m7gbLscpcbJBs/rRLf6DNNkTJM1vDVohhU+dgPI1Yt59U+q3bw28jY23pNDx8Xqm32yOcOiFH8fZqhEObJV3zY4iU6blOejUCh0iAqFOZMeSnMUcj5BDFNs2QJrWWMsP7yi4/Ei32Gq2+3zed32PvTxrJ2YuMiXdsfHcL/AE4MiRYZ1YeBHpOx69AQG6FQRw91JV82skNIRr15GSEO+bTjKRj3CrN+wexC6T5i8ZO0DEXavGz5JM6ahBAxDlAQEBDK4cj3SXZdnmzsY6crokZ/qu5sG/3Rci3mAa3y5GLjZ0EmFmRpLhzIySI4DK6OpV0ZT0ZWUlWBFiCQas78IvD2webGy7WaftMlCU+rkQn9h3DoCWsElLWN48OwimSkgsYqs5PqtHjhR247xESIHOcpznTIfB+33Bcnnm6SjImePb4AGmlvqkZnLaVUte7uVYszXsASbkgGAPcJ3z23sBxPC/luHDkb7mFocLF/yoI4oFUPIwjAtDCGijWJNBYuqqVVWK74eW/xH07WmobPs7RlwucnJUCDd2Sx1W7OISTCbr0M2O7nXcLIxEPXzMJOOj0VHQIKpuCOSpGTIJDiXmR+adlcDatkl3bjs2Q82NGXeOUq2pFF3KFUUhgAW0m4a1hY2Brj2S97O+cs5xh8Q7i4OBDibnkLBBk4iyx+lPKwSFZkllmDxO5CF1KNHqDsGUG2lvg/tCyrs7ppN9Ptj1IE0tj1WtvSpA7JaURTibQ7g3JwBUqKlfKgd016ugxkyqEKCgqCekPe99/3LgmJtuGhl2bC3CTKmP0/oq0PpA3YghZHcXRL6mUMR9N6sB7gOI7TFk4HcDHxmG+EnByZ0vpOOQZMdZgOhYS6ljkPUKTGToCBbw9Gg62hqDZOpmTauVdBi2rkmNgOk9Md28VmgkJCQnFFHiiZzFaQRE0hTKkRIADkBAMzTsBHm92uzHKOzO2w7ZtUEUWHN+7KSl5ZXyfVnly2Mh1H08VY4iioIkCrZlUVr37jtBw3nW084yXy8ySR509G6AIixaI0hAUWGqUs+osXJJ6E1FK2k6ggsogbfOs+4kcxD9K0goXqKPBulRJJRNQAEPqUwgP7ch+XsXwqOQxDuHxQsptcPKV+51VlI+YJB8qzZO4O/Mof/wBNbwAf7KA/eCQR946VtL496GjYRC1WD+d67cY201qTppTVoResU20go1UkBculTEEHSYNyFFASBwBuTD9Mtv7bvbxtmwQbxyMb/tu97Vu21TbarYP6kSpMUaf1HbqJF0RgRWFgWL+KgQz3R7l5e4yYW1/y7KwMvDzI8ojI+lyyBhHpUf0TqY67nwGnzqud3FvWMu4hVUTDItJBWNVblDk/vUHAtlECh9RMC5RL+8c1lZ2z52FvM3H5UJ3OHKfHKDxMqSGIqPmWFhVrcbPgmw49ziYDHaJZQx8NJUMCfu615Xk9rRv4z7vpMrT3zhNVeJrOwUe4sZY8dZ46VcISYNlTiZVRm5k4f3RAOI9PuDJh9hChmwnnfDYuz/JNlh2d214+Dhz9SWtPA2mSxPUo7RagCbjUyjpatQHcAxR81y98xSVizcuTLA84y8hYgE366hrBPQMbWCgCsh2LRYfaHnrYKHYVpBKHsl4TYSCsYsi3kCN0as3ch7ZZw3dopn/0pQ5MmcOn9MyDkWw4XKO/2RsG4mQYOTn6XKEBrCAN9JIYDqAOoPmK6GdiR7hzB8OfUEeUA28baAfMHyHw8DevxeEDihtbzs5ltJxAp62ca9MnPIW07b+W3L1veqeeA/IEef6Q7pJ8XqbiYOSn56eBzg7GSbBBv26Q8qbHHGn20iYZFvRZhlY/paw30lg19F/A3tXxxRsMZWRHuBT+XtECwe2gssimMm/QlSSVPkSbWqN98L69u/kErXqCTX9H12nLQVTip+ARbNKwVgush+Qt0w7Zgmk6BNy/VOqoUA6GyJEwEejrNjPPn47vvcM7dx/+X4HHBNFjpNCFEAQka8mQrYNYuxJ6AIirf6Sx6G8HCy96MOF6MOFqVAygabX6yNa1z9Rv1H0qADfqc1+R3UFLZ670DtvVEg2sVHh4A2m3M/HvUpNo6QhHElI1x2Z215bquV5H80R0oAFKC4EIAB6FDYz25Ow4/F8TauMzR5GxQRaYZEYPq0fpyEuOjMWT6vCzaunkKv8AvK4XjjF2PuDtX6mGIf5dK4IK6VZ5cYiwt9TNkhm8L6F6GwOM/FFqsbXvOe2U9aipF6trK3sFzF+wlruBXEPHgAmDpP26+lKCPHqQ4kH09MyrdJSsCxKbFmufmoB6fYSQT/dHlesP9mnD/wCcdxMrlmSmrD2jCIjJ8Fyck6EYfFlgXJUeIGu9r6SOgW41eNu9RtFNmCdcTbK9M1uSL0gcRYzcc5jXXSURABMCDkwh6h654QJBBHiK2Wb1tWLvuz5eyZwDYWZjSwSDxukqMjdPsY1ygaV2TYPEryGRs8jCrScrrqXuFUs1ZK9/F/k1StJatSEas8VZvBbkQkulYDCicQMgUeOcyidBl4+lTYOFYfLwPh9hIrTN2/5RuXZPueu65kDT5m0zZeJkQB/T9Wyy47rrKtpHqhZASpP0DpVmfx9742P5D+V2y7xsWTO8cJ6gk2kNEsCOW1aq8Ytd6eqSIhmIqrItiqCmBjKKnUduRTEyihxARDzs+GLHxljjHQv4nxNh5n7/AA8P41bH20dxuVdz+8u68g5TMZJl2N0iiQMuPjxnLxiI4kuQLkXLuWlk03ZiBYag/OV46zMVsKj+TcIwWc1a1QbDXd4coJHUJC2uBUeuay+kFORBBrZIN0ZqibgEyLxvSYQOumBoY5xtrpkLuUY/ScWb5OBa5/vKAB8kN/Kv6Q/Yd3Iwszjmf2uzpFXdcOd8zFUkAy48oUTog8WaGUeow6sUmLD6Y2K1x+EvnJsjwouszMVmLY3KjXFFi3vOv5Z4vHISpooXRomYhJhBB4eAsMd71ZMFhbuUF26pk1UTGBFRHG9k3zI2WYvGNULfmU+B+HXyI62Plc3BvVlO+XYfjPfHY4MLdZZMLfsIucXLjUOY/U0epHLESvrQvoU6dcbo4DI4BdJNl/Nn5ZL95V6/W1FTqIlqXXk0o0VuoHsP8z2a3JMHKD9nCnkk4iEawtfB+3TVcJIpKOHYokIZYqArILenvfLcjdYP2sUYigJF+uom3h1sOl+treIBv5VGHY32ice7S8hHMd6zzvHJIAwxf0fQhxiwKtKE9WUyzaCVRnISMMzBDIEkSt/V1GuNxdWyRq1efzcdRae/ttyeMwR7FdraT6PjRl3xllUuUBkXyKQFT61R6hMBeghzFirmW3ZOfxyZ8ZWY47pM1heyIbOx+ShwTVq9y5Bsux5OFj7tkRwT7jljFxla95p2R5BEtgfqKRs1zYdAL3Kg2u/GL5j0vxevV0rW0DOY/X20EIL3NnaMnEiaq2Gtmkyxz2RYsyqv1YSQZTC6LgzdJwuksRAwJ9vunL5naTnO38R3HIxN4um2ZipeQAt6bx6tOoC5KMHYEgEqQptYkisHu57E7/3g47t+7cO0S8n2dprY7OE/cwT+nrWN2sgmR4lZBIyIyGQa9ehWtF8xvkr8dozR96qepruz2VsC/wBTmqlCta+zkDRdeSssa5indinpR+zaMkSxLR0ook0TFdys6BMh0iImUVTl7nPdbi8PH8jD2bIXL3PJhaNAgbSocaS7sQFGkEkL1LMALAXIqB2K9pvdHN7hbdvXNdvfaOMbZmw5MzTMgkn9CRZBjwRozOWlKgGVtESJrYOzhI3o/wDCGhStp2xNWpBm5NB60oc5ZJeRIBwatHso7i6xAs3CoAJRWkXUuoKaYiAqFQUMH8A5RbuRgzz9sN7zkB/a40eN6jdbATZUUKDp5tIygfK58BWwv3Ackw9o4djbPI6jcN33KKCJOl2WNJMiZgPgixrcjwLqP6Qq8vSKiiOq/IxVM50zBUIFMTEMJTCCy84mcgiUQ5TUTESnAfQxREB5ARzCew8kkPaLudJExVjsmKlwbfTI2WjD7GUlT8ia169w0WTmnFEcAj9/MbH4qISD9oIBHzqL6lrlS1UnYlyCXIxJQG0K4OwMyM4NK/mHDtACEcg5RBmKAteeRIp19X6cc5E/De2UnLuCcl5uuauPHxyLGcwmIucj9y8iABw6iLT6fiUfVq8Ba9ZlvnK12XkO1bAYDK25vKofWF9P0lU3K6Trvq8Lra3nW3/g8uZOM2X3lxI1QcVhfpUUEEEBFCwe4X4MPQmJ00S9ZvTkCBz9Ay6PsHyDHtXKvWkK4kcuC9ibIp0Zet+vQXVV1HzCi/gKgr3FRh8zaPTW8zJkDoOp+qHSPibEmw+JNvE1pVPW1d/sKVvDME0nLm2u7K0AUi9pNY8seSb8pCHBikOJeefUePX15yivJOZZG49ys3n+AFXJk3uXPhBUWB/cmeIMvgf6Orxv1ve9WD2vY4sXi2PxzJJMSYKY7m/U/pCNiD+NvhXm+W9hJufyipcBEH77VxFaxq0aVISLh12wzaxcf4Q/esQ9sBM4DwIGT6R44y/fdDfcfuP3D2htsOrAy8LbljtZumWRP5eJAyACPEFSLVqX5ziZMHOpuPZFjk4eSuMR5BgwuD4eJa56j6SvUeIyqvCLz5J3Aj6iTZVmD+wGVVlgD/pQz39uJm9zDE+I3Of/AOGCT/YK4IPq5yR5idv+wf8AT+B86i3xA1bEbpue0Naz0hJRMVM0U0gu/iPahIJKwl7qT1uml7xBy2BJY/ofkgjwHpx9cxXs5xXD5tvW6cZz5JYcSbA1l49OsGLKx2AGoMLHzuL15/Gtvj3TJnwJmZY2hvdbX+mRD5gio9n9MwcT5OpaNQlZdSAU2PXqWMusVn+ZBjMPIxsu7ACIkZC6SI+MJP8ADAg8AIl/TMd3DheBid0V4Kksx247nDjGQ6RLokZFZh9OnUAx0/Ta4FxXSm2uGPfv5SGb0vXVNRtf6iOtug86kX5FZCK0zrnTfiPUZuRlIyENNbHsbiRFsD5YknNTZau0dGYJN2/Sm6fyihkhIX7U26ggI8GzY7254jhcL47DsOA80uJjB1R5SpdvUkeV9WhUUkF7A6R0+JuarH7xuUJtm37R2uwJSyAtnZI8Omp0xU+FixncpfpoiY9CLw18bG9zal34xqUs+MhTdvFa1CRIooJWrW0d45qXKmJ9BVGSXUjuREClJImOb0IHGYbjAZYNaj9RDfz6qfzdB8OjXPQKGNRT7VO4v/oruSmyZ8mjYd8VcZ7mypkgk4khuQBd2fH+JM63/KLWD/Il5q3jR8ky03rJqELZ7HVG1ilL8sZNZzDxEo/lopFjWmZimTRmVTxKpjvVur2xDF7JBVEFUejgYaTAzS9VBsAPM/P5fZ1PxFutl/c9375D2+y4+C8RQQbtlYQmlzGsWiikeSNVx18BMTG5Mr3EY06FZzqjoQn4m2pJx9otEfYCJ3QH8zFz863kA/mkCvVEZKWZyT8vVMh+QE5VlynU5W6gMbq5z2wyElVI+noQPL5fL7PKtcO5YW9xpFu+7xZQTPDyxzTK/wD1A1EPKjv/AJo131OCbte5vXTr8e8ZrVHxe15Oa9rjCCdT0cYt5cJGM4lJi6wTp1Czj+WfL9TtQrh80UXaIGN2mrVchEgAnHOO55kOU6yG9j0+QPUfwIrbX7ZsTisfaDatw4zix48uTD/1bDrJLlws0M7yObsdUiM0ak2jjZVUAVtTsHX1L2tSrHrvYddjrZS7bGqRU/ASqQqs3zQ5yLJmAxDJrtXjN0imu2conTcNXKSayJyKkIcPNyMeHKhbHyF1QuLEf6dQR4gjqD1HWrNcb5JvvEN8xuS8aypcPfMOTXFNGbMjWKkfBldSySIwKSIzI6sjMDzZ7/8Ag12nDT0hKeON5rtzp7hc60fV7/IKV66RCKg/axGabxy1csREPX/UqfjFBKIAKRjAJzRpuPBstJC+3Mrwk9FJ0sPl/VP23X5LWzXt778uJ52BHi9ysDJwd5VbPPhoJsWQj+l6TOJob/1B64v1DgEKIk158JHlrZplBte5TXGsoEFC++l3FgNcJMiAiIGNGQdeS9u/cl4/y3D5kQQH/M59M6eNwndpXtPoij8yWBP3BdV/vI+6sv5J75u0G1YTS7BFuW67hb6Y1i/boT/blm6ovzSKU/2fOuiLxo8K9IeMGppnVFSgSWJpdWaiGzrBakGsjLbHO6j14x03nk+0DQkARi7WQbRiRQaN0VlPQ6yzhZaQ8DYdvwcB9v0CSOVCspYf5gIIII/q2JAX4E3JJJOuHuf3w533T5hBy/d8g40+A4ODFjkomGFkEimI31GbWFZ52PqOyr1VEjRKbN+/DXtKHs8lJ+PU7X7bSXztw5jKxaZg0FbK6gsoKiMSMi9RUiJ9myTHtpu1HDdwcoACiRjdShq5cm7F7vFmvPxiSKbb2N1jkYpIn9nUQUcDrYkqbWBB8Tfjtt78OH5+0xYndDGysLkMaKsmRjRCbHnIFjL6akSQux6tGqPGDcoyiyCEKv8AER5iTkm3ZzULR6YwUWKVxLzd2i5FBugBwBVUrSr/AJ58up0cmIQCFA3oBjE5HjHcTslznIlCZCY0Ed+rPKGAHxAjDk/Z06+fnUhbv73uxe3YjT7fPuOfkhfpiixJELG3QFsgwoBfoTc28QGq3qA8O6r4m+KlspdPM9tl1t8rVJC+28kcdKQsr6NlEBZM2se2M6WY1yDSVXBm2FRYUzLrKnOJ1jjjv/wBOL+3jdNm2ZJsvdMjJwmmZEZnlK5UTdEQMRHHYlVNwvViSxuaSZ/fXee9XenB5BvojwdgwcfIjw8YyXTHR42LMztpD5EzafVkCqWCxoAEjQD8Op6vZI3S+/nz2BlmqMpD1pjGCvHuklH7hq+kTO02qJkgWXK2K8SE4gUSh1+o+g8Va7PcU5RtfYzuNn523ZsMGZg4UMGuGRWmdJZvVEaFdTCMSpqYDSNXj0a3c5tvG05fcDjGPj5MDvDPkPJpdSEVkTSWN7DVoawJubfMV+jStVsUnp7yBhmcPImlX0dUlGTM7J0mu9Bk5mna6LNMyXU6ddlAwFSTAxzHEpeOTF57PYviHKN27Kdx9jwMDKbecjG24xRGN0eX03yZGWIMBrfSpsi3YsVUC7Lfi7g71tOHzzjG4ZGREMGKXJDuGUhNaxKC5BOkXIuTYAXN7A2hWqXLZuvGNkha8WRiW1lbgxm0FoRNZY4JIvGpe0q7ZqLtF0k3yoAKZijyPPqJSiEFcN5x3U7b7dumy8YGTiYm6xCPKVsTUxCrIgKmSIvEwWVxdSpuQT1VSJB3zYOIcoycTO3YxTTYba4iJrAXKsbhXCuCUXxuOnToTf1m2lrKOqpvZj9hIs0WMtDto5io2Mmo+i3Si7aSkxQUT9wKKL1dqmkYAAhuVRER6fT1sXsbytuz+4d1c7HyYIcfNx48eJkKtLA7NHPkFGXX6ayvAkTL0b9YkaVVj1JO4GzDm2NxCCWKRpIJHlcMCEkWzJEGB06iiyM4Ph+mB1JFfx4w+L9ltu0oncjyzQJImp3tOTfwCqMsWdAI9qk7hAQBRoLE6JlSpF6hVL09o/ADwXm1XtY4SeWQbdyWCUQ4+xZaRTQShxMzJGJI5E+nR6bu1luwI0OOhAvRbuv253/ae62ZyjdsnDnxdzzJMyP0df0IWMccLahYyRoia2B0m4tfxrZ+r+IlthfKx15APbVXHMAtaLfPpwbdCTLLlQn4Wai2Dcx1UPZd5opJJmVED8GAg9P1AMsztXZ/d8Huw/cGfLxm29srIlEQD+paWOREHUabqXBY3sbG3jao7x+N5EXITvDyIYTI7aRe/wBQYAfDpe5rA9P+DewdbMttunF+rgWG9a6m6NX1IUJtJtGuJp/HSBpl5IHbNH7U7M8WQqZEE1RHuGETfaAG8Dh3YnkPGIN4lk3HHO45+2yYsJjEiKhldXMjt+cFSihQl/FifIV09s4pm4SZDNLGJpoGjXSWNixB1arKRa3gAfHx6dfB1N8fl4qu1KpsG87EgZdtW7EwtK6cWWaey8tJxTpOQZJOHcq3alIks9RIKyhjKHFMBKAcj1B5/Efbzvu08sw+Q77uWPLDi5KzkRiRpJHjbWoLSBbAuAWb6iRcWubji27huXj7jHm5k6ssbh/puWZl6i5YeF/Hzt0FvEaYbQ8V/J/yb8ppy22bWVnqVLuF2btPz02rEtUa3rqIUbxTJc6RZJcPyKFZYlU7CQGFd6c3HPWJsufDlY2LijQQZFW9h4lj/DofHr4A2ubA0B5h2c7ud2+8GRu277Tl4Ww5+4BDNKY1WDBitGp6M/6n7dLoqqQ87C9lZnGX+enhbsk27mt80RryZm67bYSKdO2VLjkUU6nZ603aQqhEmzEEPYIyDBozdpLfxqOzOR55LyPHgZcKwejOV+noAbkMpvcHyt5EdLhugPWve9yHYblj9wU5P2623IyNvzoI3cYqAftcnHVIgQFsV1oscqP4+qshJBC33mpfjJBeRkzrPyF8kqjOp32D1rA0ea1XaYxJhBmtdWlp1SStsq1TVUGZjZ9xIe5ZsTdLVNE4FXBcREpOich8ZGxsdvo1khri5Xy8AADbqbW69PDxsNsnaXbO6W4bT3O7p4OQvI4NpgxZdunj0QjJgklMk7rcmaORn1RRn9MJb1BITZcf+SjxyntvaopMtrWqup2365sAM2MDAsyGdK1CwNUmMm1YskAJ1ljn8bHqkIUOlJAiogABzn3t2QsUxWQ2iYHr8CASPx/L5eN/KvL91fa3cebcKwc7ieG+Tvu1ZIVIIUGpsafTHKqKLf5RSKQAA2RHUAar14nxiVbcmsqjsbW20teW6nRpJ5hcKo9sEYq0aOlpVkWKsMcgsqb7VEBiGaxEyhwbvKm9B56vrcmikdZYmBOmx+7z+yx+3oa8/wBpGz864nse68U5htedg4q5SZWO80ZVW9VBHNGCT4qYkfSBazk+JNWlZ5tW/pilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilMUpilf/Z=";
var cc = cc || {},
	ClassManager = {
		id: 0 | 998 * Math.random(),
		instanceId: 0 | 998 * Math.random(),
		compileSuper: function(a, b, c) {
			a = a.toString();
			var d = a.indexOf("("),
				e = a.indexOf(")"),
				d = a.substring(d + 1, e),
				d = d.trim(),
				e = a.indexOf("{"),
				f = a.lastIndexOf("}");
			for (a = a.substring(e + 1, f); - 1 !== a.indexOf("this._super");) {
				var e = a.indexOf("this._super"),
					f = a.indexOf("(", e),
					k = a.indexOf(")", f),
					k = a.substring(f + 1, k),
					k = (k = k.trim()) ? "," : "";
				a = a.substring(0, e) + "ClassManager[" + c + "]." + b + ".call(this" + k + a.substring(f + 1)
			}
			return Function(d, a)
		},
		getNewID: function() {
			return this.id++
		},
		getNewInstanceId: function() {
			return this.instanceId++
		}
	};
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
	var a = /\b_super\b/,
		b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
	b && console.log("release Mode");
	cc.Class = function() {};
	cc.Class.extend = function(c) {
		function d() {
			this.__instanceId = ClassManager.getNewInstanceId();
			this.ctor && this.ctor.apply(this, arguments)
		}
		var e = this.prototype,
			f = Object.create(e),
			k = ClassManager.getNewID();
		ClassManager[k] = e;
		var m = {
			writable: !0,
			enumerable: !1,
			configurable: !0
		};
		f.__instanceId = null;
		d.id = k;
		m.value = k;
		Object.defineProperty(f, "__pid", m);
		d.prototype = f;
		m.value = d;
		Object.defineProperty(d.prototype, "constructor", m);
		this.__getters__ && (d.__getters__ = cc.clone(this.__getters__));
		this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
		for (var n = 0, p = arguments.length; n < p; ++n) {
			var r = arguments[n],
				s;
			for (s in r) {
				var u = "function" === typeof r[s],
					t = "function" === typeof e[s],
					w = a.test(r[s]);
				b && u && t && w ? (m.value = ClassManager.compileSuper(r[s], s, k), Object.defineProperty(f, s, m)) : u && t && w ? (m.value = function(a, b) {
					return function() {
						var c = this._super;
						this._super = e[a];
						var d = b.apply(this, arguments);
						this._super = c;
						return d
					}
				}(s, r[s]), Object.defineProperty(f, s, m)) : u ? (m.value = r[s], Object.defineProperty(f, s, m)) : f[s] = r[s];
				if (u) {
					var v, y;
					if (this.__getters__ && this.__getters__[s]) {
						var u = this.__getters__[s],
							z;
						for (z in this.__setters__)
						if (this.__setters__[z] === u) {
							y = z;
							break
						}
						cc.defineGetterSetter(f, u, r[s], r[y] ? r[y] : f[y], s, y)
					}
					if (this.__setters__ && this.__setters__[s]) {
						u = this.__setters__[s];
						for (z in this.__getters__)
						if (this.__getters__[z] === u) {
							v = z;
							break

						}
						cc.defineGetterSetter(f, u, r[v] ? r[v] : f[v], r[s], v, s)
					}
				}
			}
		}
		d.extend = cc.Class.extend;
		d.implement = function(a) {
			for (var b in a) f[b] = a[b]
		};
		return d
	}
})();
cc.defineGetterSetter = function(a, b, c, d, e, f) {
	if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
	else if (Object.defineProperty) {
		var k = {
			enumerable: !1,
			configurable: !0
		};
		c && (k.get = c);
		d && (k.set = d);
		Object.defineProperty(a, b, k)
	} else throw Error("browser does not support getters");
	if (!e && !f) for (var k = null != c, m = void 0 != d, n = Object.getOwnPropertyNames(a), p = 0; p < n.length; p++) {
		var r = n[p];
		if (!((a.__lookupGetter__ ? a.__lookupGetter__(r) : Object.getOwnPropertyDescriptor(a, r)) || "function" !== typeof a[r])) {
			var s = a[r];
			if (k && s === c && (e = r, !m || f)) break;
			if (m && s === d && (f = r, !k || e)) break
		}
	}
	a = a.constructor;
	e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b);
	f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
};
cc.clone = function(a) {
	var b = a.constructor ? new a.constructor : {},
		c;
	for (c in a) {
		var d = a[c];
		b[c] = "object" === typeof d && d && !(d instanceof cc.Node) && !(d instanceof HTMLElement) ? cc.clone(d) : d
	}
	return b
};
cc.inject = function(a, b) {
	for (var c in a) b[c] = a[c]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, b) {};
cc.KEY = {
	none: 0,
	back: 6,
	menu: 18,
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	pause: 19,
	capslock: 20,
	escape: 27,
	space: 32,
	pageup: 33,
	pagedown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	select: 41,
	insert: 45,
	Delete: 46,
	"0": 48,
	1: 49,
	2: 50,
	3: 51,
	4: 52,
	5: 53,
	6: 54,
	7: 55,
	8: 56,
	9: 57,
	a: 65,
	b: 66,
	c: 67,
	d: 68,
	e: 69,
	f: 70,
	g: 71,
	h: 72,
	i: 73,
	j: 74,
	k: 75,
	l: 76,
	m: 77,
	n: 78,
	o: 79,
	p: 80,
	q: 81,
	r: 82,
	s: 83,
	t: 84,
	u: 85,
	v: 86,
	w: 87,
	x: 88,
	y: 89,
	z: 90,
	num0: 96,
	num1: 97,
	num2: 98,
	num3: 99,
	num4: 100,
	num5: 101,
	num6: 102,
	num7: 103,
	num8: 104,
	num9: 105,
	"*": 106,
	"+": 107,
	"-": 109,
	numdel: 110,
	"/": 111,
	f1: 112,
	f2: 113,
	f3: 114,
	f4: 115,
	f5: 116,
	f6: 117,
	f7: 118,
	f8: 119,
	f9: 120,
	f10: 121,
	f11: 122,
	f12: 123,
	numlock: 144,
	scrolllock: 145,
	";": 186,
	semicolon: 186,
	equal: 187,
	"=": 187,
	",": 188,
	comma: 188,
	dash: 189,
	".": 190,
	period: 190,
	forwardslash: 191,
	grave: 192,
	"[": 219,
	openbracket: 219,
	backslash: 220,
	"]": 221,
	closebracket: 221,
	quote: 222,
	dpadLeft: 1E3,
	dpadRight: 1001,
	dpadUp: 1003,
	dpadDown: 1004,
	dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
	return 8 < a.length && 137 === a[0] && 80 === a[1] && 78 === a[2] && 71 === a[3] && 13 === a[4] && 10 === a[5] && 26 === a[6] && 10 === a[7] ? cc.FMT_PNG : 2 < a.length && (73 === a[0] && 73 === a[1] || 77 === a[0] && 77 === a[1] || 255 === a[0] && 216 === a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, b) {
	function c() {}
	c.prototype = b.prototype;
	a.superClass_ = b.prototype;
	a.prototype = new c;
	a.prototype.constructor = a
};
cc.base = function(a, b, c) {
	var d = arguments.callee.caller;
	if (d.superClass_) return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
	for (var e = Array.prototype.slice.call(arguments, 2), f = !1, k = a.constructor; k; k = k.superClass_ && k.superClass_.constructor)
	if (k.prototype[b] === d) f = !0;
	else if (f) return k.prototype[b].apply(a, e);
	if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
	throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, b) {
	this.x = a || 0;
	this.y = b || 0
};
cc.p = function(a, b) {
	return void 0 === a ? {
		x: 0,
		y: 0
	} : void 0 === b ? {
		x: a.x,
		y: a.y
	} : {
		x: a,
		y: b
	}
};
cc.pointEqualToPoint = function(a, b) {
	return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function(a, b) {
	this.width = a || 0;
	this.height = b || 0
};
cc.size = function(a, b) {
	return void 0 === a ? {
		width: 0,
		height: 0
	} : void 0 === b ? {
		width: a.width,
		height: a.height
	} : {
		width: a,
		height: b
	}
};
cc.sizeEqualToSize = function(a, b) {
	return a && b && a.width === b.width && a.height === b.height
};
cc.Rect = function(a, b, c, d) {
	this.x = a || 0;
	this.y = b || 0;
	this.width = c || 0;
	this.height = d || 0
};
cc.rect = function(a, b, c, d) {
	return void 0 === a ? {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	} : void 0 === b ? {
		x: a.x,
		y: a.y,
		width: a.width,
		height: a.height
	} : {
		x: a,
		y: b,
		width: c,
		height: d
	}
};
cc.rectEqualToRect = function(a, b) {
	return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function(a) {
	return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, b) {
	return !a || !b ? !1 : !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height)
};
cc.rectGetMaxX = function(a) {
	return a.x + a.width
};
cc.rectGetMidX = function(a) {
	return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
	return a.x
};
cc.rectGetMaxY = function(a) {
	return a.y + a.height
};
cc.rectGetMidY = function(a) {
	return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
	return a.y
};
cc.rectContainsPoint = function(a, b) {
	return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, b) {
	var c = a.y + a.height,
		d = b.x + b.width,
		e = b.y + b.height;
	return !(a.x + a.width < b.x || d < a.x || c < b.y || e < a.y)
};
cc.rectOverlapsRect = function(a, b) {
	return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function(a, b) {
	var c = cc.rect(0, 0, 0, 0);
	c.x = Math.min(a.x, b.x);
	c.y = Math.min(a.y, b.y);
	c.width = Math.max(a.x + a.width, b.x + b.width) - c.x;
	c.height = Math.max(a.y + a.height, b.y + b.height) - c.y;
	return c
};
cc.rectIntersection = function(a, b) {
	var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
	c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c);
	c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c);
	return c
};
cc.SAXParser = cc.Class.extend({
	_parser: null,
	_isSupportDOMParser: null,
	ctor: function() {
		window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
	},
	parse: function(a) {
		return this._parseXML(a)
	},
	_parseXML: function(a) {
		var b;
		this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
		return b
	}
});
cc.PlistParser = cc.SAXParser.extend({
	parse: function(a) {
		a = this._parseXML(a).documentElement;
		if ("plist" !== a.tagName) throw Error("Not a plist file!");
		for (var b = null, c = 0, d = a.childNodes.length; c < d && !(b = a.childNodes[c], 1 === b.nodeType); c++);
		return this._parseNode(b)
	},
	_parseNode: function(a) {
		var b = null,
			c = a.tagName;
		if ("dict" === c) b = this._parseDict(a);
		else if ("array" === c) b = this._parseArray(a);
		else if ("string" === c) if (1 === a.childNodes.length) b = a.firstChild.nodeValue;
		else {
			b = "";
			for (c = 0; c < a.childNodes.length; c++) b += a.childNodes[c].nodeValue
		} else "false" === c ? b = !1 : "true" === c ? b = !0 : "real" === c ? b = parseFloat(a.firstChild.nodeValue) : "integer" === c && (b = parseInt(a.firstChild.nodeValue, 10));
		return b
	},
	_parseArray: function(a) {
		for (var b = [], c = 0, d = a.childNodes.length; c < d; c++) {
			var e = a.childNodes[c];
			1 === e.nodeType && b.push(this._parseNode(e))
		}
		return b
	},
	_parseDict: function(a) {
		for (var b = {}, c = null, d = 0, e = a.childNodes.length; d < e; d++) {
			var f = a.childNodes[d];
			1 === f.nodeType && ("key" === f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
		}
		return b
	}
});
cc._txtLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadTxt(a, d)
	}
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadJson(a, d)
	}
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadJs(a, d)
	}
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
	load: function(a, b, c, d) {
		cc.loader.cache[b] = cc.loader.loadImg(a, function(a, c) {
			if (a) return d(a);
			cc.textureCache.handleLoadedTexture(b);
			d(null, c)
		})
	}
};
cc.loader.register("png jpg bmp jpeg gif ico tiff".split(" "), cc._imgLoader);
cc._serverImgLoader = {
	load: function(a, b, c, d) {
		cc.loader.cache[b] = cc.loader.loadImg(c.src, function(a, c) {
			if (a) return d(a);
			cc.textureCache.handleLoadedTexture(b);
			d(null, c)
		})
	}
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadTxt(a, function(a, b) {
			if (a) return d(a);
			d(null, cc.plistParser.parse(b))
		})
	}
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
	TYPE: {
		".eot": "embedded-opentype",
		".ttf": "truetype",
		".ttc": "truetype",
		".woff": "woff",
		".svg": "svg"
	},
	_loadFont: function(a, b, c) {
		var d = document,
			e = cc.path,
			f = this.TYPE,
			k = cc.newElement("style");
		k.type = "text/css";
		d.body.appendChild(k);
		var m = "",
			m = isNaN(a - 0) ? m + ("@font-face { font-family:" + a + "; src:") : m + ("@font-face { font-family:'" + a + "'; src:");
		if (b instanceof Array) for (var n = 0, p = b.length; n < p; n++) c = e.extname(b[n]).toLowerCase(), m += "url('" + b[n] + "') format('" + f[c] + "')", m += n === p - 1 ? ";" : ",";
		else c = c.toLowerCase(), m += "url('" + b + "') format('" + f[c] + "');";
		k.textContent += m + "}";
		b = cc.newElement("div");
		c = b.style;
		c.fontFamily = a;
		b.innerHTML = ".";
		c.position = "absolute";
		c.left = "-100px";
		c.top = "-100px";
		d.body.appendChild(b)
	},
	load: function(a, b, c, d) {
		b = c.type;
		a = c.name;
		b = c.srcs;
		cc.isString(c) ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b);
		d(null, !0)
	}
};
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader);
cc._binaryLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadBinary(a, d)
	}
};
cc._csbLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadCsb(a, d)
	}
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.7.1";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
	var b = this === cc ? document : this;
	if (a = a instanceof HTMLElement ? a : b.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass ||
	function(a) {
		return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
	}, a.addClass = a.addClass ||
	function(a) {
		this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
		return this
	}, a.removeClass = a.removeClass ||
	function(a) {
		this.hasClass(a) && (this.className = this.className.replace(a, ""));
		return this
	}, a.remove = a.remove ||
	function() {
		this.parentNode && this.parentNode.removeChild(this);
		return this
	}, a.appendTo = a.appendTo ||
	function(a) {
		a.appendChild(this);
		return this
	}, a.prependTo = a.prependTo ||
	function(a) {
		a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
		return this
	}, a.transforms = a.transforms ||
	function() {
		this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
		return this
	}, a.position = a.position || {
		x: 0,
		y: 0
	}, a.rotation = a.rotation || 0, a.scale = a.scale || {
		x: 1,
		y: 1
	}, a.skew = a.skew || {
		x: 0,
		y: 0
	}, a.translates = function(a, b) {
		this.position.x = a;
		this.position.y = b;
		this.transforms();
		return this
	}, a.rotate = function(a) {
		this.rotation = a;
		this.transforms();
		return this
	}, a.resize = function(a, b) {
		this.scale.x = a;
		this.scale.y = b;
		this.transforms();
		return this
	}, a.setSkew = function(a, b) {
		this.skew.x = a;
		this.skew.y = b;
		this.transforms();
		return this
	};
	return a
};
switch (cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_FIREFOX:
	cc.$.pfx = "Moz";
	cc.$.hd = !0;
	break;
case cc.sys.BROWSER_TYPE_CHROME:
case cc.sys.BROWSER_TYPE_SAFARI:
	cc.$.pfx = "webkit";
	cc.$.hd = !0;
	break;
case cc.sys.BROWSER_TYPE_OPERA:
	cc.$.pfx = "O";
	cc.$.hd = !1;
	break;
case cc.sys.BROWSER_TYPE_IE:
	cc.$.pfx = "ms";
	cc.$.hd = !1;
	break;
default:
	cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ?
function(a) {
	return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
	return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ?
function(a) {
	return "rotateZ(" + a + "deg) "
} : function(a) {
	return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
	return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
	return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
	return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
	var b = 0,
		c = 0;
	do b += a.offsetLeft, c += a.offsetTop;
	while (a = a.offsetParent);
	return {
		x: b,
		y: c
	}
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, b, c) {
	if (cc.isObject(c) && !cc.isUndefined(c.x) && !cc.isUndefined(c.y)) {
		var d = c[a];
		c[a] = c[b];
		c[b] = d
	} else cc.log(cc._LogInfos.swap)
};
cc.lerp = function(a, b, c) {
	return a + (b - a) * c
};
cc.rand = function() {
	return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
	return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
	return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
	return a * cc.DEG
};
cc.radiansToDegress = function(a) {
	cc.log(cc._LogInfos.radiansToDegress);
	return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function(a) {
	a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
	cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function() {
	return cc.director.getContentScaleFactor()
} : function() {
	return 1
};
cc.pointPointsToPixels = function(a) {
	var b = cc.contentScaleFactor();
	return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function(a) {
	var b = cc.contentScaleFactor();
	return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function(a, b) {
	var c = cc.contentScaleFactor();
	b.x = a.x / c;
	b.y = a.y / c
};
cc.sizePointsToPixels = function(a) {
	var b = cc.contentScaleFactor();
	return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function(a) {
	var b = cc.contentScaleFactor();
	return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function(a, b) {
	var c = cc.contentScaleFactor();
	b.width = a.width / c;
	b.height = a.height / c
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function(a) {
	var b = cc.contentScaleFactor();
	return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
	return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ?
function(a) {
	var b = cc.contentScaleFactor();
	return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
	return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc._renderType === cc._RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? cc.ONE : cc.SRC_ALPHA;
cc.BLEND_DST = 771;
cc.checkGLErrorDebug = function() {
	if (cc.renderMode === cc._RENDER_TYPE_WEBGL) {
		var a = cc._renderContext.getError();
		a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
	}
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(a, b) {
	if (a && 0 < a.length) for (var c = 0; c < a.length; c++)
	if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
	return !0
};
cc.arrayRemoveObject = function(a, b) {
	for (var c = 0, d = a.length; c < d; c++)
	if (a[c] === b) {
		a.splice(c, 1);
		break
	}
};
cc.arrayRemoveArray = function(a, b) {
	for (var c = 0, d = b.length; c < d; c++) cc.arrayRemoveObject(a, b[c])
};
cc.arrayAppendObjectsToIndex = function(a, b, c) {
	a.splice.apply(a, [c, 0].concat(b));
	return a
};
cc.copyArray = function(a) {
	var b, c = a.length,
		d = Array(c);
	for (b = 0; b < c; b += 1) d[b] = a[b];
	return d
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
	cc.color = function(a, c, d, e, f, k) {
		return void 0 === a ? new cc.Color(0, 0, 0, 255, f, k) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, c, d, e, f, k)
	};
	cc.Color = function(a, c, d, e, f, k) {
		this._arrayBuffer = f || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
		this._offset = k || 0;
		f = this._arrayBuffer;
		k = this._offset;
		var m = Uint8Array.BYTES_PER_ELEMENT;
		this._rU8 = new Uint8Array(f, k, 1);
		this._gU8 = new Uint8Array(f, k + m, 1);
		this._bU8 = new Uint8Array(f, k + 2 * m, 1);
		this._aU8 = new Uint8Array(f, k + 3 * m, 1);
		this._rU8[0] = a || 0;
		this._gU8[0] = c || 0;
		this._bU8[0] = d || 0;
		this._aU8[0] = null == e ? 255 : e;
		void 0 === e && (this.a_undefined = !0)
	};
	cc.Color.BYTES_PER_ELEMENT = 4;
	var a = cc.Color.prototype;
	a._getR = function() {
		return this._rU8[0]
	};
	a._setR = function(a) {
		this._rU8[0] = 0 > a ? 0 : a
	};
	a._getG = function() {
		return this._gU8[0]
	};
	a._setG = function(a) {
		this._gU8[0] = 0 > a ? 0 : a
	};
	a._getB = function() {
		return this._bU8[0]
	};
	a._setB = function(a) {
		this._bU8[0] = 0 > a ? 0 : a
	};
	a._getA = function() {
		return this._aU8[0]
	};
	a._setA = function(a) {
		this._aU8[0] = 0 > a ? 0 : a
	};
	cc.defineGetterSetter(a, "r", a._getR, a._setR);
	cc.defineGetterSetter(a, "g", a._getG, a._setG);
	cc.defineGetterSetter(a, "b", a._getB, a._setB);
	cc.defineGetterSetter(a, "a", a._getA, a._setA);
	cc.Vertex2F = function(a, c, d, e) {
		this._arrayBuffer = d || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
		this._offset = e || 0;
		this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._xF32[0] = a || 0;
		this._yF32[0] = c || 0
	};
	cc.Vertex2F.BYTES_PER_ELEMENT = 8;
	a = cc.Vertex2F.prototype;
	a._getX = function() {
		return this._xF32[0]
	};
	a._setX = function(a) {
		this._xF32[0] = a
	};
	a._getY = function() {
		return this._yF32[0]
	};
	a._setY = function(a) {
		this._yF32[0] = a
	};
	cc.defineGetterSetter(a, "x", a._getX, a._setX);
	cc.defineGetterSetter(a, "y", a._getY, a._setY);
	cc.Vertex3F = function(a, c, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		this._xF32 = new Float32Array(e, f, 1);
		this._xF32[0] = a || 0;
		this._yF32 = new Float32Array(e, f + Float32Array.BYTES_PER_ELEMENT, 1);
		this._yF32[0] = c || 0;
		this._zF32 = new Float32Array(e, f + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
		this._zF32[0] = d || 0
	};
	cc.Vertex3F.BYTES_PER_ELEMENT = 12;
	a = cc.Vertex3F.prototype;
	a._getX = function() {
		return this._xF32[0]
	};
	a._setX = function(a) {
		this._xF32[0] = a
	};
	a._getY = function() {
		return this._yF32[0]
	};
	a._setY = function(a) {
		this._yF32[0] = a
	};
	a._getZ = function() {
		return this._zF32[0]
	};
	a._setZ = function(a) {
		this._zF32[0] = a
	};
	cc.defineGetterSetter(a, "x", a._getX, a._setX);
	cc.defineGetterSetter(a, "y", a._getY, a._setY);
	cc.defineGetterSetter(a, "z", a._getZ, a._setZ);
	cc.Tex2F = function(a, c, d, e) {
		this._arrayBuffer = d || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
		this._offset = e || 0;
		this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
		this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
		this._uF32[0] = a || 0;
		this._vF32[0] = c || 0
	};
	cc.Tex2F.BYTES_PER_ELEMENT = 8;
	a = cc.Tex2F.prototype;
	a._getU = function() {
		return this._uF32[0]
	};
	a._setU = function(a) {
		this._uF32[0] = a
	};
	a._getV = function() {
		return this._vF32[0]
	};
	a._setV = function(a) {
		this._vF32[0] = a
	};
	cc.defineGetterSetter(a, "u", a._getU, a._setU);
	cc.defineGetterSetter(a, "v", a._getV, a._setV);
	cc.Quad2 = function(a, c, d, e, f, k) {
		this._arrayBuffer = f || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
		this._offset = k || 0;
		f = this._arrayBuffer;
		k = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._tl = a ? new cc.Vertex2F(a.x, a.y, f, 0) : new cc.Vertex2F(0, 0, f, 0);
		this._tr = c ? new cc.Vertex2F(c.x, c.y, f, k) : new cc.Vertex2F(0, 0, f, k);
		this._bl = d ? new cc.Vertex2F(d.x, d.y, f, 2 * k) : new cc.Vertex2F(0, 0, f, 2 * k);
		this._br = e ? new cc.Vertex2F(e.x, e.y, f, 3 * k) : new cc.Vertex2F(0, 0, f, 3 * k)
	};
	cc.Quad2.BYTES_PER_ELEMENT = 32;
	a = cc.Quad2.prototype;
	a._getTL = function() {
		return this._tl
	};
	a._setTL = function(a) {
		this._tl.x = a.x;
		this._tl.y = a.y
	};
	a._getTR = function() {
		return this._tr
	};
	a._setTR = function(a) {
		this._tr.x = a.x;
		this._tr.y = a.y
	};
	a._getBL = function() {
		return this._bl
	};
	a._setBL = function(a) {
		this._bl.x = a.x;
		this._bl.y = a.y
	};
	a._getBR = function() {
		return this._br
	};
	a._setBR = function(a) {
		this._br.x = a.x;
		this._br.y = a.y
	};
	cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
	cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
	cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
	cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
	cc.Quad3 = function(a, c, d, e) {
		this.bl = a || new cc.Vertex3F(0, 0, 0);
		this.br = c || new cc.Vertex3F(0, 0, 0);
		this.tl = d || new cc.Vertex3F(0, 0, 0);
		this.tr = e || new cc.Vertex3F(0, 0, 0)
	};
	cc.V3F_C4B_T2F = function(a, c, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var k = cc.Vertex3F.BYTES_PER_ELEMENT;
		this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, e, f) : new cc.Vertex3F(0, 0, 0, e, f);
		this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + k) : cc.color(0, 0, 0, 0, e, f + k);
		this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + k + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + k + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
	a = cc.V3F_C4B_T2F.prototype;
	a._getVertices = function() {
		return this._vertices
	};
	a._setVertices = function(a) {
		var c = this._vertices;
		c.x = a.x;
		c.y = a.y;
		c.z = a.z
	};
	a._getColor = function() {
		return this._colors
	};
	a._setColor = function(a) {
		var c = this._colors;
		c.r = a.r;
		c.g = a.g;
		c.b = a.b;
		c.a = a.a
	};
	a._getTexCoords = function() {
		return this._texCoords
	};
	a._setTexCoords = function(a) {
		this._texCoords.u = a.u;
		this._texCoords.v = a.v
	};
	cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
	cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
	cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
	cc.V3F_C4B_T2F_Quad = function(a, c, d, e, f, k) {
		this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
		this._offset = k || 0;
		f = this._arrayBuffer;
		k = this._offset;
		var m = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
		this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, k) : new cc.V3F_C4B_T2F(null, null, null, f, k);
		this._bl = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, f, k + m) : new cc.V3F_C4B_T2F(null, null, null, f, k + m);
		this._tr = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, k + 2 * m) : new cc.V3F_C4B_T2F(null, null, null, f, k + 2 * m);
		this._br = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, k + 3 * m) : new cc.V3F_C4B_T2F(null, null, null, f, k + 3 * m)
	};
	cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
	a = cc.V3F_C4B_T2F_Quad.prototype;
	a._getTL = function() {
		return this._tl
	};
	a._setTL = function(a) {
		var c = this._tl;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getBL = function() {
		return this._bl
	};
	a._setBL = function(a) {
		var c = this._bl;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getTR = function() {
		return this._tr
	};
	a._setTR = function(a) {
		var c = this._tr;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getBR = function() {
		return this._br
	};
	a._setBR = function(a) {
		var c = this._br;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getArrayBuffer = function() {
		return this._arrayBuffer
	};
	cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
	cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
	cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
	cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
	cc.defineGetterSetter(a, "arrayBuffer", a._getArrayBuffer, null);
	cc.V3F_C4B_T2F_QuadZero = function() {
		return new cc.V3F_C4B_T2F_Quad
	};
	cc.V3F_C4B_T2F_QuadCopy = function(a) {
		if (!a) return cc.V3F_C4B_T2F_QuadZero();
		var c = a.tl,
			d = a.bl,
			e = a.tr;
		a = a.br;
		return {
			tl: {
				vertices: {
					x: c.vertices.x,
					y: c.vertices.y,
					z: c.vertices.z
				},
				colors: {
					r: c.colors.r,
					g: c.colors.g,
					b: c.colors.b,
					a: c.colors.a
				},
				texCoords: {
					u: c.texCoords.u,
					v: c.texCoords.v
				}
			},
			bl: {
				vertices: {
					x: d.vertices.x,
					y: d.vertices.y,
					z: d.vertices.z
				},
				colors: {
					r: d.colors.r,
					g: d.colors.g,
					b: d.colors.b,
					a: d.colors.a
				},
				texCoords: {
					u: d.texCoords.u,
					v: d.texCoords.v
				}
			},
			tr: {
				vertices: {
					x: e.vertices.x,
					y: e.vertices.y,
					z: e.vertices.z
				},
				colors: {
					r: e.colors.r,
					g: e.colors.g,
					b: e.colors.b,
					a: e.colors.a
				},
				texCoords: {
					u: e.texCoords.u,
					v: e.texCoords.v
				}
			},
			br: {
				vertices: {
					x: a.vertices.x,
					y: a.vertices.y,
					z: a.vertices.z
				},
				colors: {
					r: a.colors.r,
					g: a.colors.g,
					b: a.colors.b,
					a: a.colors.a
				},
				texCoords: {
					u: a.texCoords.u,
					v: a.texCoords.v
				}
			}
		}
	};
	cc.V3F_C4B_T2F_QuadsCopy = function(a) {
		if (!a) return [];
		for (var c = [], d = 0; d < a.length; d++) c.push(cc.V3F_C4B_T2F_QuadCopy(a[d]));
		return c
	};
	cc.V2F_C4B_T2F = function(a, c, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var k = cc.Vertex2F.BYTES_PER_ELEMENT;
		this._vertices = a ? new cc.Vertex2F(a.x, a.y, e, f) : new cc.Vertex2F(0, 0, e, f);
		this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + k) : cc.color(0, 0, 0, 0, e, f + k);
		this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + k + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + k + cc.Color.BYTES_PER_ELEMENT)
	};
	cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
	a = cc.V2F_C4B_T2F.prototype;
	a._getVertices = function() {
		return this._vertices
	};
	a._setVertices = function(a) {
		this._vertices.x = a.x;
		this._vertices.y = a.y
	};
	a._getColor = function() {
		return this._colors
	};
	a._setColor = function(a) {
		var c = this._colors;
		c.r = a.r;
		c.g = a.g;
		c.b = a.b;
		c.a = a.a
	};
	a._getTexCoords = function() {
		return this._texCoords
	};
	a._setTexCoords = function(a) {
		this._texCoords.u = a.u;
		this._texCoords.v = a.v
	};
	cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
	cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
	cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
	cc.V2F_C4B_T2F_Triangle = function(a, c, d, e, f) {
		this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
		this._offset = f || 0;
		e = this._arrayBuffer;
		f = this._offset;
		var k = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
		this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V2F_C4B_T2F(null, null, null, e, f);
		this._b = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + k) : new cc.V2F_C4B_T2F(null, null, null, e, f + k);
		this._c = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 2 * k) : new cc.V2F_C4B_T2F(null, null, null, e, f + 2 * k)
	};
	cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
	a = cc.V2F_C4B_T2F_Triangle.prototype;
	a._getA = function() {
		return this._a
	};
	a._setA = function(a) {
		var c = this._a;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getB = function() {
		return this._b
	};
	a._setB = function(a) {
		var c = this._b;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	a._getC = function() {
		return this._c
	};
	a._setC = function(a) {
		var c = this._c;
		c.vertices = a.vertices;
		c.colors = a.colors;
		c.texCoords = a.texCoords
	};
	cc.defineGetterSetter(a, "a", a._getA, a._setA);
	cc.defineGetterSetter(a, "b", a._getB, a._setB);
	cc.defineGetterSetter(a, "c", a._getC, a._setC)
};
cc._tmp.PrototypeColor = function() {
	var a = cc.color;
	a._getWhite = function() {
		return a(255, 255, 255)
	};
	a._getYellow = function() {
		return a(255, 255, 0)
	};
	a._getBlue = function() {
		return a(0, 0, 255)
	};
	a._getGreen = function() {
		return a(0, 255, 0)
	};
	a._getRed = function() {
		return a(255, 0, 0)
	};
	a._getMagenta = function() {
		return a(255, 0, 255)
	};
	a._getBlack = function() {
		return a(0, 0, 0)
	};
	a._getOrange = function() {
		return a(255, 127, 0)
	};
	a._getGray = function() {
		return a(166, 166, 166)
	};
	cc.defineGetterSetter(a, "WHITE", a._getWhite);
	cc.defineGetterSetter(a, "YELLOW", a._getYellow);
	cc.defineGetterSetter(a, "BLUE", a._getBlue);
	cc.defineGetterSetter(a, "GREEN", a._getGreen);
	cc.defineGetterSetter(a, "RED", a._getRed);
	cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
	cc.defineGetterSetter(a, "BLACK", a._getBlack);
	cc.defineGetterSetter(a, "ORANGE", a._getOrange);
	cc.defineGetterSetter(a, "GRAY", a._getGray);
	cc.BlendFunc._disable = function() {
		return new cc.BlendFunc(cc.ONE, cc.ZERO)
	};
	cc.BlendFunc._alphaPremultiplied = function() {
		return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._alphaNonPremultiplied = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
	};
	cc.BlendFunc._additive = function() {
		return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
	};
	cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
	cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, b, c, d) {
	this.r = a || 0;
	this.g = b || 0;
	this.b = c || 0;
	this.a = null == d ? 255 : d
};
cc.color = function(a, b, c, d) {
	return void 0 === a ? {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	} : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
		r: a.r,
		g: a.g,
		b: a.b,
		a: null == a.a ? 255 : a.a
	} : {
		r: a,
		g: b,
		b: c,
		a: null == d ? 255 : d
	}
};
cc.colorEqual = function(a, b) {
	return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function(a, b, c, d) {
	this.x = a || 0;
	this.y = b || 0;
	this.z = c || 0;
	this.timestamp = d || 0
};
cc.Vertex2F = function(a, b) {
	this.x = a || 0;
	this.y = b || 0
};
cc.vertex2 = function(a, b) {
	return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function(a, b, c) {
	this.x = a || 0;
	this.y = b || 0;
	this.z = c || 0
};
cc.vertex3 = function(a, b, c) {
	return new cc.Vertex3F(a, b, c)
};
cc.Tex2F = function(a, b) {
	this.u = a || 0;
	this.v = b || 0
};
cc.tex2 = function(a, b) {
	return new cc.Tex2F(a, b)
};
cc.BlendFunc = function(a, b) {
	this.src = a;
	this.dst = b
};
cc.blendFuncDisable = function() {
	return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
	a = a.replace(/^#?/, "0x");
	a = parseInt(a);
	return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
	var b = a.r.toString(16),
		c = a.g.toString(16),
		d = a.b.toString(16);
	return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
	_keyMapTb: null,
	_valueMapTb: null,
	__currId: 0,
	ctor: function() {
		this._keyMapTb = {};
		this._valueMapTb = {};
		this.__currId = 2 << (0 | 10 * Math.random())
	},
	__getKey: function() {
		this.__currId++;
		return "key_" + this.__currId
	},
	setObject: function(a, b) {
		if (null != b) {
			var c = this.__getKey();
			this._keyMapTb[c] = b;
			this._valueMapTb[c] = a
		}
	},
	objectForKey: function(a) {
		if (null == a) return null;
		var b = this._keyMapTb,
			c;
		for (c in b)
		if (b[c] === a) return this._valueMapTb[c];
		return null
	},
	valueForKey: function(a) {
		return this.objectForKey(a)
	},
	removeObjectForKey: function(a) {
		if (null != a) {
			var b = this._keyMapTb,
				c;
			for (c in b)
			if (b[c] === a) {
				delete this._valueMapTb[c];
				delete b[c];
				break
			}
		}
	},
	removeObjectsForKeys: function(a) {
		if (null != a) for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
	},
	allKeys: function() {
		var a = [],
			b = this._keyMapTb,
			c;
		for (c in b) a.push(b[c]);
		return a
	},
	removeAllObjects: function() {
		this._keyMapTb = {};
		this._valueMapTb = {}
	},
	count: function() {
		return this.allKeys().length
	}
});
cc.FontDefinition = function(a) {
	this.fontName = "Arial";
	this.fontSize = 12;
	this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
	this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
	this.fillStyle = cc.color(255, 255, 255, 255);
	this.boundingHeight = this.boundingWidth = 0;
	this.strokeEnabled = !1;
	this.strokeStyle = cc.color(255, 255, 255, 255);
	this.lineWidth = 1;
	this.fontWeight = this.fontStyle = this.lineHeight = "normal";
	this.shadowEnabled = !1;
	this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
	this.shadowOpacity = 1;
	if (a && a instanceof Object) for (var b in a) this[b] = a[b]
};
cc.FontDefinition.prototype._getCanvasFontStr = function() {
	return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (!this.lineHeight.charAt ? this.lineHeight + "px" : this.lineHeight) + " '" + this.fontName + "'"
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
	init: function() {
		this.html = document.getElementsByTagName("html")[0]
	},
	availWidth: function(a) {
		return !a || a === this.html ? window.innerWidth : a.clientWidth
	},
	availHeight: function(a) {
		return !a || a === this.html ? window.innerHeight : a.clientHeight
	},
	meta: {
		width: "device-width",
		"user-scalable": "no"
	},
	adaptationType: cc.sys.browserType
}; - 1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch (cc.__BrowserGetter.adaptationType) {
case cc.sys.BROWSER_TYPE_SAFARI:
	cc.__BrowserGetter.meta["minimal-ui"] = "true";
	cc.__BrowserGetter.availWidth = function(a) {
		return a.clientWidth
	};
	cc.__BrowserGetter.availHeight = function(a) {
		return a.clientHeight
	};
	break;
case cc.sys.BROWSER_TYPE_CHROME:
	cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
		return cc.view._targetDensityDPI
	});
case cc.sys.BROWSER_TYPE_SOUGOU:
case cc.sys.BROWSER_TYPE_UC:
	cc.__BrowserGetter.availWidth = function(a) {
		return a.clientWidth
	};
	cc.__BrowserGetter.availHeight = function(a) {
		return a.clientHeight
	};
	break;
case cc.sys.BROWSER_TYPE_MIUI:
	cc.__BrowserGetter.init = function(a) {
		if (!a.__resizeWithBrowserSize) {
			var b = function() {
					a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy);
					window.removeEventListener("resize", b, !1)
				};
			window.addEventListener("resize", b, !1)
		}
	}
}
cc.EGLView = cc.Class.extend({
	_delegate: null,
	_frameSize: null,
	_designResolutionSize: null,
	_originalDesignResolutionSize: null,
	_viewPortRect: null,
	_visibleRect: null,
	_retinaEnabled: !1,
	_autoFullScreen: !0,
	_devicePixelRatio: 1,
	_viewName: "",
	_resizeCallback: null,
	_scaleX: 1,
	_originalScaleX: 1,
	_scaleY: 1,
	_originalScaleY: 1,
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_resolutionPolicy: null,
	_rpExactFit: null,
	_rpShowAll: null,
	_rpNoBorder: null,
	_rpFixedHeight: null,
	_rpFixedWidth: null,
	_initialized: !1,
	_captured: !1,
	_wnd: null,
	_hDC: null,
	_hRC: null,
	_supportTouch: !1,
	_contentTranslateLeftTop: null,
	_frame: null,
	_frameZoomFactor: 1,
	__resizeWithBrowserSize: !1,
	_isAdjustViewPort: !0,
	_targetDensityDPI: null,
	ctor: function() {
		var a = document,
			b = cc.ContainerStrategy,
			c = cc.ContentStrategy;
		cc.__BrowserGetter.init(this);
		this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
		this._frameSize = cc.size(0, 0);
		this._initFrameSize();
		var a = cc._canvas.width,
			d = cc._canvas.height;
		this._designResolutionSize = cc.size(a, d);
		this._originalDesignResolutionSize = cc.size(a, d);
		this._viewPortRect = cc.rect(0, 0, a, d);
		this._visibleRect = cc.rect(0, 0, a, d);
		this._contentTranslateLeftTop = {
			left: 0,
			top: 0
		};
		this._viewName = "Cocos2dHTML5";
		a = cc.sys;
		this.enableRetina(a.os === a.OS_IOS || a.os === a.OS_OSX);
		cc.visibleRect && cc.visibleRect.init(this._visibleRect);
		this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.EXACT_FIT);
		this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, c.SHOW_ALL);
		this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.NO_BORDER);
		this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_HEIGHT);
		this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_WIDTH);
		this._hDC = cc._canvas;
		this._hRC = cc._renderContext;
		this._targetDensityDPI = cc.DENSITYDPI_HIGH
	},
	_resizeEvent: function() {
		var a;
		a = this.setDesignResolutionSize ? this : cc.view;
		var b = a._frameSize.width,
			c = a._frameSize.height;
		a._initFrameSize();
		a._frameSize.width === b && a._frameSize.height === c || (a._resizeCallback && a._resizeCallback.call(), b = a._originalDesignResolutionSize.width, c = a._originalDesignResolutionSize.height, 0 < b && a.setDesignResolutionSize(b, c, a._resolutionPolicy))
	},
	setTargetDensityDPI: function(a) {
		this._targetDensityDPI = a;
		this._setViewPortMeta()
	},
	getTargetDensityDPI: function() {
		return this._targetDensityDPI
	},
	resizeWithBrowserSize: function(a) {
		a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, cc._addEventListener(window, "resize", this._resizeEvent), cc._addEventListener(window, "orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent))
	},
	setResizeCallback: function(a) {
		if (cc.isFunction(a) || null == a) this._resizeCallback = a
	},
	_initFrameSize: function() {
		var a = this._frameSize;
		a.width = cc.__BrowserGetter.availWidth(this._frame);
		a.height = cc.__BrowserGetter.availHeight(this._frame)
	},
	_adjustSizeKeepCanvasSize: function() {
		var a = this._originalDesignResolutionSize.width,
			b = this._originalDesignResolutionSize.height;
		0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
	},
	_setViewPortMeta: function() {
		if (this._isAdjustViewPort) {
			var a = document.getElementById("cocosMetaElement");
			a && document.head.removeChild(a);
			var b, c = (a = document.getElementsByName("viewport")) ? a[0] : null,
				d, a = cc.newElement("meta");
			a.id = "cocosMetaElement";
			a.name = "viewport";
			a.content = "";
			b = cc.__BrowserGetter.meta;
			d = c ? c.content : "";
			for (var e in b) RegExp(e).test(d) || (d += "," + e + "=" + b[e]);
			/^,/.test(d) && (d = d.substr(1));
			a.content = d;
			c && (c.content = d);
			document.head.appendChild(a)
		}
	},
	_setScaleXYForRenderTexture: function() {
		var a = cc.contentScaleFactor();
		this._scaleY = this._scaleX = a
	},
	_resetScale: function() {
		this._scaleX = this._originalScaleX;
		this._scaleY = this._originalScaleY
	},
	_adjustSizeToBrowser: function() {},
	initialize: function() {
		this._initialized = !0
	},
	adjustViewPort: function(a) {
		this._isAdjustViewPort = a
	},
	enableRetina: function(a) {
		this._retinaEnabled = a ? !0 : !1
	},
	isRetinaEnabled: function() {
		return this._retinaEnabled
	},
	enableAutoFullScreen: function(a) {
		this._autoFullScreen = a ? !0 : !1
	},
	isAutoFullScreenEnabled: function() {
		return this._autoFullScreen
	},
	end: function() {},
	isOpenGLReady: function() {
		return null !== this._hDC && null !== this._hRC
	},
	setFrameZoomFactor: function(a) {
		this._frameZoomFactor = a;
		this.centerWindow();
		cc.director.setProjection(cc.director.getProjection())
	},
	swapBuffers: function() {},
	setIMEKeyboardState: function(a) {},
	setContentTranslateLeftTop: function(a, b) {
		this._contentTranslateLeftTop = {
			left: a,
			top: b
		}
	},
	getContentTranslateLeftTop: function() {
		return this._contentTranslateLeftTop
	},
	getFrameSize: function() {
		return cc.size(this._frameSize.width, this._frameSize.height)
	},
	setFrameSize: function(a, b) {
		this._frameSize.width = a;
		this._frameSize.height = b;
		this._frame.style.width = a + "px";
		this._frame.style.height = b + "px";
		this._resizeEvent();
		cc.director.setProjection(cc.director.getProjection())
	},
	centerWindow: function() {},
	getVisibleSize: function() {
		return cc.size(this._visibleRect.width, this._visibleRect.height)
	},
	getVisibleOrigin: function() {
		return cc.p(this._visibleRect.x, this._visibleRect.y)
	},
	canSetContentScaleFactor: function() {
		return !0
	},
	getResolutionPolicy: function() {
		return this._resolutionPolicy
	},
	setResolutionPolicy: function(a) {
		if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
		else {
			var b = cc.ResolutionPolicy;
			a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
			a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
			a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
			a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
			a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
		}
	},
	setDesignResolutionSize: function(a, b, c) {
		if (0 < a || 0 < b) if (this.setResolutionPolicy(c), c = this._resolutionPolicy) {
			c.preApply(this);
			cc.sys.isMobile && this._setViewPortMeta();
			this._initFrameSize();
			this._originalDesignResolutionSize.width = this._designResolutionSize.width = a;
			this._originalDesignResolutionSize.height = this._designResolutionSize.height = b;
			var d = c.apply(this, this._designResolutionSize);
			d.scale && 2 === d.scale.length && (this._scaleX = d.scale[0], this._scaleY = d.scale[1]);
			d.viewport && (a = this._viewPortRect, b = this._visibleRect, d = d.viewport, a.x = d.x, a.y = d.y, a.width = d.width, a.height = d.height, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(a.x, -a.y));
			a = cc.director;
			a._winSizeInPoints.width = this._designResolutionSize.width;
			a._winSizeInPoints.height = this._designResolutionSize.height;
			c.postApply(this);
			cc.winSize.width = a._winSizeInPoints.width;
			cc.winSize.height = a._winSizeInPoints.height;
			cc._renderType === cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues());
			this._originalScaleX = this._scaleX;
			this._originalScaleY = this._scaleY;
			cc.DOM && cc.DOM._resetEGLViewDiv();
			cc.visibleRect && cc.visibleRect.init(this._visibleRect)
		} else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
		else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
	},
	getDesignResolutionSize: function() {
		return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
	},
	setViewPortInPoints: function(a, b, c, d) {
		var e = this._frameZoomFactor,
			f = this._scaleX,
			k = this._scaleY;
		cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * k * e + this._viewPortRect.y * e, c * f * e, d * k * e)
	},
	setScissorInPoints: function(a, b, c, d) {
		var e = this._frameZoomFactor,
			f = this._scaleX,
			k = this._scaleY;
		cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * k * e + this._viewPortRect.y * e, c * f * e, d * k * e)
	},
	isScissorEnabled: function() {
		var a = cc._renderContext;
		return a.isEnabled(a.SCISSOR_TEST)
	},
	getScissorRect: function() {
		var a = cc._renderContext,
			b = this._scaleX,
			c = this._scaleY,
			a = a.getParameter(a.SCISSOR_BOX);
		return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
	},
	setViewName: function(a) {
		null != a && 0 < a.length && (this._viewName = a)
	},
	getViewName: function() {
		return this._viewName
	},
	getViewPortRect: function() {
		return this._viewPortRect
	},
	getScaleX: function() {
		return this._scaleX
	},
	getScaleY: function() {
		return this._scaleY
	},
	getDevicePixelRatio: function() {
		return this._devicePixelRatio
	},
	convertToLocationInView: function(a, b, c) {
		return {
			x: this._devicePixelRatio * (a - c.left),
			y: this._devicePixelRatio * (c.top + c.height - b)
		}
	},
	_convertMouseToLocationInView: function(a, b) {
		var c = this._viewPortRect;
		a.x = (this._devicePixelRatio * (a.x - b.left) - c.x) / this._scaleX;
		a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
	},
	_convertTouchesWithScale: function(a) {
		for (var b = this._viewPortRect, c = this._scaleX, d = this._scaleY, e, f, k, m = 0; m < a.length; m++) e = a[m], f = e._point, k = e._prevPoint, e._setPoint((f.x - b.x) / c, (f.y - b.y) / d), e._setPrevPoint((k.x - b.x) / c, (k.y - b.y) / d)
	}
});
cc.EGLView._getInstance = function() {
	this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
	return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
	preApply: function(a) {},
	apply: function(a, b) {},
	postApply: function(a) {},
	_setupContainer: function(a, b, c) {
		var d = a._frame;
		cc.view._autoFullScreen && (cc.sys.isMobile && d === document.documentElement) && cc.screen.autoFullScreen(d);
		var d = cc._canvas,
			e = cc.container;
		e.style.width = d.style.width = b + "px";
		e.style.height = d.style.height = c + "px";
		e = a._devicePixelRatio = 1;
		a.isRetinaEnabled() && (e = a._devicePixelRatio = window.devicePixelRatio || 1);
		d.width = b * e;
		d.height = c * e;
		cc._renderContext.resetCache && cc._renderContext.resetCache();
		a = document.body;
		var f;
		if (a && (f = a.style)) f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px"
	},
	_fixContainer: function() {
		document.body.insertBefore(cc.container, document.body.firstChild);
		var a = document.body.style;
		a.width = window.innerWidth + "px";
		a.height = window.innerHeight + "px";
		a.overflow = "hidden";
		a = cc.container.style;
		a.position = "fixed";
		a.left = a.top = "0px";
		document.body.scrollTop = 0
	}
});
cc.ContentStrategy = cc.Class.extend({
	_result: {
		scale: [1, 1],
		viewport: null
	},
	_buildResult: function(a, b, c, d, e, f) {
		2 > Math.abs(a - c) && (c = a);
		2 > Math.abs(b - d) && (d = b);
		a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
		this._result.scale = [e, f];
		this._result.viewport = a;
		return this._result
	},
	preApply: function(a) {},
	apply: function(a, b) {
		return {
			scale: [1, 1]
		}
	},
	postApply: function(a) {}
});
(function() {
	var a = cc.ContainerStrategy.extend({
		apply: function(a) {
			this._setupContainer(a, a._frameSize.width, a._frameSize.height)
		}
	}),
		b = cc.ContainerStrategy.extend({
			apply: function(a, b) {
				var c = a._frameSize.width,
					d = a._frameSize.height,
					e = cc.container.style,
					r = b.width,
					s = b.height,
					u = c / r,
					t = d / s,
					w, v;
				u < t ? (w = c, v = s * u) : (w = r * t, v = d);
				r = Math.round((c - w) / 2);
				v = Math.round((d - v) / 2);
				this._setupContainer(a, c - 2 * r, d - 2 * v);
				e.marginLeft = r + "px";
				e.marginRight = r + "px";
				e.marginTop = v + "px";
				e.marginBottom = v + "px"
			}
		});
	a.extend({
		preApply: function(a) {
			this._super(a);
			a._frame = document.documentElement
		},
		apply: function(a) {
			this._super(a);
			this._fixContainer()
		}
	});
	b.extend({
		preApply: function(a) {
			this._super(a);
			a._frame = document.documentElement
		},
		apply: function(a, b) {
			this._super(a, b);
			this._fixContainer()
		}
	});
	var c = cc.ContainerStrategy.extend({
		apply: function(a) {
			this._setupContainer(a, cc._canvas.width, cc._canvas.height)
		}
	});
	cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
	cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
	cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
	var a = cc.ContentStrategy.extend({
		apply: function(a, b) {
			var c = cc._canvas.width,
				d = cc._canvas.height;
			return this._buildResult(c, d, c, d, c / b.width, d / b.height)
		}
	}),
		b = cc.ContentStrategy.extend({
			apply: function(a, b) {
				var c = cc._canvas.width,
					d = cc._canvas.height,
					e = b.width,
					r = b.height,
					s = c / e,
					u = d / r,
					t = 0,
					w, v;
				s < u ? (t = s, w = c, v = r * t) : (t = u, w = e * t, v = d);
				return this._buildResult(c, d, w, v, t, t)
			}
		}),
		c = cc.ContentStrategy.extend({
			apply: function(a, b) {
				var c = cc._canvas.width,
					d = cc._canvas.height,
					e = b.width,
					r = b.height,
					s = c / e,
					u = d / r,
					t, w, v;
				s < u ? (t = u, w = e * t, v = d) : (t = s, w = c, v = r * t);
				return this._buildResult(c, d, w, v, t, t)
			}
		}),
		d = cc.ContentStrategy.extend({
			apply: function(a, b) {
				var c = cc._canvas.width,
					d = cc._canvas.height,
					e = d / b.height;
				return this._buildResult(c, d, c, d, e, e)
			},
			postApply: function(a) {
				cc.director._winSizeInPoints = a.getVisibleSize()
			}
		}),
		e = cc.ContentStrategy.extend({
			apply: function(a, b) {
				var c = cc._canvas.width,
					d = cc._canvas.height,
					e = c / b.width;
				return this._buildResult(c, d, c, d, e, e)
			},
			postApply: function(a) {
				cc.director._winSizeInPoints = a.getVisibleSize()
			}
		});
	cc.ContentStrategy.EXACT_FIT = new a;
	cc.ContentStrategy.SHOW_ALL = new b;
	cc.ContentStrategy.NO_BORDER = new c;
	cc.ContentStrategy.FIXED_HEIGHT = new d;
	cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({
	_containerStrategy: null,
	_contentStrategy: null,
	ctor: function(a, b) {
		this.setContainerStrategy(a);
		this.setContentStrategy(b)
	},
	preApply: function(a) {
		this._containerStrategy.preApply(a);
		this._contentStrategy.preApply(a)
	},
	apply: function(a, b) {
		this._containerStrategy.apply(a, b);
		return this._contentStrategy.apply(a, b)
	},
	postApply: function(a) {
		this._containerStrategy.postApply(a);
		this._contentStrategy.postApply(a)
	},
	setContainerStrategy: function(a) {
		a instanceof cc.ContainerStrategy && (this._containerStrategy = a)
	},
	setContentStrategy: function(a) {
		a instanceof cc.ContentStrategy && (this._contentStrategy = a)
	}
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
	_supportsFullScreen: !1,
	_preOnFullScreenChange: null,
	_touchEvent: "",
	_fn: null,
	_fnMap: [
		["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
		["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
		["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
		["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
		["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
	],
	init: function() {
		this._fn = {};
		var a, b, c = this._fnMap,
			d;
		a = 0;
		for (l = c.length; a < l; a++)
		if ((b = c[a]) && b[1] in document) {
			a = 0;
			for (d = b.length; a < d; a++) this._fn[c[0][a]] = b[a];
			break
		}
		this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
		this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
	},
	fullScreen: function() {
		return this._supportsFullScreen && document[this._fn.fullscreenElement]
	},
	requestFullScreen: function(a, b) {
		if (this._supportsFullScreen) {
			a = a || document.documentElement;
			if (b) {
				var c = this._fn.fullscreenchange;
				this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange);
				this._preOnFullScreenChange = b;
				cc._addEventListener(document, c, b, !1)
			}
			return a[this._fn.requestFullscreen]()
		}
	},
	exitFullScreen: function() {
		return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
	},
	autoFullScreen: function(a, b) {
		function c() {
			e.requestFullScreen(a, b);
			d.removeEventListener(e._touchEvent, c)
		}
		a = a || document.body;
		var d = cc._canvas || a,
			e = this;
		this.requestFullScreen(a, b);
		cc._addEventListener(d, this._touchEvent, c)
	}
};
cc.screen.init();
cc.visibleRect = {
	topLeft: cc.p(0, 0),
	topRight: cc.p(0, 0),
	top: cc.p(0, 0),
	bottomLeft: cc.p(0, 0),
	bottomRight: cc.p(0, 0),
	bottom: cc.p(0, 0),
	center: cc.p(0, 0),
	left: cc.p(0, 0),
	right: cc.p(0, 0),
	width: 0,
	height: 0,
	init: function(a) {
		var b = this.width = a.width,
			c = this.height = a.height,
			d = a.x;
		a = a.y;
		var e = a + c,
			f = d + b;
		this.topLeft.x = d;
		this.topLeft.y = e;
		this.topRight.x = f;
		this.topRight.y = e;
		this.top.x = d + b / 2;
		this.top.y = e;
		this.bottomLeft.x = d;
		this.bottomLeft.y = a;
		this.bottomRight.x = f;
		this.bottomRight.y = a;
		this.bottom.x = d + b / 2;
		this.bottom.y = a;
		this.center.x = d + b / 2;
		this.center.y = a + c / 2;
		this.left.x = d;
		this.left.y = a + c / 2;
		this.right.x = f;
		this.right.y = a + c / 2
	}
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
	_mousePressed: !1,
	_isRegisterEvent: !1,
	_preTouchPoint: cc.p(0, 0),
	_prevMousePoint: cc.p(0, 0),
	_preTouchPool: [],
	_preTouchPoolPointer: 0,
	_touches: [],
	_touchesIntegerDict: {},
	_indexBitsUsed: 0,
	_maxTouches: 5,
	_accelEnabled: !1,
	_accelInterval: 1 / 30,
	_accelMinus: 1,
	_accelCurTime: 0,
	_acceleration: null,
	_accelDeviceEvent: null,
	_getUnUsedIndex: function() {
		for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
			if (!(a & 1)) return this._indexBitsUsed |= 1 << b, b;
			a >>= 1
		}
		return -1
	},
	_removeUsedIndexBit: function(a) {
		0 > a || a >= this._maxTouches || (a = ~ (1 << a), this._indexBitsUsed &= a)
	},
	_glView: null,
	handleTouchesBegin: function(a) {
		for (var b, c, d, e = [], f = this._touchesIntegerDict, k = 0, m = a.length; k < m; k++)
		if (b = a[k], d = b.getID(), c = f[d], null == c) {
			var n = this._getUnUsedIndex(); - 1 === n ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, n) : (c = this._touches[n] = new cc.Touch(b._point.x, b._point.y, b.getID()), c._setPrevPoint(b._prevPoint), f[d] = n, e.push(c))
		}
		0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesMove: function(a) {
		for (var b, c, d = [], e = this._touches, f = 0, k = a.length; f < k; f++) b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point), e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
		0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesEnd: function(a) {
		a = this.getSetOfTouchesEndOrCancel(a);
		0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
	},
	handleTouchesCancel: function(a) {
		a = this.getSetOfTouchesEndOrCancel(a);
		0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
	},
	getSetOfTouchesEndOrCancel: function(a) {
		for (var b, c, d, e = [], f = this._touches, k = this._touchesIntegerDict, m = 0, n = a.length; m < n; m++) b = a[m], d = b.getID(), c = k[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete k[d]);
		return e
	},
	getHTMLElementPosition: function(a) {
		var b = document.documentElement,
			c = window,
			d = null,
			d = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
				left: 0,
				top: 0,
				width: a.width,
				height: a.height
			} : {
				left: 0,
				top: 0,
				width: parseInt(a.style.width),
				height: parseInt(a.style.height)
			};
		return {
			left: d.left + c.pageXOffset - b.clientLeft,
			top: d.top + c.pageYOffset - b.clientTop,
			width: d.width,
			height: d.height
		}
	},
	getPreTouch: function(a) {
		for (var b = null, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
		if (c[e].getID() === d) {
			b = c[e];
			break
		}
		b || (b = a);
		return b
	},
	setPreTouch: function(a) {
		for (var b = !1, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
		if (c[e].getID() === d) {
			c[e] = a;
			b = !0;
			break
		}
		b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
	},
	getTouchByXY: function(a, b, c) {
		var d = this._preTouchPoint;
		a = this._glView.convertToLocationInView(a, b, c);
		b = new cc.Touch(a.x, a.y);
		b._setPrevPoint(d.x, d.y);
		d.x = a.x;
		d.y = a.y;
		return b
	},
	getMouseEvent: function(a, b, c) {
		var d = this._prevMousePoint;
		this._glView._convertMouseToLocationInView(a, b);
		b = new cc.EventMouse(c);
		b.setLocation(a.x, a.y);
		b._setPrevCursor(d.x, d.y);
		d.x = a.x;
		d.y = a.y;
		return b
	},
	getPointByEvent: function(a, b) {
		if (null != a.pageX) return {
			x: a.pageX,
			y: a.pageY
		};
		b.left -= document.body.scrollLeft;
		b.top -= document.body.scrollTop;
		return {
			x: a.clientX,
			y: a.clientY
		}
	},
	getTouchesByEvent: function(a, b) {
		for (var c = [], d = this._glView, e, f, k = this._preTouchPoint, m = a.changedTouches.length, n = 0; n < m; n++)
		if (e = a.changedTouches[n]) {
			var p;
			p = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? d.convertToLocationInView(e.pageX, e.pageY, b) : d.convertToLocationInView(e.clientX, e.clientY, b);
			null != e.identifier ? (e = new cc.Touch(p.x, p.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(p.x, p.y), e._setPrevPoint(k.x, k.y));
			k.x = p.x;
			k.y = p.y;
			c.push(e)
		}
		return c
	},
	registerSystemEvent: function(a) {
		if (!this._isRegisterEvent) {
			this._glView = cc.view;
			var b = this,
				c = "mouse" in cc.sys.capabilities,
				d = "touches" in cc.sys.capabilities,
				e = !1;
			cc.sys.isMobile && (e = !0);
			c && (cc._addEventListener(window, "mousedown", function() {
				b._mousePressed = !0
			}, !1), cc._addEventListener(window, "mouseup", function(c) {
				if (!e) {
					var d = b._mousePressed;
					b._mousePressed = !1;
					if (d) {
						var d = b.getHTMLElementPosition(a),
							f = b.getPointByEvent(c, d);
						cc.rectContainsPoint(new cc.Rect(d.left, d.top, d.width, d.height), f) || (b.handleTouchesEnd([b.getTouchByXY(f.x, f.y, d)]), d = b.getMouseEvent(f, d, cc.EventMouse.UP), d.setButton(c.button), cc.eventManager.dispatchEvent(d))
					}
				}
			}, !1), cc._addEventListener(a, "mousedown", function(c) {
				if (!e) {
					b._mousePressed = !0;
					var d = b.getHTMLElementPosition(a),
						f = b.getPointByEvent(c, d);
					b.handleTouchesBegin([b.getTouchByXY(f.x, f.y, d)]);
					d = b.getMouseEvent(f, d, cc.EventMouse.DOWN);
					d.setButton(c.button);
					cc.eventManager.dispatchEvent(d);
					c.stopPropagation();
					c.preventDefault();
					a.focus()
				}
			}, !1), cc._addEventListener(a, "mouseup", function(c) {
				if (!e) {
					b._mousePressed = !1;
					var d = b.getHTMLElementPosition(a),
						f = b.getPointByEvent(c, d);
					b.handleTouchesEnd([b.getTouchByXY(f.x, f.y, d)]);
					d = b.getMouseEvent(f, d, cc.EventMouse.UP);
					d.setButton(c.button);
					cc.eventManager.dispatchEvent(d);
					c.stopPropagation();
					c.preventDefault()
				}
			}, !1), cc._addEventListener(a, "mousemove", function(c) {
				if (!e) {
					var d = b.getHTMLElementPosition(a),
						f = b.getPointByEvent(c, d);
					b.handleTouchesMove([b.getTouchByXY(f.x, f.y, d)]);
					d = b.getMouseEvent(f, d, cc.EventMouse.MOVE);
					b._mousePressed ? d.setButton(c.button) : d.setButton(null);
					cc.eventManager.dispatchEvent(d);
					c.stopPropagation();
					c.preventDefault()
				}
			}, !1), cc._addEventListener(a, "mousewheel", function(c) {
				var d = b.getHTMLElementPosition(a),
					e = b.getPointByEvent(c, d),
					d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
				d.setButton(c.button);
				d.setScrollData(0, c.wheelDelta);
				cc.eventManager.dispatchEvent(d);
				c.stopPropagation();
				c.preventDefault()
			}, !1), cc._addEventListener(a, "DOMMouseScroll", function(c) {
				var d = b.getHTMLElementPosition(a),
					e = b.getPointByEvent(c, d),
					d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
				d.setButton(c.button);
				d.setScrollData(0, -120 * c.detail);
				cc.eventManager.dispatchEvent(d);
				c.stopPropagation();
				c.preventDefault()
			}, !1));
			if (window.navigator.msPointerEnabled) {
				var c = {
					MSPointerDown: b.handleTouchesBegin,
					MSPointerMove: b.handleTouchesMove,
					MSPointerUp: b.handleTouchesEnd,
					MSPointerCancel: b.handleTouchesCancel
				},
					f;
				for (f in c)(function(c, d) {
					cc._addEventListener(a, c, function(c) {
						var e = b.getHTMLElementPosition(a);
						e.left -= document.documentElement.scrollLeft;
						e.top -= document.documentElement.scrollTop;
						d.call(b, [b.getTouchByXY(c.clientX, c.clientY, e)]);
						c.stopPropagation()
					}, !1)
				})(f, c[f])
			}
			d && (cc._addEventListener(a, "touchstart", function(c) {
				if (c.changedTouches) {
					var d = b.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					b.handleTouchesBegin(b.getTouchesByEvent(c, d));
					c.stopPropagation();
					c.preventDefault();
					a.focus()
				}
			}, !1), cc._addEventListener(a, "touchmove", function(c) {
				if (c.changedTouches) {
					var d = b.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					b.handleTouchesMove(b.getTouchesByEvent(c, d));
					c.stopPropagation();
					c.preventDefault()
				}
			}, !1), cc._addEventListener(a, "touchend", function(c) {
				if (c.changedTouches) {
					var d = b.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					b.handleTouchesEnd(b.getTouchesByEvent(c, d));
					c.stopPropagation();
					c.preventDefault()
				}
			}, !1), cc._addEventListener(a, "touchcancel", function(c) {
				if (c.changedTouches) {
					var d = b.getHTMLElementPosition(a);
					d.left -= document.body.scrollLeft;
					d.top -= document.body.scrollTop;
					b.handleTouchesCancel(b.getTouchesByEvent(c, d));
					c.stopPropagation();
					c.preventDefault()
				}
			}, !1));
			this._registerKeyboardEvent();
			this._registerAccelerometerEvent();
			this._isRegisterEvent = !0
		}
	},
	_registerKeyboardEvent: function() {},
	_registerAccelerometerEvent: function() {},
	update: function(a) {
		this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
		this._accelCurTime += a
	}
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
	this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelCurTime = 0, a.scheduleUpdate(this))
};
_p.setAccelerometerInterval = function(a) {
	this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
	cc._addEventListener(cc._canvas, "keydown", function(a) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
		a.stopPropagation();
		a.preventDefault()
	}, !1);
	cc._addEventListener(cc._canvas, "keyup", function(a) {
		cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
		a.stopPropagation();
		a.preventDefault()
	}, !1)
};
_p._registerAccelerometerEvent = function() {
	var a = window;
	this._acceleration = new cc.Acceleration;
	this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
	cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
	var b = this._accelDeviceEvent === a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
		c = navigator.userAgent;
	if (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType === cc.BROWSER_TYPE_UC) this._minus = -1;
	cc._addEventListener(a, b, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
	var b = window;
	if (this._accelEnabled) {
		var c = this._acceleration,
			d, e, f;
		this._accelDeviceEvent === window.DeviceMotionEvent ? (f = a.accelerationIncludingGravity, d = 0.1 * this._accelMinus * f.x, e = 0.1 * this._accelMinus * f.y, f = 0.1 * f.z) : (d = 0.981 * (a.gamma / 90), e = 0.981 * -(a.beta / 90), f = 0.981 * (a.alpha / 90));
		cc.sys.os === cc.sys.OS_ANDROID ? (c.x = -d, c.y = -e) : (c.x = d, c.y = e);
		c.z = f;
		c.timestamp = a.timeStamp || Date.now();
		a = c.x;
		b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (c.x = -c.y, c.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (c.x = c.y, c.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (c.x = -c.x, c.y = -c.y)
	}
};
delete _p;
cc.AffineTransform = function(a, b, c, d, e, f) {
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.tx = e;
	this.ty = f
};
cc.affineTransformMake = function(a, b, c, d, e, f) {
	return {
		a: a,
		b: b,
		c: c,
		d: d,
		tx: e,
		ty: f
	}
};
cc.pointApplyAffineTransform = function(a, b, c) {
	var d;
	void 0 === c ? (c = b, d = a.x, a = a.y) : (d = a, a = b);
	return {
		x: c.a * d + c.c * a + c.tx,
		y: c.b * d + c.d * a + c.ty
	}
};
cc._pointApplyAffineTransform = function(a, b, c) {
	return cc.pointApplyAffineTransform(a, b, c)
};
cc.sizeApplyAffineTransform = function(a, b) {
	return {
		width: b.a * a.width + b.c * a.height,
		height: b.b * a.width + b.d * a.height
	}
};
cc.affineTransformMakeIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.affineTransformIdentity = function() {
	return {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	}
};
cc.rectApplyAffineTransform = function(a, b) {
	var c = cc.rectGetMinY(a),
		d = cc.rectGetMinX(a),
		e = cc.rectGetMaxX(a),
		f = cc.rectGetMaxY(a),
		k = cc.pointApplyAffineTransform(d, c, b),
		c = cc.pointApplyAffineTransform(e, c, b),
		d = cc.pointApplyAffineTransform(d, f, b),
		m = cc.pointApplyAffineTransform(e, f, b),
		e = Math.min(k.x, c.x, d.x, m.x),
		f = Math.max(k.x, c.x, d.x, m.x),
		n = Math.min(k.y, c.y, d.y, m.y),
		k = Math.max(k.y, c.y, d.y, m.y);
	return cc.rect(e, n, f - e, k - n)
};
cc._rectApplyAffineTransformIn = function(a, b) {
	var c = cc.rectGetMinY(a),
		d = cc.rectGetMinX(a),
		e = cc.rectGetMaxX(a),
		f = cc.rectGetMaxY(a),
		k = cc.pointApplyAffineTransform(d, c, b),
		c = cc.pointApplyAffineTransform(e, c, b),
		d = cc.pointApplyAffineTransform(d, f, b),
		m = cc.pointApplyAffineTransform(e, f, b),
		e = Math.min(k.x, c.x, d.x, m.x),
		f = Math.max(k.x, c.x, d.x, m.x),
		n = Math.min(k.y, c.y, d.y, m.y),
		k = Math.max(k.y, c.y, d.y, m.y);
	a.x = e;
	a.y = n;
	a.width = f - e;
	a.height = k - n;
	return a
};
cc.affineTransformTranslate = function(a, b, c) {
	return {
		a: a.a,
		b: a.b,
		c: a.c,
		d: a.d,
		tx: a.tx + a.a * b + a.c * c,
		ty: a.ty + a.b * b + a.d * c
	}
};
cc.affineTransformScale = function(a, b, c) {
	return {
		a: a.a * b,
		b: a.b * b,
		c: a.c * c,
		d: a.d * c,
		tx: a.tx,
		ty: a.ty
	}
};
cc.affineTransformRotate = function(a, b) {
	var c = Math.sin(b),
		d = Math.cos(b);
	return {
		a: a.a * d + a.c * c,
		b: a.b * d + a.d * c,
		c: a.c * d - a.a * c,
		d: a.d * d - a.b * c,
		tx: a.tx,
		ty: a.ty
	}
};
cc.affineTransformConcat = function(a, b) {
	return {
		a: a.a * b.a + a.b * b.c,
		b: a.a * b.b + a.b * b.d,
		c: a.c * b.a + a.d * b.c,
		d: a.c * b.b + a.d * b.d,
		tx: a.tx * b.a + a.ty * b.c + b.tx,
		ty: a.tx * b.b + a.ty * b.d + b.ty
	}
};
cc.affineTransformConcatIn = function(a, b) {
	var c = a.a,
		d = a.b,
		e = a.c,
		f = a.d,
		k = a.tx,
		m = a.ty;
	a.a = c * b.a + d * b.c;
	a.b = c * b.b + d * b.d;
	a.c = e * b.a + f * b.c;
	a.d = e * b.b + f * b.d;
	a.tx = k * b.a + m * b.c + b.tx;

	a.ty = k * b.b + m * b.d + b.ty;
	return a
};
cc.affineTransformEqualToTransform = function(a, b) {
	return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.affineTransformInvert = function(a) {
	var b = 1 / (a.a * a.d - a.b * a.c);
	return {
		a: b * a.d,
		b: -b * a.b,
		c: -b * a.c,
		d: b * a.a,
		tx: b * (a.c * a.ty - a.d * a.tx),
		ty: b * (a.b * a.tx - a.a * a.ty)
	}
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
	return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, b) {
	return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function(a, b) {
	return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function(a, b) {
	return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function(a, b) {
	return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function(a, b) {
	return a.x * b.x + a.y * b.y
};
cc.pCross = function(a, b) {
	return a.x * b.y - a.y * b.x
};
cc.pPerp = function(a) {
	return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
	return cc.p(a.y, -a.x)
};
cc.pProject = function(a, b) {
	return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function(a, b) {
	return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function(a, b) {
	return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function(a) {
	return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, b) {
	return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function(a) {
	return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, b) {
	return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function(a) {
	var b = cc.pLength(a);
	return 0 === b ? cc.p(a) : cc.pMult(a, 1 / b)
};
cc.pForAngle = function(a) {
	return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
	return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, b, c) {
	if (b > c) {
		var d = b;
		b = c;
		c = d
	}
	return a < b ? b : a < c ? a : c
};
cc.pClamp = function(a, b, c) {
	return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
};
cc.pFromSize = function(a) {
	return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, b) {
	return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function(a, b, c) {
	return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
};
cc.pFuzzyEqual = function(a, b, c) {
	return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
};
cc.pCompMult = function(a, b) {
	return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function(a, b) {
	var c = cc.pNormalize(a),
		d = cc.pNormalize(b),
		c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
	return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pAngle = function(a, b) {
	var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
	return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pRotateByAngle = function(a, b, c) {
	a = cc.pSub(a, b);
	var d = Math.cos(c);
	c = Math.sin(c);
	var e = a.x;
	a.x = e * d - a.y * c + b.x;
	a.y = e * c + a.y * d + b.y;
	return a
};
cc.pLineIntersect = function(a, b, c, d, e) {
	if (a.x === b.x && a.y === b.y || c.x === d.x && c.y === d.y) return !1;
	var f = b.x - a.x;
	b = b.y - a.y;
	var k = d.x - c.x;
	d = d.y - c.y;
	var m = a.x - c.x;
	a = a.y - c.y;
	c = d * f - k * b;
	e.x = k * a - d * m;
	e.y = f * a - b * m;
	if (0 === c) return 0 === e.x || 0 === e.y ? !0 : !1;
	e.x /= c;
	e.y /= c;
	return !0
};
cc.pSegmentIntersect = function(a, b, c, d) {
	var e = cc.p(0, 0);
	return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function(a, b, c, d) {
	var e = cc.p(0, 0);
	return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
};
cc.pSameAs = function(a, b) {
	return null != a && null != b ? a.x === b.x && a.y === b.y : !1
};
cc.pZeroIn = function(a) {
	a.x = 0;
	a.y = 0
};
cc.pIn = function(a, b) {
	a.x = b.x;
	a.y = b.y
};
cc.pMultIn = function(a, b) {
	a.x *= b;
	a.y *= b
};
cc.pSubIn = function(a, b) {
	a.x -= b.x;
	a.y -= b.y
};
cc.pAddIn = function(a, b) {
	a.x += b.x;
	a.y += b.y
};
cc.pNormalizeIn = function(a) {
	cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, b, c, d, e) {
	e += d;
	if (!(1 >= e)) {
		b *= 0.5;
		for (var f, k = e - 1, m = d; m < e; m++) {
			f = 2 * m;
			var n = cc.p(a[2 * m], a[2 * m + 1]),
				p;
			if (0 === m) p = cc.pPerp(cc.pNormalize(cc.pSub(n, cc.p(a[2 * (m + 1)], a[2 * (m + 1) + 1]))));
			else if (m === k) p = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (m - 1)], a[2 * (m - 1) + 1]), n)));
			else {
				p = cc.p(a[2 * (m - 1)], a[2 * (m - 1) + 1]);
				var r = cc.p(a[2 * (m + 1)], a[2 * (m + 1) + 1]),
					s = cc.pNormalize(cc.pSub(r, n)),
					u = cc.pNormalize(cc.pSub(p, n)),
					t = Math.acos(cc.pDot(s, u));
				p = t < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(s, u))) : t < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(s, u)) : cc.pPerp(cc.pNormalize(cc.pSub(r, p)))
			}
			p = cc.pMult(p, b);
			c[2 * f] = n.x + p.x;
			c[2 * f + 1] = n.y + p.y;
			c[2 * (f + 1)] = n.x - p.x;
			c[2 * (f + 1) + 1] = n.y - p.y
		}
		for (m = 0 === d ? 0 : d - 1; m < k; m++) {
			f = 2 * m;
			a = f + 2;
			b = cc.vertex2(c[2 * f], c[2 * f + 1]);
			e = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]);
			f = cc.vertex2(c[2 * a], c[2 * a]);
			d = cc.vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]);
			b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y);
			if (!b.isSuccess && (0 > b.value || 1 < b.value)) b.isSuccess = !0;
			b.isSuccess && (c[2 * a] = d.x, c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
		}
	}
};
cc.vertexLineIntersect = function(a, b, c, d, e, f, k, m) {
	if (a === c && b === d || e === k && f === m) return {
		isSuccess: !1,
		value: 0
	};
	c -= a;
	d -= b;
	e -= a;
	f -= b;
	k -= a;
	m -= b;
	a = Math.sqrt(c * c + d * d);
	c /= a;
	d /= a;
	b = e * c + f * d;
	f = f * c - e * d;
	e = b;
	b = k * c + m * d;
	m = m * c - k * d;
	k = b;
	return f === m ? {
		isSuccess: !1,
		value: 0
	} : {
		isSuccess: !0,
		value: (k + (e - k) * m / (m - f)) / a
	}
};
cc.vertexListIsClockwise = function(a) {
	for (var b = 0, c = a.length; b < c; b++) {
		var d = a[(b + 1) % c],
			e = a[(b + 2) % c];
		if (0 < cc.pCross(cc.pSub(d, a[b]), cc.pSub(e, d))) return !1
	}
	return !0
};
cc.CGAffineToGL = function(a, b) {
	b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
	b[10] = b[15] = 1;
	b[0] = a.a;
	b[4] = a.c;
	b[12] = a.tx;
	b[1] = a.b;
	b[5] = a.d;
	b[13] = a.ty
};
cc.GLToCGAffine = function(a, b) {
	b.a = a[0];
	b.c = a[4];
	b.tx = a[12];
	b.b = a[1];
	b.d = a[5];
	b.ty = a[13]
};
cc.Touch = cc.Class.extend({
	_point: null,
	_prevPoint: null,
	_id: 0,
	_startPointCaptured: !1,
	_startPoint: null,
	ctor: function(a, b, c) {
		this._point = cc.p(a || 0, b || 0);
		this._id = c || 0
	},
	getLocation: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getLocationX: function() {
		return this._point.x
	},
	getLocationY: function() {
		return this._point.y
	},
	getPreviousLocation: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocation: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getDelta: function() {
		return cc.pSub(this._point, this._prevPoint)
	},
	getLocationInView: function() {
		return {
			x: this._point.x,
			y: this._point.y
		}
	},
	getPreviousLocationInView: function() {
		return {
			x: this._prevPoint.x,
			y: this._prevPoint.y
		}
	},
	getStartLocationInView: function() {
		return {
			x: this._startPoint.x,
			y: this._startPoint.y
		}
	},
	getID: function() {
		return this._id
	},
	getId: function() {
		cc.log("getId is deprecated. Please use getID instead.");
		return this._id
	},
	setTouchInfo: function(a, b, c) {
		this._prevPoint = this._point;
		this._point = cc.p(b || 0, c || 0);
		this._id = a;
		this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
	},
	_setPoint: function(a, b) {
		void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
	},
	_setPrevPoint: function(a, b) {
		this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
	}
});
cc.Event = cc.Class.extend({
	_type: 0,
	_isStopped: !1,
	_currentTarget: null,
	_setCurrentTarget: function(a) {
		this._currentTarget = a
	},
	ctor: function(a) {
		this._type = a
	},
	getType: function() {
		return this._type
	},
	stopPropagation: function() {
		this._isStopped = !0
	},
	isStopped: function() {
		return this._isStopped
	},
	getCurrentTarget: function() {
		return this._currentTarget
	}
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
	_eventName: null,
	_userData: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
		this._eventName = a
	},
	setUserData: function(a) {
		this._userData = a
	},
	getUserData: function() {
		return this._userData
	},
	getEventName: function() {
		return this._eventName
	}
});
cc.EventMouse = cc.Event.extend({
	_eventType: 0,
	_button: 0,
	_x: 0,
	_y: 0,
	_prevX: 0,
	_prevY: 0,
	_scrollX: 0,
	_scrollY: 0,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
		this._eventType = a
	},
	setScrollData: function(a, b) {
		this._scrollX = a;
		this._scrollY = b
	},
	getScrollX: function() {
		return this._scrollX
	},
	getScrollY: function() {
		return this._scrollY
	},
	setLocation: function(a, b) {
		this._x = a;
		this._y = b
	},
	getLocation: function() {
		return {
			x: this._x,
			y: this._y
		}
	},
	getLocationInView: function() {
		return {
			x: this._x,
			y: cc.view._designResolutionSize.height - this._y
		}
	},
	_setPrevCursor: function(a, b) {
		this._prevX = a;
		this._prevY = b
	},
	getDelta: function() {
		return {
			x: this._x - this._prevX,
			y: this._y - this._prevY
		}
	},
	getDeltaX: function() {
		return this._x - this._prevX
	},
	getDeltaY: function() {
		return this._y - this._prevY
	},
	setButton: function(a) {
		this._button = a
	},
	getButton: function() {
		return this._button
	},
	getLocationX: function() {
		return this._x
	},
	getLocationY: function() {
		return this._y
	}
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
	_eventCode: 0,
	_touches: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
		this._touches = a || []
	},
	getEventCode: function() {
		return this._eventCode
	},
	getTouches: function() {
		return this._touches
	},
	_setEventCode: function(a) {
		this._eventCode = a
	},
	_setTouches: function(a) {
		this._touches = a
	}
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
	BEGAN: 0,
	MOVED: 1,
	ENDED: 2,
	CANCELLED: 3
};
cc.EventFocus = cc.Event.extend({
	_widgetGetFocus: null,
	_widgetLoseFocus: null,
	ctor: function(a, b) {
		cc.Event.prototype.ctor.call(this, cc.Event.FOCUS);
		this._widgetGetFocus = b;
		this._widgetLoseFocus = a
	}
});
cc.EventListener = cc.Class.extend({
	_onEvent: null,
	_type: 0,
	_listenerID: null,
	_registered: !1,
	_fixedPriority: 0,
	_node: null,
	_paused: !0,
	_isEnabled: !0,
	ctor: function(a, b, c) {
		this._onEvent = c;
		this._type = a || 0;
		this._listenerID = b || ""
	},
	_setPaused: function(a) {
		this._paused = a
	},
	_isPaused: function() {
		return this._paused
	},
	_setRegistered: function(a) {
		this._registered = a
	},
	_isRegistered: function() {
		return this._registered
	},
	_getType: function() {
		return this._type
	},
	_getListenerID: function() {
		return this._listenerID
	},
	_setFixedPriority: function(a) {
		this._fixedPriority = a
	},
	_getFixedPriority: function() {
		return this._fixedPriority
	},
	_setSceneGraphPriority: function(a) {
		this._node = a
	},
	_getSceneGraphPriority: function() {
		return this._node
	},
	checkAvailable: function() {
		return null !== this._onEvent
	},
	clone: function() {
		return null
	},
	setEnabled: function(a) {
		this._isEnabled = a
	},
	isEnabled: function() {
		return this._isEnabled
	},
	retain: function() {},
	release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.CUSTOM = 8;
cc.EventListener.FOCUS = 7;
cc._EventListenerCustom = cc.EventListener.extend({
	_onCustomEvent: null,
	ctor: function(a, b) {
		this._onCustomEvent = b;
		var c = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
			null !== c._onCustomEvent && c._onCustomEvent(a)
		})
	},
	checkAvailable: function() {
		return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
	},
	clone: function() {
		return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
	}
});
cc._EventListenerCustom.create = function(a, b) {
	return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({
	onMouseDown: null,
	onMouseUp: null,
	onMouseMove: null,
	onMouseScroll: null,
	ctor: function() {
		var a = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(b) {
			var c = cc.EventMouse;
			switch (b._eventType) {
			case c.DOWN:
				if (a.onMouseDown) a.onMouseDown(b);
				break;
			case c.UP:
				if (a.onMouseUp) a.onMouseUp(b);
				break;
			case c.MOVE:
				if (a.onMouseMove) a.onMouseMove(b);
				break;
			case c.SCROLL:
				if (a.onMouseScroll) a.onMouseScroll(b)
			}
		})
	},
	clone: function() {
		var a = new cc._EventListenerMouse;
		a.onMouseDown = this.onMouseDown;
		a.onMouseUp = this.onMouseUp;
		a.onMouseMove = this.onMouseMove;
		a.onMouseScroll = this.onMouseScroll;
		return a
	},
	checkAvailable: function() {
		return !0
	}
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
	return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
	_claimedTouches: null,
	swallowTouches: !1,
	onTouchBegan: null,
	onTouchMoved: null,
	onTouchEnded: null,
	onTouchCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
		this._claimedTouches = []
	},
	setSwallowTouches: function(a) {
		this.swallowTouches = a
	},
	isSwallowTouches: function() {
		return this.swallowTouches
	},
	clone: function() {
		var a = new cc._EventListenerTouchOneByOne;
		a.onTouchBegan = this.onTouchBegan;
		a.onTouchMoved = this.onTouchMoved;
		a.onTouchEnded = this.onTouchEnded;
		a.onTouchCancelled = this.onTouchCancelled;
		a.swallowTouches = this.swallowTouches;
		return a
	},
	checkAvailable: function() {
		return !this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
	}
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
	return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
	onTouchesBegan: null,
	onTouchesMoved: null,
	onTouchesEnded: null,
	onTouchesCancelled: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
	},
	clone: function() {
		var a = new cc._EventListenerTouchAllAtOnce;
		a.onTouchesBegan = this.onTouchesBegan;
		a.onTouchesMoved = this.onTouchesMoved;
		a.onTouchesEnded = this.onTouchesEnded;
		a.onTouchesCancelled = this.onTouchesCancelled;
		return a
	},
	checkAvailable: function() {
		return null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
	}
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
	return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
	cc.assert(a && a.event, cc._LogInfos.EventListener_create);
	var b = a.event;
	delete a.event;
	var c = null;
	b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard : b === cc.EventListener.ACCELERATION ? (c = new cc._EventListenerAcceleration(a.callback), delete a.callback) : b === cc.EventListener.FOCUS && (c = new cc._EventListenerFocus);
	for (var d in a) c[d] = a[d];
	return c
};
cc._EventListenerFocus = cc.EventListener.extend({
	clone: function() {
		var a = new cc._EventListenerFocus;
		a.onFocusChanged = this.onFocusChanged;
		return a
	},
	checkAvailable: function() {
		return !this.onFocusChanged ? (cc.log("Invalid EventListenerFocus!"), !1) : !0
	},
	onFocusChanged: null,
	ctor: function() {
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function(a) {
			if (this.onFocusChanged) this.onFocusChanged(a._widgetLoseFocus, a._widgetGetFocus)
		})
	}
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
	_fixedListeners: null,
	_sceneGraphListeners: null,
	gt0Index: 0,
	ctor: function() {
		this._fixedListeners = [];
		this._sceneGraphListeners = []
	},
	size: function() {
		return this._fixedListeners.length + this._sceneGraphListeners.length
	},
	empty: function() {
		return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
	},
	push: function(a) {
		0 === a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
	},
	clearSceneGraphListeners: function() {
		this._sceneGraphListeners.length = 0
	},
	clearFixedListeners: function() {
		this._fixedListeners.length = 0
	},
	clear: function() {
		this._sceneGraphListeners.length = 0;
		this._fixedListeners.length = 0
	},
	getFixedPriorityListeners: function() {
		return this._fixedListeners
	},
	getSceneGraphPriorityListeners: function() {
		return this._sceneGraphListeners
	}
});
cc.__getListenerID = function(a) {
	var b = cc.Event,
		c = a.getType();
	if (c === b.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
	if (c === b.CUSTOM) return a.getEventName();
	if (c === b.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
	if (c === b.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
	if (c === b.FOCUS) return cc._EventListenerFocus.LISTENER_ID;
	c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
	return ""
};
cc.eventManager = {
	DIRTY_NONE: 0,
	DIRTY_FIXED_PRIORITY: 1,
	DIRTY_SCENE_GRAPH_PRIORITY: 2,
	DIRTY_ALL: 3,
	_listenersMap: {},
	_priorityDirtyFlagMap: {},
	_nodeListenersMap: {},
	_nodePriorityMap: {},
	_globalZOrderNodeMap: {},
	_toAddedListeners: [],
	_dirtyNodes: [],
	_inDispatch: 0,
	_isEnabled: !1,
	_nodePriorityIndex: 0,
	_internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
	_setDirtyForNode: function(a) {
		null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
		a = a.getChildren();
		for (var b = 0, c = a.length; b < c; b++) this._setDirtyForNode(a[b])
	},
	pauseTarget: function(a, b) {
		var c = this._nodeListenersMap[a.__instanceId],
			d, e;
		if (c) {
			d = 0;
			for (e = c.length; d < e; d++) c[d]._setPaused(!0)
		}
		if (!0 === b) {
			c = a.getChildren();
			d = 0;
			for (e = c.length; d < e; d++) this.pauseTarget(c[d], !0)
		}
	},
	resumeTarget: function(a, b) {
		var c = this._nodeListenersMap[a.__instanceId],
			d, e;
		if (c) {
			d = 0;
			for (e = c.length; d < e; d++) c[d]._setPaused(!1)
		}
		this._setDirtyForNode(a);
		if (!0 === b) {
			c = a.getChildren();
			d = 0;
			for (e = c.length; d < e; d++) this.resumeTarget(c[d], !0)
		}
	},
	_addListener: function(a) {
		0 === this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
	},
	_forceAddEventListener: function(a) {
		var b = a._getListenerID(),
			c = this._listenersMap[b];
		c || (c = new cc._EventListenerVector, this._listenersMap[b] = c);
		c.push(a);
		0 === a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null === b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
	},
	_getListeners: function(a) {
		return this._listenersMap[a]
	},
	_updateDirtyFlagForSceneGraph: function() {
		if (0 !== this._dirtyNodes.length) {
			for (var a = this._dirtyNodes, b, c, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)
			if (b = d[a[e].__instanceId]) for (var k = 0, m = b.length; k < m; k++)(c = b[k]) && this._setDirty(c._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
			this._dirtyNodes.length = 0
		}
	},
	_removeAllListenersInVector: function(a) {
		if (a) for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(), b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
	},
	_removeListenersForListenerID: function(a) {
		var b = this._listenersMap[a];
		if (b) {
			var c = b.getFixedPriorityListeners(),
				d = b.getSceneGraphPriorityListeners();
			this._removeAllListenersInVector(d);
			this._removeAllListenersInVector(c);
			delete this._priorityDirtyFlagMap[a];
			this._inDispatch || (b.clear(), delete this._listenersMap[a])
		}
		c = this._toAddedListeners;
		for (b = 0; b < c.length;)(d = c[b]) && d._getListenerID() === a ? cc.arrayRemoveObject(c, d) : ++b
	},
	_sortEventListeners: function(a) {
		var b = this.DIRTY_NONE,
			c = this._priorityDirtyFlagMap;
		c[a] && (b = c[a]);
		b !== this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
	},
	_sortListenersOfSceneGraphPriority: function(a, b) {
		var c = this._getListeners(a);
		if (c) {
			var d = c.getSceneGraphPriorityListeners();
			d && 0 !== d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
		}
	},
	_sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
		var c = cc.eventManager._nodePriorityMap,
			d = a._getSceneGraphPriority(),
			e = b._getSceneGraphPriority();
		return !b || !e || !c[e.__instanceId] ? -1 : !a || !d || !c[d.__instanceId] ? 1 : c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId]
	},
	_sortListenersOfFixedPriority: function(a) {
		if (a = this._listenersMap[a]) {
			var b = a.getFixedPriorityListeners();
			if (b && 0 !== b.length) {
				b.sort(this._sortListenersOfFixedPriorityAsc);
				for (var c = 0, d = b.length; c < d && !(0 <= b[c]._getFixedPriority());)++c;
				a.gt0Index = c
			}
		}
	},
	_sortListenersOfFixedPriorityAsc: function(a, b) {
		return a._getFixedPriority() - b._getFixedPriority()
	},
	_onUpdateListeners: function(a) {
		if (a = this._listenersMap[a]) {
			var b = a.getFixedPriorityListeners(),
				c = a.getSceneGraphPriorityListeners(),
				d, e;
			if (c) for (d = 0; d < c.length;) e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c, e);
			if (b) for (d = 0; d < b.length;) e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b, e);
			c && 0 === c.length && a.clearSceneGraphListeners();
			b && 0 === b.length && a.clearFixedListeners()
		}
	},
	_updateListeners: function(a) {
		var b = this._inDispatch;
		cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
		if (!(1 < b)) {
			a.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
			cc.assert(1 === b, cc._LogInfos.EventManager__updateListeners_2);
			a = this._listenersMap;
			var b = this._priorityDirtyFlagMap,
				c;
			for (c in a) a[c].empty() && (delete b[c], delete a[c]);
			c = this._toAddedListeners;
			if (0 !== c.length) {
				a = 0;
				for (b = c.length; a < b; a++) this._forceAddEventListener(c[a]);
				this._toAddedListeners.length = 0
			}
		}
	},
	_onTouchEventCallback: function(a, b) {
		if (!a._isRegistered) return !1;
		var c = b.event,
			d = b.selTouch;
		c._setCurrentTarget(a._node);
		var e = !1,
			f, k = c.getEventCode(),
			m = cc.EventTouch.EventCode;
		if (k === m.BEGAN) a.onTouchBegan && (e = a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d);
		else if (0 < a._claimedTouches.length && -1 !== (f = a._claimedTouches.indexOf(d))) if (e = !0, k === m.MOVED && a.onTouchMoved) a.onTouchMoved(d, c);
		else if (k === m.ENDED) {
			if (a.onTouchEnded) a.onTouchEnded(d, c);
			a._registered && a._claimedTouches.splice(f, 1)
		} else if (k === m.CANCELLED) {
			if (a.onTouchCancelled) a.onTouchCancelled(d, c);
			a._registered && a._claimedTouches.splice(f, 1)
		}
		return c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : e && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
	},
	_dispatchTouchEvent: function(a) {
		this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
		this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
			c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
		if (!(null === b && null === c)) {
			var d = a.getTouches(),
				e = cc.copyArray(d),
				f = {
					event: a,
					needsMutableSet: b && c,
					touches: e,
					selTouch: null
				};
			if (b) for (var k = 0; k < d.length; k++)
			if (f.selTouch = d[k], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
			if (c && 0 < e.length && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
				event: a,
				touches: e
			}), a.isStopped())) return;
			this._updateListeners(a)
		}
	},
	_onTouchesEventCallback: function(a, b) {
		if (!a._registered) return !1;
		var c = cc.EventTouch.EventCode,
			d = b.event,
			e = b.touches,
			f = d.getEventCode();
		d._setCurrentTarget(a._node);
		if (f === c.BEGAN && a.onTouchesBegan) a.onTouchesBegan(e, d);
		else if (f === c.MOVED && a.onTouchesMoved) a.onTouchesMoved(e, d);
		else if (f === c.ENDED && a.onTouchesEnded) a.onTouchesEnded(e, d);
		else if (f === c.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(e, d);
		return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
	},
	_associateNodeAndEventListener: function(a, b) {
		var c = this._nodeListenersMap[a.__instanceId];
		c || (c = [], this._nodeListenersMap[a.__instanceId] = c);
		c.push(b)
	},
	_dissociateNodeAndEventListener: function(a, b) {
		var c = this._nodeListenersMap[a.__instanceId];
		c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
	},
	_dispatchEventToListeners: function(a, b, c) {
		var d = !1,
			e = a.getFixedPriorityListeners(),
			f = a.getSceneGraphPriorityListeners(),
			k = 0,
			m;
		if (e && 0 !== e.length) for (; k < a.gt0Index; ++k)
		if (m = e[k], m.isEnabled() && !m._isPaused() && m._isRegistered() && b(m, c)) {
			d = !0;
			break
		}
		if (f && !d) for (a = 0; a < f.length; a++)
		if (m = f[a], m.isEnabled() && !m._isPaused() && m._isRegistered() && b(m, c)) {
			d = !0;
			break
		}
		if (e && !d) for (; k < e.length && !(m = e[k], m.isEnabled() && !m._isPaused() && m._isRegistered() && b(m, c)); ++k);
	},
	_setDirty: function(a, b) {
		var c = this._priorityDirtyFlagMap;
		c[a] = null == c[a] ? b : b | c[a]
	},
	_visitTarget: function(a, b) {
		var c = a.getChildren(),
			d = 0,
			e = c.length,
			f = this._globalZOrderNodeMap,
			k = this._nodeListenersMap;
		if (0 < e) {
			for (var m; d < e; d++)
			if ((m = c[d]) && 0 > m.getLocalZOrder()) this._visitTarget(m, !1);
			else break;
			null != k[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
			for (; d < e; d++)(m = c[d]) && this._visitTarget(m, !1)
		} else null != k[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
		if (b) {
			var c = [],
				n;
			for (n in f) c.push(n);
			c.sort(this._sortNumberAsc);
			n = c.length;
			m = this._nodePriorityMap;
			for (d = 0; d < n; d++) {
				e = f[c[d]];
				for (k = 0; k < e.length; k++) m[e[k]] = ++this._nodePriorityIndex
			}
			this._globalZOrderNodeMap = {}
		}
	},
	_sortNumberAsc: function(a, b) {
		return a - b
	},
	addListener: function(a, b) {
		cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
		if (a instanceof cc.EventListener) {
			if (a._isRegistered()) {
				cc.log(cc._LogInfos.eventManager_addListener_4);
				return
			}
		} else cc.assert(!cc.isNumber(b), cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
		if (a.checkAvailable()) {
			if (cc.isNumber(b)) {
				if (0 === b) {
					cc.log(cc._LogInfos.eventManager_addListener);
					return
				}
				a._setSceneGraphPriority(null);
				a._setFixedPriority(b);
				a._setRegistered(!0);
				a._setPaused(!1)
			} else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0);
			this._addListener(a);
			return a
		}
	},
	addCustomListener: function(a, b) {
		var c = new cc._EventListenerCustom(a, b);
		this.addListener(c, 1);
		return c
	},
	removeListener: function(a) {
		if (null != a) {
			var b, c = this._listenersMap,
				d;
			for (d in c) {
				var e = c[d],
					f = e.getFixedPriorityListeners();
				b = e.getSceneGraphPriorityListeners();
				(b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
				e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]);
				if (b) break
			}
			if (!b) {
				c = this._toAddedListeners;
				d = 0;
				for (e = c.length; d < e; d++)
				if (f = c[d], f === a) {
					cc.arrayRemoveObject(c, f);
					f._setRegistered(!1);
					break
				}
			}
		}
	},
	_removeListenerInCallback: function(a, b) {
		if (null == a) return !1;
		for (var c = 0, d = a.length; c < d; c++) {
			var e = a[c];
			if (e._onCustomEvent === b || e._onEvent === b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
		}
		return !1
	},
	_removeListenerInVector: function(a, b) {
		if (null == a) return !1;
		for (var c = 0, d = a.length; c < d; c++) {
			var e = a[c];
			if (e === b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
		}
		return !1
	},
	removeListeners: function(a, b) {
		if (a instanceof cc.Node) {
			delete this._nodePriorityMap[a.__instanceId];
			cc.arrayRemoveObject(this._dirtyNodes, a);
			var c = this._nodeListenersMap[a.__instanceId];
			if (c) {
				for (var d = cc.copyArray(c), c = 0; c < d.length; c++) this.removeListener(d[c]);
				d.length = 0
			}
			d = this._toAddedListeners;
			for (c = 0; c < d.length;) {
				var e = d[c];
				e._getSceneGraphPriority() === a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(c, 1)) : ++c
			}
			if (!0 === b) {
				d = a.getChildren();
				c = 0;
				for (e = d.length; c < e; c++) this.removeListeners(d[c], !0)
			}
		} else a === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
	},
	removeCustomListeners: function(a) {
		this._removeListenersForListenerID(a)
	},
	removeAllListeners: function() {
		var a = this._listenersMap,
			b = this._internalCustomListenerIDs,
			c;
		for (c in a) - 1 === b.indexOf(c) && this._removeListenersForListenerID(c)
	},
	setPriority: function(a, b) {
		if (null != a) {
			var c = this._listenersMap,
				d;
			for (d in c) {
				var e = c[d].getFixedPriorityListeners();
				if (e && -1 !== e.indexOf(a)) {
					null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
					a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
					break
				}
			}
		}
	},
	setEnabled: function(a) {
		this._isEnabled = a
	},
	isEnabled: function() {
		return this._isEnabled
	},
	dispatchEvent: function(a) {
		if (this._isEnabled) {
			this._updateDirtyFlagForSceneGraph();
			this._inDispatch++;
			if (!a || !a.getType) throw Error("event is undefined");
			if (a.getType() === cc.Event.TOUCH) this._dispatchTouchEvent(a);
			else {
				var b = cc.__getListenerID(a);
				this._sortEventListeners(b);
				b = this._listenersMap[b];
				null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
				this._updateListeners(a)
			}
			this._inDispatch--
		}
	},
	_onListenerCallback: function(a, b) {
		b._setCurrentTarget(a._getSceneGraphPriority());
		a._onEvent(b);
		return b.isStopped()
	},
	dispatchCustomEvent: function(a, b) {
		var c = new cc.EventCustom(a);
		c.setUserData(b);
		this.dispatchEvent(c)
	}
};
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
	constructor: cc.EventHelper,
	apply: function(a) {
		a.addEventListener = cc.EventHelper.prototype.addEventListener;
		a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
		a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
		a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
	},
	addEventListener: function(a, b, c) {
		if ("load" === a && this._textureLoaded) setTimeout(function() {
			b.call(c)
		}, 0);
		else {
			void 0 === this._listeners && (this._listeners = {});
			var d = this._listeners;
			void 0 === d[a] && (d[a] = []);
			this.hasEventListener(a, b, c) || d[a].push({
				callback: b,
				eventTarget: c
			})
		}
	},
	hasEventListener: function(a, b, c) {
		if (void 0 === this._listeners) return !1;
		var d = this._listeners;
		if (void 0 !== d[a]) {
			a = 0;
			for (var e = d.length; a < e; a++) {
				var f = d[a];
				if (f.callback === b && f.eventTarget === c) return !0
			}
		}
		return !1
	},
	removeEventListener: function(a, b) {
		if (void 0 !== this._listeners) {
			var c = this._listeners[a];
			if (void 0 !== c) for (var d = 0; d < c.length;) c[d].eventTarget === b ? c.splice(d, 1) : d++
		}
	},
	dispatchEvent: function(a, b) {
		if (void 0 !== this._listeners) {
			null == b && (b = !0);
			var c = this._listeners[a];
			if (void 0 !== c) {
				for (var d = [], e = c.length, f = 0; f < e; f++) d[f] = c[f];
				for (f = 0; f < e; f++) d[f].callback.call(d[f].eventTarget, this);
				b && (c.length = 0)
			}
		}
	}
};
cc.EventAcceleration = cc.Event.extend({
	_acc: null,
	ctor: function(a) {
		cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
		this._acc = a
	}
});
cc.EventKeyboard = cc.Event.extend({
	_keyCode: 0,
	_isPressed: !1,
	ctor: function(a, b) {
		cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
		this._keyCode = a;
		this._isPressed = b
	}
});
cc._EventListenerAcceleration = cc.EventListener.extend({
	_onAccelerationEvent: null,
	ctor: function(a) {
		this._onAccelerationEvent = a;
		var b = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
			b._onAccelerationEvent(a._acc, a)
		})
	},
	checkAvailable: function() {
		cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
		return !0
	},
	clone: function() {
		return new cc._EventListenerAcceleration(this._onAccelerationEvent)
	}
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
	return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
	onKeyPressed: null,
	onKeyReleased: null,
	ctor: function() {
		var a = this;
		cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(b) {
			if (b._isPressed) {
				if (a.onKeyPressed) a.onKeyPressed(b._keyCode, b)
			} else if (a.onKeyReleased) a.onKeyReleased(b._keyCode, b)
		})
	},
	clone: function() {
		var a = new cc._EventListenerKeyboard;
		a.onKeyPressed = this.onKeyPressed;
		a.onKeyReleased = this.onKeyReleased;
		return a
	},
	checkAvailable: function() {
		return null === this.onKeyPressed && null === this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
	}
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
	return new cc._EventListenerKeyboard
};
cc.rendererCanvas = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToCanvasOn: !1,
	_cacheToCanvasCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	_clearColor: cc.color(),
	_clearFillStyle: "rgb(0, 0, 0)",
	getRenderCmd: function(a) {
		return a._createRenderCmd()
	},
	rendering: function(a) {
		var b = this._renderCmds,
			c, d = cc.view.getScaleX(),
			e = cc.view.getScaleY(),
			f = a || cc._renderContext;
		f.computeRealOffsetY();
		a = 0;
		for (c = b.length; a < c; a++) b[a].rendering(f, d, e)
	},
	_renderingToCacheCanvas: function(a, b, c, d) {
		a || cc.log("The context of RenderTexture is invalid.");
		c = cc.isUndefined(c) ? 1 : c;
		d = cc.isUndefined(d) ? 1 : d;
		b = b || this._currentID;
		var e = this._cacheToCanvasCmds[b],
			f, k;
		a.computeRealOffsetY();
		f = 0;
		for (k = e.length; f < k; f++) e[f].rendering(a, c, d);
		e.length = 0;
		a = this._cacheInstanceIds;
		delete this._cacheToCanvasCmds[b];
		cc.arrayRemoveObject(a, b);
		0 === a.length ? this._isCacheToCanvasOn = !1 : this._currentID = a[a.length - 1]
	},
	_turnToCacheMode: function(a) {
		this._isCacheToCanvasOn = !0;
		a = a || 0;
		this._cacheToCanvasCmds[a] = []; - 1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a);
		this._currentID = a
	},
	_turnToNormalMode: function() {
		this._isCacheToCanvasOn = !1
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var a = this._transformNodePool;
		a.sort(this._sortNodeByLevelAsc);
		for (var b = 0, c = a.length; b < c; b++) 0 !== a[b]._dirtyFlag && a[b].updateStatus();
		a.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(a, b) {
		return a._curLevel - b._curLevel
	},
	pushDirtyNode: function(a) {
		this._transformNodePool.push(a)
	},
	clear: function() {
		var a = cc._canvas,
			b = cc._renderContext.getContext(),
			c = cc._renderContext;
		b.setTransform(1, 0, 0, 1, 0, 0);
		255 !== this._clearColor.a && b.clearRect(0, 0, a.width, a.height);
		c.setFillStyle(this._clearFillStyle);
		c.setGlobalAlpha(this._clearColor.a);
		b.fillRect(0, 0, a.width, a.height)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	pushRenderCommand: function(a) {
		if (a._needDraw) if (this._isCacheToCanvasOn) {
			var b = this._cacheToCanvasCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
		} else - 1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.renderer = cc.rendererCanvas);
(function() {
	cc.CanvasContextWrapper = function(a) {
		this._context = a;
		this._saveCount = 0;
		this._currentAlpha = a.globalAlpha;
		this._currentCompositeOperation = a.globalCompositeOperation;
		this._currentFillStyle = a.fillStyle;
		this._currentStrokeStyle = a.strokeStyle;
		this._offsetY = this._offsetX = 0;
		this._realOffsetY = this.height;
		this._armatureMode = 0
	};
	var a = cc.CanvasContextWrapper.prototype;
	a.resetCache = function() {
		var a = this._context;
		this._currentAlpha = a.globalAlpha;
		this._currentCompositeOperation = a.globalCompositeOperation;
		this._currentFillStyle = a.fillStyle;
		this._currentStrokeStyle = a.strokeStyle;
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.setOffset = function(a, c) {
		this._offsetX = a;
		this._offsetY = c;
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.computeRealOffsetY = function() {
		this._realOffsetY = this._context.canvas.height + this._offsetY
	};
	a.setViewScale = function(a, c) {
		this._scaleX = a;
		this._scaleY = c
	};
	a.getContext = function() {
		return this._context
	};
	a.save = function() {
		this._context.save();
		this._saveCount++
	};
	a.restore = function() {
		this._context.restore();
		this._saveCount--
	};
	a.setGlobalAlpha = function(a) {
		0 < this._saveCount ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
	};
	a.setCompositeOperation = function(a) {
		0 < this._saveCount ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
	};
	a.setFillStyle = function(a) {
		0 < this._saveCount ? this._context.fillStyle = a : this._currentFillStyle !== a && (this._currentFillStyle = a, this._context.fillStyle = a)
	};
	a.setStrokeStyle = function(a) {
		0 < this._saveCount ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
	};
	a.setTransform = function(a, c, d) {
		0 < this._armatureMode ? (this.restore(), this.save(), this._context.transform(a.a, -a.b, -a.c, a.d, a.tx * c, -(a.ty * d))) : this._context.setTransform(a.a, -a.b, -a.c, a.d, this._offsetX + a.tx * c, this._realOffsetY - a.ty * d)
	};
	a._switchToArmatureMode = function(a, c, d, e) {
		a ? (this._armatureMode++, this._context.setTransform(c.a, c.c, c.b, c.d, this._offsetX + c.tx * d, this._realOffsetY - c.ty * e), this.save()) : (this._armatureMode--, this.restore())
	}
})();
cc.rendererWebGL = {
	childrenOrderDirty: !0,
	_transformNodePool: [],
	_renderCmds: [],
	_isCacheToBufferOn: !1,
	_cacheToBufferCmds: {},
	_cacheInstanceIds: [],
	_currentID: 0,
	_clearColor: cc.color(),
	getRenderCmd: function(a) {
		return a._createRenderCmd()
	},
	rendering: function(a) {
		var b = this._renderCmds,
			c, d = a || cc._renderContext;
		a = 0;
		for (c = b.length; a < c; a++) b[a].rendering(d)
	},
	_turnToCacheMode: function(a) {
		this._isCacheToBufferOn = !0;
		a = a || 0;
		this._cacheToBufferCmds[a] = [];
		this._cacheInstanceIds.push(a);
		this._currentID = a
	},
	_turnToNormalMode: function() {
		this._isCacheToBufferOn = !1
	},
	_renderingToBuffer: function(a) {
		a = a || this._currentID;
		var b = this._cacheToBufferCmds[a],
			c, d, e = cc._renderContext,
			f = this._cacheInstanceIds;
		c = 0;
		for (d = b.length; c < d; c++) b[c].rendering(e);
		b.length = 0;
		delete this._cacheToBufferCmds[a];
		cc.arrayRemoveObject(f, a);
		0 === f.length ? this._isCacheToBufferOn = !1 : this._currentID = f[f.length - 1]
	},
	resetFlag: function() {
		this.childrenOrderDirty = !1;
		this._transformNodePool.length = 0
	},
	transform: function() {
		var a = this._transformNodePool;
		a.sort(this._sortNodeByLevelAsc);
		for (var b = 0, c = a.length; b < c; b++) a[b].updateStatus();
		a.length = 0
	},
	transformDirty: function() {
		return 0 < this._transformNodePool.length
	},
	_sortNodeByLevelAsc: function(a, b) {
		return a._curLevel - b._curLevel
	},
	pushDirtyNode: function(a) {
		this._transformNodePool.push(a)
	},
	clearRenderCommands: function() {
		this._renderCmds.length = 0
	},
	clear: function() {
		var a = cc._renderContext;
		a.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
		a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT);
		0 === this._clearColor.a && a.blendFunc(a.SRC_ALPHA, a.DST_ALPHA)
	},
	pushRenderCommand: function(a) {
		if (a._needDraw) if (this._isCacheToBufferOn) {
			var b = this._cacheToBufferCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
		} else - 1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
	}
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.renderer = cc.rendererWebGL);
cc._tmp.PrototypeCCNode = function() {
	var a = cc.Node.prototype;
	cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
	cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
	cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
	cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
	cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
	cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
	cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
	cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY);
	cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
	cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
	cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
	cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
	cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
	cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
	cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
	cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.setScaleY);
	cc.defineGetterSetter(a, "children", a.getChildren);
	cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
	cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
	cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
	cc.defineGetterSetter(a, "running", a.isRunning);
	cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
	cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
	cc.defineGetterSetter(a, "scheduler", a.getScheduler, a.setScheduler);
	cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
	cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
	_localZOrder: 0,
	_globalZOrder: 0,
	_vertexZ: 0,
	_rotationX: 0,
	_rotationY: 0,
	_scaleX: 1,
	_scaleY: 1,
	_position: null,
	_normalizedPosition: null,
	_usingNormalizedPosition: !1,
	_normalizedPositionDirty: !1,
	_skewX: 0,
	_skewY: 0,
	_children: null,
	_visible: !0,
	_anchorPoint: null,
	_contentSize: null,
	_running: !1,
	_parent: null,
	_ignoreAnchorPointForPosition: !1,
	tag: cc.NODE_TAG_INVALID,
	userData: null,
	userObject: null,
	_reorderChildDirty: !1,
	_shaderProgram: null,
	arrivalOrder: 0,
	_actionManager: null,
	_scheduler: null,
	_eventDispatcher: null,
	_additionalTransformDirty: !1,
	_additionalTransform: null,
	_componentContainer: null,
	_isTransitionFinished: !1,
	_className: "Node",
	_showNode: !1,
	_name: "",
	_realOpacity: 255,
	_realColor: null,
	_cascadeColorEnabled: !1,
	_cascadeOpacityEnabled: !1,
	_renderCmd: null,
	_camera: null,
	ctor: function() {
		this._initNode();
		this._initRendererCmd()
	},
	_initNode: function() {
		this._anchorPoint = cc.p(0, 0);
		this._contentSize = cc.size(0, 0);
		this._position = cc.p(0, 0);
		this._normalizedPosition = cc.p(0, 0);
		this._children = [];
		var a = cc.director;
		this._actionManager = a.getActionManager();
		this._scheduler = a.getScheduler();
		this._additionalTransform = cc.affineTransformMakeIdentity();
		cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
		this._realOpacity = 255;
		this._realColor = cc.color(255, 255, 255, 255);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
	},
	init: function() {
		return !0
	},
	_arrayMakeObjectsPerformSelector: function(a, b) {
		if (a && 0 !== a.length) {
			var c, d = a.length,
				e;
			c = cc.Node._stateCallbackType;
			switch (b) {
			case c.onEnter:
				for (c = 0; c < d; c++)
				if (e = a[c]) e.onEnter();
				break;
			case c.onExit:
				for (c = 0; c < d; c++)
				if (e = a[c]) e.onExit();
				break;
			case c.onEnterTransitionDidFinish:
				for (c = 0; c < d; c++)
				if (e = a[c]) e.onEnterTransitionDidFinish();
				break;
			case c.cleanup:
				for (c = 0; c < d; c++)(e = a[c]) && e.cleanup();
				break;
			case c.updateTransform:
				for (c = 0; c < d; c++)(e = a[c]) && e.updateTransform();
				break;
			case c.onExitTransitionDidStart:
				for (c = 0; c < d; c++)
				if (e = a[c]) e.onExitTransitionDidStart();
				break;
			case c.sortAllChildren:
				for (c = 0; c < d; c++)(e = a[c]) && e.sortAllChildren();
				break;
			default:
				cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
			}
		}
	},
	attr: function(a) {
		for (var b in a) this[b] = a[b]
	},
	getSkewX: function() {
		return this._skewX
	},
	setSkewX: function(a) {
		this._skewX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getSkewY: function() {
		return this._skewY
	},
	setSkewY: function(a) {
		this._skewY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setLocalZOrder: function(a) {
		this._localZOrder = a;
		this._parent && this._parent.reorderChild(this, a);
		cc.eventManager._setDirtyForNode(this)
	},
	_setLocalZOrder: function(a) {
		this._localZOrder = a
	},
	getLocalZOrder: function() {
		return this._localZOrder
	},
	getZOrder: function() {
		cc.log(cc._LogInfos.Node_getZOrder);
		return this.getLocalZOrder()
	},
	setZOrder: function(a) {
		cc.log(cc._LogInfos.Node_setZOrder);
		this.setLocalZOrder(a)
	},
	setGlobalZOrder: function(a) {
		this._globalZOrder !== a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
	},
	getGlobalZOrder: function() {
		return this._globalZOrder
	},
	getVertexZ: function() {
		return this._vertexZ
	},
	setVertexZ: function(a) {
		this._vertexZ = a
	},
	getRotation: function() {
		this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
		return this._rotationX
	},
	setRotation: function(a) {
		this._rotationX = this._rotationY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationX: function() {
		return this._rotationX
	},
	setRotationX: function(a) {
		this._rotationX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getRotationY: function() {
		return this._rotationY
	},
	setRotationY: function(a) {
		this._rotationY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScale: function() {
		this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
		return this._scaleX
	},
	setScale: function(a, b) {
		this._scaleX = a;
		this._scaleY = b || 0 === b ? b : a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleX: function() {
		return this._scaleX
	},
	setScaleX: function(a) {
		this._scaleX = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getScaleY: function() {
		return this._scaleY
	},
	setScaleY: function(a) {
		this._scaleY = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setPosition: function(a, b) {
		var c = this._position;
		if (void 0 === b) {
			if (c.x === a.x && c.y === a.y) return;
			c.x = a.x;
			c.y = a.y
		} else {
			if (c.x === a && c.y === b) return;
			c.x = a;
			c.y = b
		}
		this._usingNormalizedPosition = !1;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setNormalizedPosition: function(a, b) {
		var c = this._normalizedPosition;
		void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
		this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPosition: function() {
		return cc.p(this._position)
	},
	getNormalizedPosition: function() {
		return cc.p(this._normalizedPosition)
	},
	getPositionX: function() {
		return this._position.x
	},
	setPositionX: function(a) {
		this._position.x = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getPositionY: function() {
		return this._position.y
	},
	setPositionY: function(a) {
		this._position.y = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	getChildrenCount: function() {
		return this._children.length
	},
	getChildren: function() {
		return this._children
	},
	isVisible: function() {
		return this._visible
	},
	setVisible: function(a) {
		this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
	},
	getAnchorPoint: function() {
		return cc.p(this._anchorPoint)
	},
	setAnchorPoint: function(a, b) {
		var c = this._anchorPoint;
		if (void 0 === b) {
			if (a.x === c.x && a.y === c.y) return;
			c.x = a.x;
			c.y = a.y
		} else {
			if (a === c.x && b === c.y) return;
			c.x = a;
			c.y = b
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getAnchorX: function() {
		return this._anchorPoint.x
	},
	_setAnchorX: function(a) {
		this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
	},
	_getAnchorY: function() {
		return this._anchorPoint.y
	},
	_setAnchorY: function(a) {
		this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
	},
	getAnchorPointInPoints: function() {
		return this._renderCmd.getAnchorPointInPoints()
	},
	_getWidth: function() {
		return this._contentSize.width
	},
	_setWidth: function(a) {
		this._contentSize.width = a;
		this._renderCmd._updateAnchorPointInPoint()
	},
	_getHeight: function() {
		return this._contentSize.height
	},
	_setHeight: function(a) {
		this._contentSize.height = a;
		this._renderCmd._updateAnchorPointInPoint()
	},
	getContentSize: function() {
		return cc.size(this._contentSize)
	},
	setContentSize: function(a, b) {
		var c = this._contentSize;
		if (void 0 === b) {
			if (a.width === c.width && a.height === c.height) return;
			c.width = a.width;
			c.height = a.height
		} else {
			if (a === c.width && b === c.height) return;
			c.width = a;
			c.height = b
		}
		this._renderCmd._updateAnchorPointInPoint()
	},
	isRunning: function() {
		return this._running
	},
	getParent: function() {
		return this._parent
	},
	setParent: function(a) {
		this._parent = a
	},
	isIgnoreAnchorPointForPosition: function() {
		return this._ignoreAnchorPointForPosition
	},
	ignoreAnchorPointForPosition: function(a) {
		a !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(a) {
		this.tag = a
	},
	setName: function(a) {
		this._name = a
	},
	getName: function() {
		return this._name
	},
	getUserData: function() {
		return this.userData
	},
	setUserData: function(a) {
		this.userData = a
	},
	getUserObject: function() {
		return this.userObject
	},
	setUserObject: function(a) {
		this.userObject !== a && (this.userObject = a)
	},
	getOrderOfArrival: function() {
		return this.arrivalOrder
	},
	setOrderOfArrival: function(a) {
		this.arrivalOrder = a
	},
	getActionManager: function() {
		this._actionManager || (this._actionManager = cc.director.getActionManager());
		return this._actionManager
	},
	setActionManager: function(a) {
		this._actionManager !== a && (this.stopAllActions(), this._actionManager = a)
	},
	getScheduler: function() {
		this._scheduler || (this._scheduler = cc.director.getScheduler());
		return this._scheduler
	},
	setScheduler: function(a) {
		this._scheduler !== a && (this.unscheduleAllCallbacks(), this._scheduler = a)
	},
	boundingBox: function() {
		cc.log(cc._LogInfos.Node_boundingBox);
		return this.getBoundingBox()
	},
	getBoundingBox: function() {
		var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
	},
	cleanup: function() {
		this.stopAllActions();
		this.unscheduleAllCallbacks();
		cc.eventManager.removeListeners(this);
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup)
	},
	getChildByTag: function(a) {
		var b = this._children;
		if (null !== b) for (var c = 0; c < b.length; c++) {
			var d = b[c];
			if (d && d.tag === a) return d
		}
		return null
	},
	getChildByName: function(a) {
		if (!a) return cc.log("Invalid name"), null;
		for (var b = this._children, c = 0, d = b.length; c < d; c++)
		if (b[c]._name === a) return b[c];
		return null
	},
	addChild: function(a, b, c) {
		b = void 0 === b ? a._localZOrder : b;
		var d, e = !1;
		cc.isUndefined(c) ? (c = void 0, d = a._name) : cc.isString(c) ? (d = c, c = void 0) : cc.isNumber(c) && (e = !0, d = "");
		cc.assert(a, cc._LogInfos.Node_addChild_3);
		cc.assert(null === a._parent, "child already added. It can't be added again");
		this._addChildHelper(a, b, c, d, e)
	},
	_addChildHelper: function(a, b, c, d, e) {
		this._children || (this._children = []);
		this._insertChild(a, b);
		e ? a.setTag(c) : a.setName(d);
		a.setParent(this);
		a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
		if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
		this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	removeFromParent: function(a) {
		this._parent && (void 0 === a && (a = !0), this._parent.removeChild(this, a))
	},
	removeFromParentAndCleanup: function(a) {
		cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
		this.removeFromParent(a)
	},
	removeChild: function(a, b) {
		0 !== this._children.length && (void 0 === b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), cc.renderer.childrenOrderDirty = !0)
	},
	removeChildByTag: function(a, b) {
		a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
		var c = this.getChildByTag(a);
		c ? this.removeChild(c, b) : cc.log(cc._LogInfos.Node_removeChildByTag_2, a)
	},
	removeAllChildrenWithCleanup: function(a) {
		this.removeAllChildren(a)
	},
	removeAllChildren: function(a) {
		var b = this._children;
		if (null !== b) {
			void 0 === a && (a = !0);
			for (var c = 0; c < b.length; c++) {
				var d = b[c];
				d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null, d._renderCmd.detachFromParent())
			}
			this._children.length = 0;
			cc.renderer.childrenOrderDirty = !0
		}
	},
	_detachChild: function(a, b) {
		this._running && (a.onExitTransitionDidStart(), a.onExit());
		b && a.cleanup();
		a.parent = null;
		a._renderCmd.detachFromParent();
		cc.arrayRemoveObject(this._children, a)
	},
	_insertChild: function(a, b) {
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		this._children.push(a);
		a._setLocalZOrder(b)
	},
	setNodeDirty: function() {
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	reorderChild: function(a, b) {
		cc.assert(a, cc._LogInfos.Node_reorderChild);
		cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
		a.arrivalOrder = cc.s_globalOrderOfArrival;
		cc.s_globalOrderOfArrival++;
		a._setLocalZOrder(b)
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var a = this._children,
				b = a.length,
				c, d, e;
			for (c = 1; c < b; c++) {
				e = a[c];
				for (d = c - 1; 0 <= d;) {
					if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
					else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
					else break;
					d--
				}
				a[d + 1] = e
			}
			this._reorderChildDirty = !1
		}
	},
	draw: function(a) {},
	transformAncestors: function() {
		null !== this._parent && (this._parent.transformAncestors(), this._parent.transform())
	},
	onEnter: function() {
		this._isTransitionFinished = !1;
		this._running = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
		this.resume()
	},
	onEnterTransitionDidFinish: function() {
		this._isTransitionFinished = !0;
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
	},
	onExitTransitionDidStart: function() {
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart)
	},
	onExit: function() {
		this._running = !1;
		this.pause();
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
		this.removeAllComponents()
	},
	runAction: function(a) {
		cc.assert(a, cc._LogInfos.Node_runAction);
		this.actionManager.addAction(a, this, !this._running);
		return a
	},
	stopAllActions: function() {
		this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
	},
	stopAction: function(a) {
		this.actionManager.removeAction(a)
	},
	stopActionByTag: function(a) {
		a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
	},
	getActionByTag: function(a) {
		return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
	},
	getNumberOfRunningActions: function() {
		return this.actionManager.numberOfRunningActionsInTarget(this)
	},
	scheduleUpdate: function() {
		this.scheduleUpdateWithPriority(0)
	},
	scheduleUpdateWithPriority: function(a) {
		this.scheduler.scheduleUpdate(this, a, !this._running)
	},
	unscheduleUpdate: function() {
		this.scheduler.unscheduleUpdate(this)
	},
	schedule: function(a, b, c, d, e) {
		var f = arguments.length;
		"function" === typeof a ? 1 === f ? (b = 0, c = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : 2 === f ? "number" === typeof b ? (c = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : (e = b, b = 0, c = cc.REPEAT_FOREVER, d = 0) : 3 === f ? ("string" === typeof c ? (e = c, c = cc.REPEAT_FOREVER) : e = this.__instanceId, d = 0) : 4 === f && (e = this.__instanceId) : 1 === f ? (b = 0, c = cc.REPEAT_FOREVER, d = 0) : 2 === f && (c = cc.REPEAT_FOREVER, d = 0);
		cc.assert(a, cc._LogInfos.Node_schedule);
		cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
		c = null == c ? cc.REPEAT_FOREVER : c;
		this.scheduler.schedule(a, this, b || 0, c, d || 0, !this._running, e)
	},
	scheduleOnce: function(a, b, c) {
		void 0 === c && (c = this.__instanceId);
		this.schedule(a, 0, 0, b, c)
	},
	unschedule: function(a) {
		a && this.scheduler.unschedule(a, this)
	},
	unscheduleAllCallbacks: function() {
		this.scheduler.unscheduleAllForTarget(this)
	},
	resumeSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
		this.resume()
	},
	resume: function() {
		this.scheduler.resumeTarget(this);
		this.actionManager && this.actionManager.resumeTarget(this);
		cc.eventManager.resumeTarget(this)
	},
	pauseSchedulerAndActions: function() {
		cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
		this.pause()
	},
	pause: function() {
		this.scheduler.pauseTarget(this);
		this.actionManager && this.actionManager.pauseTarget(this);
		cc.eventManager.pauseTarget(this)
	},
	setAdditionalTransform: function(a) {
		if (void 0 === a) return this._additionalTransformDirty = !1;
		this._additionalTransform = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
		this._additionalTransformDirty = !0
	},
	getParentToNodeTransform: function() {
		this._renderCmd.getParentToNodeTransform()
	},
	parentToNodeTransform: function() {
		return this.getParentToNodeTransform()
	},
	getNodeToWorldTransform: function() {
		for (var a = this.getNodeToParentTransform(), b = this._parent; null !== b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
		return a
	},
	nodeToWorldTransform: function() {
		return this.getNodeToWorldTransform()
	},
	getWorldToNodeTransform: function() {
		return cc.affineTransformInvert(this.getNodeToWorldTransform())
	},
	worldToNodeTransform: function() {
		return this.getWorldToNodeTransform()
	},
	convertToNodeSpace: function(a) {
		return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
	},
	convertToWorldSpace: function(a) {
		a = a || cc.p(0, 0);
		return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
	},
	convertToNodeSpaceAR: function(a) {
		return cc.pSub(this.convertToNodeSpace(a), this._renderCmd.getAnchorPointInPoints())
	},
	convertToWorldSpaceAR: function(a) {
		a = a || cc.p(0, 0);
		a = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
		return this.convertToWorldSpace(a)
	},
	_convertToWindowSpace: function(a) {
		a = this.convertToWorldSpace(a);
		return cc.director.convertToUI(a)
	},
	convertTouchToNodeSpace: function(a) {
		a = a.getLocation();
		return this.convertToNodeSpace(a)
	},
	convertTouchToNodeSpaceAR: function(a) {
		a = cc.director.convertToGL(a.getLocation());
		return this.convertToNodeSpaceAR(a)
	},
	update: function(a) {
		this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
	},
	updateTransform: function() {
		this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform)
	},
	retain: function() {},
	release: function() {},
	getComponent: function(a) {
		return this._componentContainer ? this._componentContainer.getComponent(a) : null
	},
	addComponent: function(a) {
		this._componentContainer && this._componentContainer.add(a)
	},
	removeComponent: function(a) {
		return this._componentContainer ? this._componentContainer.remove(a) : !1
	},
	removeAllComponents: function() {
		this._componentContainer && this._componentContainer.removeAll()
	},
	grid: null,
	visit: function(a) {
		this._renderCmd.visit(a)
	},
	transform: function(a, b) {
		this._renderCmd.transform(a, b)
	},
	nodeToParentTransform: function() {
		return this.getNodeToParentTransform()
	},
	getNodeToParentTransform: function(a) {
		var b = this._renderCmd.getNodeToParentTransform();
		if (a) for (var b = {
			a: b.a,
			b: b.b,
			c: b.c,
			d: b.d,
			tx: b.tx,
			ty: b.ty
		}, c = this._parent; null != c && c != a; c = c.getParent()) cc.affineTransformConcatIn(b, c.getNodeToParentTransform());
		return b
	},
	getNodeToParentAffineTransform: function(a) {
		return this.getNodeToParentTransform(a)
	},
	getCamera: function() {
		this._camera || (this._camera = new cc.Camera);
		return this._camera
	},
	getGrid: function() {
		return this.grid
	},
	setGrid: function(a) {
		this.grid = a
	},
	getShaderProgram: function() {
		return this._renderCmd.getShaderProgram()
	},
	setShaderProgram: function(a) {
		this._renderCmd.setShaderProgram(a)
	},
	getGLServerState: function() {
		return 0
	},
	setGLServerState: function(a) {},
	getBoundingBoxToWorld: function() {
		var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
			b = this.getNodeToWorldTransform(),
			a = cc.rectApplyAffineTransform(a, b);
		if (!this._children) return a;
		for (var c = this._children, d = 0; d < c.length; d++) {
			var e = c[d];
			e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, e))
		}
		return a
	},
	_getBoundingBoxToCurrentNode: function(a) {
		var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
		a = void 0 === a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
		b = cc.rectApplyAffineTransform(b, a);
		if (!this._children) return b;
		for (var c = this._children, d = 0; d < c.length; d++) {
			var e = c[d];
			e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, e))
		}
		return b
	},
	getOpacity: function() {
		return this._realOpacity
	},
	getDisplayedOpacity: function() {
		return this._renderCmd.getDisplayedOpacity()
	},
	setOpacity: function(a) {
		this._realOpacity = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	updateDisplayedOpacity: function(a) {
		this._renderCmd._updateDisplayOpacity(a)
	},
	isCascadeOpacityEnabled: function() {
		return this._cascadeOpacityEnabled
	},
	setCascadeOpacityEnabled: function(a) {
		this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled = a, this._renderCmd.setCascadeOpacityEnabledDirty())
	},
	getColor: function() {
		var a = this._realColor;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	getDisplayedColor: function() {
		return this._renderCmd.getDisplayedColor()
	},
	setColor: function(a) {
		var b = this._realColor;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	updateDisplayedColor: function(a) {
		this._renderCmd._updateDisplayColor(a)
	},
	isCascadeColorEnabled: function() {
		return this._cascadeColorEnabled
	},
	setCascadeColorEnabled: function(a) {
		this._cascadeColorEnabled !== a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_initRendererCmd: function() {
		this._renderCmd = cc.renderer.getRenderCmd(this)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
	},
	enumerateChildren: function(a, b) {
		cc.assert(a && 0 != a.length, "Invalid name");
		cc.assert(null != b, "Invalid callback function");
		var c = a.length,
			d = 0,
			e = c,
			f = !1;
		2 < c && ("/" === a[0] && "/" === a[1]) && (f = !0, d = 2, e -= 2);
		var k = !1;
		3 < c && ("/" === a[c - 3] && "." === a[c - 2] && "." === a[c - 1]) && (k = !0, e -= 3);
		c = a.substr(d, e);
		k && (c = "[[:alnum:]]+/" + c);
		f ? this.doEnumerateRecursive(this, c, b) : this.doEnumerate(c, b)
	},
	doEnumerateRecursive: function(a, b, c) {
		if (!a.doEnumerate(b, c)) for (var d = a.getChildren(), e = d.length, f = 0; f < e && !(a = d[f], this.doEnumerateRecursive(a, b, c)); f++);
	},
	doEnumerate: function(a, b) {
		var c = a.indexOf("/"),
			d = a,
			e = !1; - 1 !== c && (d = a.substr(0, c), e = !0);
		for (var c = !1, f, k = this._children, m = k.length, n = 0; n < m; n++)
		if (f = k[n], -1 !== f._name.indexOf(d)) if (e) {
			if (c = f.doEnumerate(a, b)) break
		} else if (b(f)) {
			c = !0;
			break
		}
		return c
	}
});
cc.Node.create = function() {
	return new cc.Node
};
cc.Node._stateCallbackType = {
	onEnter: 1,
	onExit: 2,
	cleanup: 3,
	onEnterTransitionDidFinish: 4,
	updateTransform: 5,
	onExitTransitionDidStart: 6,
	sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(a, b) {
	this._needDraw = !0;
	this._target = a;
	this._callback = b;
	this.rendering = function(a, b, e) {
		this._callback && this._callback.call(this._target, a, b, e)
	}
};
cc.Node._dirtyFlags = {
	transformDirty: 1,
	visibleDirty: 2,
	colorDirty: 4,
	opacityDirty: 8,
	cacheDirty: 16,
	orderDirty: 32,
	textDirty: 64,
	gradientDirty: 128,
	all: 255
};
cc.Node.RenderCmd = function(a) {
	this._dirtyFlag = 1;
	this._node = a;
	this._needDraw = !1;
	this._anchorPointInPoints = new cc.Point(0, 0);
	this._transform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._worldTransform = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._inverse = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		tx: 0,
		ty: 0
	};
	this._displayedOpacity = 255;
	this._displayedColor = cc.color(255, 255, 255, 255);
	this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
	this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
	constructor: cc.Node.RenderCmd,
	getAnchorPointInPoints: function() {
		return cc.p(this._anchorPointInPoints)
	},
	getDisplayedColor: function() {
		var a = this._displayedColor;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	getDisplayedOpacity: function() {
		return this._displayedOpacity
	},
	setCascadeColorEnabledDirty: function() {
		this._cascadeColorEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setCascadeOpacityEnabledDirty: function() {
		this._cascadeOpacityEnabledDirty = !0;
		this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getParentToNodeTransform: function() {
		this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
		return this._inverse
	},
	detachFromParent: function() {},
	_updateAnchorPointInPoint: function() {
		var a = this._anchorPointInPoints,
			b = this._node._contentSize,
			c = this._node._anchorPoint;
		a.x = b.width * c.x;
		a.y = b.height * c.y;
		this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
	},
	setDirtyFlag: function(a) {
		0 === this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this);
		this._dirtyFlag |= a
	},
	getParentRenderCmd: function() {
		return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
	},
	_updateDisplayColor: function(a) {
		var b = this._node,
			c = this._displayedColor,
			d = b._realColor,
			e;
		if (this._cascadeColorEnabledDirty && !b._cascadeColorEnabled) {
			c.r = d.r;
			c.g = d.g;
			c.b = d.b;
			c = new cc.Color(255, 255, 255, 255);
			a = b._children;
			b = 0;
			for (d = a.length; b < d; b++)(e = a[b]) && e._renderCmd && e._renderCmd._updateDisplayColor(c);
			this._cascadeColorEnabledDirty = !1
		} else if (void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE), c.r = 0 | d.r * a.r / 255, c.g = 0 | d.g * a.g / 255, c.b = 0 | d.b * a.b / 255, b._cascadeColorEnabled) {
			a = b._children;
			b = 0;
			for (d = a.length; b < d; b++)
			if ((e = a[b]) && e._renderCmd) e._renderCmd._updateDisplayColor(c), e._renderCmd._updateColor()
		}
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
	},
	_updateDisplayOpacity: function(a) {
		var b = this._node,
			c, d;
		if (this._cascadeOpacityEnabledDirty && !b._cascadeOpacityEnabled) {
			this._displayedOpacity = b._realOpacity;
			c = b._children;
			a = 0;
			for (b = c.length; a < b; a++)(d = c[a]) && d._renderCmd && d._renderCmd._updateDisplayOpacity(255);
			this._cascadeOpacityEnabledDirty = !1
		} else if (void 0 === a && (c = b._parent, a = 255, c && c._cascadeOpacityEnabled && (a = c.getDisplayedOpacity())), this._displayedOpacity = b._realOpacity * a / 255, b._cascadeOpacityEnabled) {
			c = b._children;
			a = 0;
			for (b = c.length; a < b; a++)
			if ((d = c[a]) && d._renderCmd) d._renderCmd._updateDisplayOpacity(this._displayedOpacity), d._renderCmd._updateColor()
		}
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
	},
	_syncDisplayColor: function(a) {
		var b = this._node,
			c = this._displayedColor,
			d = b._realColor;
		void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
		c.r = 0 | d.r * a.r / 255;
		c.g = 0 | d.g * a.g / 255;
		c.b = 0 | d.b * a.b / 255
	},
	_syncDisplayOpacity: function(a) {
		var b = this._node;
		if (void 0 === a) {
			var c = b._parent;
			a = 255;
			c && c._cascadeOpacityEnabled && (a = c.getDisplayedOpacity())
		}
		this._displayedOpacity = b._realOpacity * a / 255
	},
	_updateColor: function() {},
	updateStatus: function() {
		var a = cc.Node._dirtyFlags,
			b = this._dirtyFlag,
			c = b & a.colorDirty,
			d = b & a.opacityDirty;
		c && this._updateDisplayColor();
		d && this._updateDisplayOpacity();
		(c || d) && this._updateColor();
		b & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	}
};
(function() {
	cc.Node.CanvasRenderCmd = function(a) {
		cc.Node.RenderCmd.call(this, a);
		this._cachedParent = null;
		this._cacheDirty = !1
	};
	var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	a.constructor = cc.Node.CanvasRenderCmd;
	a.transform = function(a, c) {
		var d = this.getNodeToParentTransform(),
			e = this._worldTransform;
		this._cacheDirty = !0;
		if (a) {
			var f = a._worldTransform;
			e.a = d.a * f.a + d.b * f.c;
			e.b = d.a * f.b + d.b * f.d;
			e.c = d.c * f.a + d.d * f.c;
			e.d = d.c * f.b + d.d * f.d;
			e.tx = f.a * d.tx + f.c * d.ty + f.tx;
			e.ty = f.d * d.ty + f.ty + f.b * d.tx
		} else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
		if (c && (d = this._node._children) && 0 !== d.length) {
			e = 0;
			for (f = d.length; e < f; e++) d[e]._renderCmd.transform(this, c)
		}
	};
	a.getNodeToParentTransform = function() {
		var a = this._node,
			c = !1;
		a._usingNormalizedPosition && a._parent && (c = a._parent._contentSize, a._position.x = a._normalizedPosition.x * c.width, a._position.y = a._normalizedPosition.y * c.height, a._normalizedPositionDirty = !1, c = !0);
		if (c || this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			c = this._transform;
			c.tx = a._position.x;
			c.ty = a._position.y;
			var d = 1,
				e = 0,
				f = 0,
				k = 1;
			a._rotationX && (k = 0.017453292519943295 * a._rotationX, f = Math.sin(k), k = Math.cos(k));
			a._rotationY && (e = 0.017453292519943295 * a._rotationY, d = Math.cos(e), e = -Math.sin(e));
			c.a = d;
			c.b = e;
			c.c = f;
			c.d = k;
			var m = a._scaleX,
				n = a._scaleY,
				p = this._anchorPointInPoints.x,
				r = this._anchorPointInPoints.y,
				s = 1E-6 > m && -1E-6 < m ? 1E-6 : m,
				u = 1E-6 > n && -1E-6 < n ? 1E-6 : n;
			if (1 !== m || 1 !== n) d = c.a *= s, e = c.b *= s, f = c.c *= u, k = c.d *= u;
			if (a._skewX || a._skewY) m = Math.tan(-a._skewX * Math.PI / 180), n = Math.tan(-a._skewY * Math.PI / 180), Infinity === m && (m = 99999999), Infinity === n && (n = 99999999), s = r * m, u = p * n, c.a = d - f * n, c.b = e - k * n, c.c = f - d * m, c.d = k - e * m, c.tx += d * s + f * u, c.ty += e * s + k * u;
			c.tx -= d * p + f * r;
			c.ty -= e * p + k * r;
			a._ignoreAnchorPointForPosition && (c.tx += p, c.ty += r);
			a._additionalTransformDirty && (this._transform = cc.affineTransformConcat(c, a._additionalTransform))
		}
		return this._transform
	};
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) {
			if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
			var d = c._children,
				e;
			this._syncStatus(a);
			a = d.length;
			if (0 < a) {
				c.sortAllChildren();
				for (c = 0; c < a; c++)
				if (e = d[c], 0 > e._localZOrder) e._renderCmd.visit(this);
				else break;
				for (cc.renderer.pushRenderCommand(this); c < a; c++) d[c]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0
		}
	};
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		var e = d & c.colorDirty,
			f = d & c.opacityDirty,
			c = d & c.transformDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e && this._updateColor();
		c && this.transform(a)
	};
	a.setDirtyFlag = function(a, c) {
		cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a, c);
		this._setCacheDirty(c);
		this._cachedParent && this._cachedParent.setDirtyFlag(a, !0)
	};
	a._setCacheDirty = function() {
		if (!1 === this._cacheDirty) {
			this._cacheDirty = !0;
			var a = this._cachedParent;
			a && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache()
		}
	};
	a._setCachedParent = function(a) {
		if (this._cachedParent !== a) {
			this._cachedParent = a;
			for (var c = this._node._children, d = 0, e = c.length; d < e; d++) c[d]._renderCmd._setCachedParent(a)
		}
	};
	a.detachFromParent = function() {
		this._cachedParent = null;
		for (var a = this._node._children, c, d = 0, e = a.length; d < e; d++)(c = a[d]) && c._renderCmd && c._renderCmd.detachFromParent()
	};
	a.setShaderProgram = function(a) {};
	a.getShaderProgram = function() {
		return null
	};
	cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(a) {
		return a ? a.src === cc.SRC_ALPHA && a.dst === cc.ONE || a.src === cc.ONE && a.dst === cc.ONE ? "lighter" : a.src === cc.ZERO && a.dst === cc.SRC_ALPHA ? "destination-in" : a.src === cc.ZERO && a.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
	}
})();
(function() {
	cc.Node.WebGLRenderCmd = function(a) {
		cc.Node.RenderCmd.call(this, a);
		a = new cc.math.Matrix4;
		var c = a.mat;
		c[2] = c[3] = c[6] = c[7] = c[8] = c[9] = c[11] = c[14] = 0;
		c[10] = c[15] = 1;
		this._transform4x4 = a;
		this._stackMatrix = new cc.math.Matrix4;
		this._camera = this._shaderProgram = null
	};
	var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
	a.constructor = cc.Node.WebGLRenderCmd;
	a.getNodeToParentTransform = function() {
		var a = this._node;
		if (a._usingNormalizedPosition && a._parent) {
			var c = a._parent._contentSize;
			a._position.x = a._normalizedPosition.x * c.width;
			a._position.y = a._normalizedPosition.y * c.height;
			a._normalizedPositionDirty = !1
		}
		if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
			var c = a._position.x,
				d = a._position.y,
				e = this._anchorPointInPoints.x,
				f = -e,
				k = this._anchorPointInPoints.y,
				m = -k,
				n = a._scaleX,
				p = a._scaleY,
				r = 0.017453292519943295 * a._rotationX,
				s = 0.017453292519943295 * a._rotationY;
			a._ignoreAnchorPointForPosition && (c += e, d += k);
			var u = 1,
				t = 0,
				w = 1,
				v = 0;
			if (0 !== a._rotationX || 0 !== a._rotationY) u = Math.cos(-r), t = Math.sin(-r), w = Math.cos(-s), v = Math.sin(-s);
			r = a._skewX || a._skewY;
			if (!r && (0 !== e || 0 !== k)) c += w * f * n + -t * m * p, d += v * f * n + u * m * p;
			s = this._transform;
			s.a = w * n;
			s.b = v * n;
			s.c = -t * p;
			s.d = u * p;
			s.tx = c;
			s.ty = d;
			if (r && (s = cc.affineTransformConcat({
				a: 1,
				b: Math.tan(cc.degreesToRadians(a._skewY)),
				c: Math.tan(cc.degreesToRadians(a._skewX)),
				d: 1,
				tx: 0,
				ty: 0
			}, s), 0 !== e || 0 !== k)) s = cc.affineTransformTranslate(s, f, m);
			a._additionalTransformDirty && (s = cc.affineTransformConcat(s, a._additionalTransform), a._additionalTransformDirty = !1);
			this._transform = s
		}
		return this._transform
	};
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		e = d & c.colorDirty;
		c = d & c.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		c && this._syncDisplayOpacity();
		(e || c) && this._updateColor();
		this.transform(a)
	};
	a._updateColor = function() {};
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) {
			a = a || this.getParentRenderCmd();
			c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._syncStatus(a);
			d.top = this._stackMatrix;
			if ((a = c._children) && 0 < a.length) {
				var e = a.length;
				c.sortAllChildren();
				for (c = 0; c < e; c++)
				if (a[c] && 0 > a[c]._localZOrder) a[c]._renderCmd.visit(this);
				else break;
				for (cc.renderer.pushRenderCommand(this); c < e; c++) a[c] && a[c]._renderCmd.visit(this)
			} else cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.transform = function(a, c) {
		var d = this._transform4x4,
			e = this._stackMatrix,
			f = this._node,
			k = (a = a || this.getParentRenderCmd()) ? a._stackMatrix : cc.current_stack.top,
			m = this.getNodeToParentTransform();
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
		var n = d.mat;
		n[0] = m.a;
		n[4] = m.c;
		n[12] = m.tx;
		n[1] = m.b;
		n[5] = m.d;
		n[13] = m.ty;
		n[14] = f._vertexZ;
		cc.kmMat4Multiply(e, k, d);
		null !== f._camera && !(null !== f.grid && f.grid.isActive()) && (k = this._anchorPointInPoints.x, m = this._anchorPointInPoints.y, 0 !== k || 0 !== m ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (k |= 0, m |= 0), n = cc.math.Matrix4.createByTranslation(k, m, 0, d), e.multiply(n), f._camera._locateForRenderer(e), n = cc.math.Matrix4.createByTranslation(-k, -m, 0, n), e.multiply(n), d.identity()) : f._camera._locateForRenderer(e));
		if (c && f._children && 0 !== f._children.length) {
			f = f._children;
			d = 0;
			for (e = f.length; d < e; d++) f[d]._renderCmd.transform(this, c)
		}
	};
	a.setShaderProgram = function(a) {
		this._shaderProgram = a
	};
	a.getShaderProgram = function() {
		return this._shaderProgram
	}
})();
cc.AtlasNode = cc.Node.extend({
	textureAtlas: null,
	quadsToDraw: 0,
	_itemsPerRow: 0,
	_itemsPerColumn: 0,
	_itemWidth: 0,
	_itemHeight: 0,
	_opacityModifyRGB: !1,
	_blendFunc: null,
	_ignoreContentScaleFactor: !1,
	_className: "AtlasNode",
	_textureForCanvas: null,
	ctor: function(a, b, c, d) {
		cc.Node.prototype.ctor.call(this);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._ignoreContentScaleFactor = !1;
		void 0 !== d && this.initWithTileFile(a, b, c, d)
	},
	_createRenderCmd: function() {
		this._renderCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
	},
	updateAtlasValues: function() {
		cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
	},
	getColor: function() {
		return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
	},
	setOpacityModifyRGB: function(a) {
		var b = this.color;
		this._opacityModifyRGB = a;
		this.setColor(b)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a, b) {
		this._blendFunc = void 0 === b ? a : {
			src: a,
			dst: b
		}
	},
	setTextureAtlas: function(a) {
		this.textureAtlas = a
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	getQuadsToDraw: function() {
		return this.quadsToDraw
	},
	setQuadsToDraw: function(a) {
		this.quadsToDraw = a
	},
	initWithTileFile: function(a, b, c, d) {
		if (!a) throw Error("cc.AtlasNode.initWithTileFile(): title should not be null");
		a = cc.textureCache.addImage(a);
		return this.initWithTexture(a, b, c, d)
	},
	initWithTexture: function(a, b, c, d) {
		return this._renderCmd.initWithTexture(a, b, c, d)
	},
	setColor: function(a) {
		this._renderCmd.setColor(a)
	},
	setOpacity: function(a) {
		this._renderCmd.setOpacity(a)
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	_setIgnoreContentScaleFactor: function(a) {
		this._ignoreContentScaleFactor = a
	}
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(a, b, c, d) {
	return new cc.AtlasNode(a, b, c, d)
};
(function() {
	cc.AtlasNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !1;
		this._colorUnmodified = cc.color.WHITE;
		this._texture = this._originalTexture = null
	};
	var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.AtlasNode.CanvasRenderCmd;
	a.initWithTexture = function(a, c, d, e) {
		var f = this._node;
		f._itemWidth = c;
		f._itemHeight = d;
		f._opacityModifyRGB = !0;
		this._originalTexture = a;
		if (!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._texture = this._originalTexture;
		this._calculateMaxItems();
		f.quadsToDraw = e;
		return !0
	};
	a.setColor = function(a) {
		var c = this._node._realColor;
		c.r === a.r && c.g === a.g && c.b === a.b || (this._colorUnmodified = a, this._changeTextureColor())
	};
	a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function() {
		var a = this._node,
			c = a.getTexture();
		if (c && this._originalTexture) {
			var d = this._originalTexture.getHtmlElementObj();
			if (d) {
				var e = c.getHtmlElementObj(),
					c = cc.rect(0, 0, d.width, d.height);
				e instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._colorUnmodified, c, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._colorUnmodified, c), c = new cc.Texture2D, c.initWithElement(e), c.handleLoadedTexture(), a.setTexture(c))
			}
		}
	} : function() {
		var a = this._node,
			c, d = a.getTexture();
		if (d && this._originalTexture && (c = d.getHtmlElementObj())) {
			var e = this._originalTexture.getHtmlElementObj();
			if (d = cc.textureCache.getTextureColors(e)) e = cc.rect(0, 0, e.width, e.height), c instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImage(c, d, this._displayedColor, e, c) : (c = cc.Sprite.CanvasRenderCmd._generateTintImage(c, d, this._displayedColor, e), d = new cc.Texture2D, d.initWithElement(c), d.handleLoadedTexture(), a.setTexture(d))
		}
	};
	a.setOpacity = function(a) {
		cc.Node.prototype.setOpacity.call(this._node, a)
	};
	a.getTexture = function() {
		return this._texture
	};
	a.setTexture = function(a) {
		this._texture = a
	};
	a._calculateMaxItems = function() {
		var a = this._node,
			c = this._texture.getContentSize();
		a._itemsPerColumn = 0 | c.height / a._itemHeight;
		a._itemsPerRow = 0 | c.width / a._itemWidth
	}
})();
(function() {
	cc.AtlasNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureAtlas = null;
		this._colorUnmodified = cc.color.WHITE;
		this._uniformColor = this._colorF32Array = null;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
		this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
	};
	var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.AtlasNode.WebGLRenderCmd;
	a._updateBlendFunc = function() {
		var a = this._node;
		this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
	};
	a._updateOpacityModifyRGB = function() {
		this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
	};
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var c = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst);
		this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(c.quadsToDraw, 0))
	};
	a.initWithTexture = function(a, c, d, e) {
		var f = this._node;
		f._itemWidth = c;
		f._itemHeight = d;
		this._colorUnmodified = cc.color.WHITE;
		f._opacityModifyRGB = !0;
		f._blendFunc.src = cc.BLEND_SRC;
		f._blendFunc.dst = cc.BLEND_DST;
		c = f._realColor;
		this._colorF32Array = new Float32Array([c.r / 255, c.g / 255, c.b / 255, f._realOpacity / 255]);
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(a, e);
		if (!this._textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB();
		this._calculateMaxItems();
		f.quadsToDraw = e;
		return !0
	};
	a.setColor = function(a) {
		var c = cc.color(a.r, a.g, a.b),
			d = this._node;
		this._colorUnmodified = a;
		a = this._displayedOpacity;
		d._opacityModifyRGB && (c.r = c.r * a / 255, c.g = c.g * a / 255, c.b = c.b * a / 255);
		cc.Node.prototype.setColor.call(d, c)
	};
	a.setOpacity = function(a) {
		var c = this._node;
		cc.Node.prototype.setOpacity.call(c, a);
		c._opacityModifyRGB && (c.color = this._colorUnmodified)
	};
	a._updateColor = function() {
		var a = this._displayedColor;
		this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
	};
	a.getTexture = function() {
		return this._textureAtlas.texture
	};
	a.setTexture = function(a) {
		this._textureAtlas.texture = a;
		this._updateBlendFunc();
		this._updateOpacityModifyRGB()
	};
	a._calculateMaxItems = function() {
		var a = this._node,
			c = this._textureAtlas.texture,
			d = c.getContentSize();
		a._ignoreContentScaleFactor && (d = c.getContentSizeInPixels());
		a._itemsPerColumn = 0 | d.height / a._itemHeight;
		a._itemsPerRow = 0 | d.width / a._itemWidth
	}
})();
cc._tmp.WebGLTexture2D = function() {
	cc.Texture2D = cc.Class.extend({
		_pVRHaveAlphaPremultiplied: !0,
		_pixelFormat: null,
		_pixelsWide: 0,
		_pixelsHigh: 0,
		_name: "",
		_contentSize: null,
		maxS: 0,

		maxT: 0,
		_hasPremultipliedAlpha: !1,
		_hasMipmaps: !1,
		shaderProgram: null,
		_textureLoaded: !1,
		_htmlElementObj: null,
		_webTextureObj: null,
		url: null,
		ctor: function() {
			this._contentSize = cc.size(0, 0);
			this._pixelFormat = cc.Texture2D.defaultPixelFormat
		},
		releaseTexture: function() {
			this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
			cc.loader.release(this.url)
		},
		getPixelFormat: function() {
			return this._pixelFormat
		},
		getPixelsWide: function() {
			return this._pixelsWide
		},
		getPixelsHigh: function() {
			return this._pixelsHigh
		},
		getName: function() {
			return this._webTextureObj
		},
		getContentSize: function() {
			return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
		},
		_getWidth: function() {
			return this._contentSize.width / cc.contentScaleFactor()
		},
		_getHeight: function() {
			return this._contentSize.height / cc.contentScaleFactor()
		},
		getContentSizeInPixels: function() {
			return this._contentSize
		},
		getMaxS: function() {
			return this.maxS
		},
		setMaxS: function(a) {
			this.maxS = a
		},
		getMaxT: function() {
			return this.maxT
		},
		setMaxT: function(a) {
			this.maxT = a
		},
		getShaderProgram: function() {
			return this.shaderProgram
		},
		setShaderProgram: function(a) {
			this.shaderProgram = a
		},
		hasPremultipliedAlpha: function() {
			return this._hasPremultipliedAlpha
		},
		hasMipmaps: function() {
			return this._hasMipmaps
		},
		description: function() {
			return "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates = (" + this.maxS + ", " + this.maxT + ")>"
		},
		releaseData: function(a) {},
		keepData: function(a, b) {
			return a
		},
		initWithData: function(a, b, c, d, e) {
			var f = cc.Texture2D,
				k = cc._renderContext,
				m = k.RGBA,
				n = k.UNSIGNED_BYTE,
				p = c * cc.Texture2D._B[b] / 8;
			0 === p % 8 ? k.pixelStorei(k.UNPACK_ALIGNMENT, 8) : 0 === p % 4 ? k.pixelStorei(k.UNPACK_ALIGNMENT, 4) : 0 === p % 2 ? k.pixelStorei(k.UNPACK_ALIGNMENT, 2) : k.pixelStorei(k.UNPACK_ALIGNMENT, 1);
			this._webTextureObj = k.createTexture();
			cc.glBindTexture2D(this);
			k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MIN_FILTER, k.LINEAR);
			k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MAG_FILTER, k.LINEAR);
			k.texParameteri(k.TEXTURE_2D, k.TEXTURE_WRAP_S, k.CLAMP_TO_EDGE);
			k.texParameteri(k.TEXTURE_2D, k.TEXTURE_WRAP_T, k.CLAMP_TO_EDGE);
			switch (b) {
			case f.PIXEL_FORMAT_RGBA8888:
				m = k.RGBA;
				break;
			case f.PIXEL_FORMAT_RGB888:
				m = k.RGB;
				break;
			case f.PIXEL_FORMAT_RGBA4444:
				n = k.UNSIGNED_SHORT_4_4_4_4;
				break;
			case f.PIXEL_FORMAT_RGB5A1:
				n = k.UNSIGNED_SHORT_5_5_5_1;
				break;
			case f.PIXEL_FORMAT_RGB565:
				n = k.UNSIGNED_SHORT_5_6_5;
				break;
			case f.PIXEL_FORMAT_AI88:
				m = k.LUMINANCE_ALPHA;
				break;
			case f.PIXEL_FORMAT_A8:
				m = k.ALPHA;
				break;
			case f.PIXEL_FORMAT_I8:
				m = k.LUMINANCE;
				break;
			default:
				cc.assert(0, cc._LogInfos.Texture2D_initWithData)
			}
			k.texImage2D(k.TEXTURE_2D, 0, m, c, d, 0, m, n, a);
			this._contentSize.width = e.width;
			this._contentSize.height = e.height;
			this._pixelsWide = c;
			this._pixelsHigh = d;
			this._pixelFormat = b;
			this.maxS = e.width / c;
			this.maxT = e.height / d;
			this._hasMipmaps = this._hasPremultipliedAlpha = !1;
			this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
			return this._textureLoaded = !0
		},
		drawAtPoint: function(a) {
			var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
				c = this._pixelsWide * this.maxS,
				d = this._pixelsHigh * this.maxT;
			a = [a.x, a.y, 0, c + a.x, a.y, 0, a.x, d + a.y, 0, c + a.x, d + a.y, 0];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			c = cc._renderContext;
			c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
			c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, b);
			c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
		},
		drawInRect: function(a) {
			var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
			a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
			this._shaderProgram.use();
			this._shaderProgram.setUniformsForBuiltins();
			cc.glBindTexture2D(this);
			var c = cc._renderContext;
			c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
			c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, b);
			c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
		},
		initWithImage: function(a) {
			if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
			var b = a.getWidth(),
				c = a.getHeight(),
				d = cc.configuration.getMaxTextureSize();
			if (b > d || c > d) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, c, d, d), !1;
			this._textureLoaded = !0;
			return this._initPremultipliedATextureWithImage(a, b, c)
		},
		initWithElement: function(a) {
			a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a, this._textureLoaded = !0)
		},
		getHtmlElementObj: function() {
			return this._htmlElementObj
		},
		isLoaded: function() {
			return this._textureLoaded
		},
		handleLoadedTexture: function(a) {
			a = void 0 === a ? !1 : a;
			if (cc._rendererInitialized) {
				if (!this._htmlElementObj) {
					var b = cc.loader.getRes(this.url);
					if (!b) return;
					this.initWithElement(b)
				}
				this._htmlElementObj.width && this._htmlElementObj.height && (b = cc._renderContext, cc.glBindTexture2D(this), b.pixelStorei(b.UNPACK_ALIGNMENT, 4), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, this._htmlElementObj), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), b = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = b, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasPremultipliedAlpha = a, this._hasMipmaps = !1, this.dispatchEvent("load"))
			}
		},
		initWithString: function(a, b, c, d, e, f) {
			cc.log(cc._LogInfos.Texture2D_initWithString);
			return null
		},
		initWithETCFile: function(a) {
			cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
			return !1
		},
		initWithPVRFile: function(a) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
			return !1
		},
		initWithPVRTCData: function(a, b, c, d, e, f) {
			cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
			return !1
		},
		setTexParameters: function(a, b, c, d) {
			var e = cc._renderContext;
			void 0 !== b && (a = {
				minFilter: a,
				magFilter: b,
				wrapS: c,
				wrapT: d
			});
			cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || a.wrapS === e.CLAMP_TO_EDGE && a.wrapT === e.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
			cc.glBindTexture2D(this);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, a.minFilter);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, a.magFilter);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a.wrapS);
			e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a.wrapT)
		},
		setAntiAliasTexParameters: function() {
			var a = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
		},
		setAliasTexParameters: function() {
			var a = cc._renderContext;
			cc.glBindTexture2D(this);
			this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
		},
		generateMipmap: function() {
			cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
			cc.glBindTexture2D(this);
			cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
			this._hasMipmaps = !0
		},
		stringForFormat: function() {
			return cc.Texture2D._M[this._pixelFormat]
		},
		bitsPerPixelForFormat: function(a) {
			a = a || this._pixelFormat;
			var b = cc.Texture2D._B[a];
			if (null != b) return b;
			cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
			return -1
		},
		_initPremultipliedATextureWithImage: function(a, b, c) {
			var d = cc.Texture2D,
				e = a.getData(),
				f = null,
				f = null,
				k = a.hasAlpha(),
				m = cc.size(a.getWidth(), a.getHeight()),
				n = d.defaultPixelFormat,
				p = a.getBitsPerComponent();
			k || (8 <= p ? n = d.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), n = d.PIXEL_FORMAT_RGB565));
			var r = b * c;
			if (n === d.PIXEL_FORMAT_RGB565) if (k) {
				e = new Uint16Array(b * c);
				f = a.getData();
				for (p = 0; p < r; ++p) e[p] = (f[p] >> 0 & 255) >> 3 << 11 | (f[p] >> 8 & 255) >> 2 << 5 | (f[p] >> 16 & 255) >> 3 << 0
			} else {
				e = new Uint16Array(b * c);
				f = a.getData();
				for (p = 0; p < r; ++p) e[p] = (f[p] & 255) >> 3 << 11 | (f[p] & 255) >> 2 << 5 | (f[p] & 255) >> 3 << 0
			} else if (n === d.PIXEL_FORMAT_RGBA4444) {
				e = new Uint16Array(b * c);
				f = a.getData();
				for (p = 0; p < r; ++p) e[p] = (f[p] >> 0 & 255) >> 4 << 12 | (f[p] >> 8 & 255) >> 4 << 8 | (f[p] >> 16 & 255) >> 4 << 4 | (f[p] >> 24 & 255) >> 4 << 0
			} else if (n === d.PIXEL_FORMAT_RGB5A1) {
				e = new Uint16Array(b * c);
				f = a.getData();
				for (p = 0; p < r; ++p) e[p] = (f[p] >> 0 & 255) >> 3 << 11 | (f[p] >> 8 & 255) >> 3 << 6 | (f[p] >> 16 & 255) >> 3 << 1 | (f[p] >> 24 & 255) >> 7 << 0
			} else if (n === d.PIXEL_FORMAT_A8) {
				e = new Uint8Array(b * c);
				f = a.getData();
				for (p = 0; p < r; ++p) e[p] = f >> 24 & 255
			}
			if (k && n === d.PIXEL_FORMAT_RGB888) {
				f = a.getData();
				e = new Uint8Array(3 * b * c);
				for (p = 0; p < r; ++p) e[3 * p] = f >> 0 & 255, e[3 * p + 1] = f >> 8 & 255, e[3 * p + 2] = f >> 16 & 255
			}
			this.initWithData(e, n, b, c, m);
			a.getData();
			this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
			return !0
		},
		addLoadedEventListener: function(a, b) {
			this.addEventListener("load", a, b)
		},
		removeLoadedEventListener: function(a) {
			this.removeEventListener("load", a)
		}
	})
};
cc._tmp.WebGLTextureAtlas = function() {
	var a = cc.TextureAtlas.prototype;
	a._setupVBO = function() {
		var a = cc._renderContext;
		this._buffersVBO[0] = a.createBuffer();
		this._buffersVBO[1] = a.createBuffer();
		this._quadsWebBuffer = a.createBuffer();
		this._mapBuffers()
	};
	a._mapBuffers = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
	};
	a.drawNumberOfQuads = function(a, c) {
		c = c || 0;
		if (!(0 === a || !this.texture || !this.texture.isLoaded())) {
			var d = cc._renderContext;
			cc.glBindTexture2D(this.texture);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			d.bindBuffer(d.ARRAY_BUFFER, this._quadsWebBuffer);
			this.dirty && (d.bufferData(d.ARRAY_BUFFER, this._quadsArrayBuffer, d.DYNAMIC_DRAW), this.dirty = !1);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12);
			d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 24, 16);
			d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
			cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? d.drawElements(d.TRIANGLE_STRIP, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT) : d.drawElements(d.TRIANGLES, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT);
			cc.g_NumberOfDraws++
		}
	}
};
cc._tmp.WebGLTextureCache = function() {
	var a = cc.textureCache;
	a.handleLoadedTexture = function(a) {
		var c = this._textures,
			d;
		cc._rendererInitialized || (c = this._loadedTexturesBefore);
		d = c[a];
		d || (d = c[a] = new cc.Texture2D, d.url = a);
		".png" === cc.path.extname(a) ? d.handleLoadedTexture(!0) : d.handleLoadedTexture()
	};
	a.addImage = function(a, c, d) {
		cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
		var e = this._textures;
		cc._rendererInitialized || (e = this._loadedTexturesBefore);
		var f = e[a] || e[cc.loader._aliases[a]];
		if (f) return f.isLoaded() ? c && c.call(d, f) : f.addEventListener("load", function() {
			c && c.call(d, f)
		}, d), f;
		f = e[a] = new cc.Texture2D;
		f.url = a;
		(cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(f, m) {
			if (f) return c && c.call(d, f);
			cc.textureCache.handleLoadedTexture(a);
			var n = e[a];
			c && c.call(d, n)
		});
		return f
	};
	a.addImageAsync = a.addImage;
	a = null
};
cc._tmp.PrototypeTexture2D = function() {
	var a = cc.Texture2D;
	a.PVRImagesHavePremultipliedAlpha = function(a) {
		cc.PVRHaveAlphaPremultiplied_ = a
	};
	a.PIXEL_FORMAT_RGBA8888 = 2;
	a.PIXEL_FORMAT_RGB888 = 3;
	a.PIXEL_FORMAT_RGB565 = 4;
	a.PIXEL_FORMAT_A8 = 5;
	a.PIXEL_FORMAT_I8 = 6;
	a.PIXEL_FORMAT_AI88 = 7;
	a.PIXEL_FORMAT_RGBA4444 = 8;
	a.PIXEL_FORMAT_RGB5A1 = 7;
	a.PIXEL_FORMAT_PVRTC4 = 9;
	a.PIXEL_FORMAT_PVRTC2 = 10;
	a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
	a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT;
	var b = cc.Texture2D._M = {};
	b[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
	b[a.PIXEL_FORMAT_RGB888] = "RGB888";
	b[a.PIXEL_FORMAT_RGB565] = "RGB565";
	b[a.PIXEL_FORMAT_A8] = "A8";
	b[a.PIXEL_FORMAT_I8] = "I8";
	b[a.PIXEL_FORMAT_AI88] = "AI88";
	b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
	b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
	b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
	b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
	b = cc.Texture2D._B = {};
	b[a.PIXEL_FORMAT_RGBA8888] = 32;
	b[a.PIXEL_FORMAT_RGB888] = 24;
	b[a.PIXEL_FORMAT_RGB565] = 16;
	b[a.PIXEL_FORMAT_A8] = 8;
	b[a.PIXEL_FORMAT_I8] = 8;
	b[a.PIXEL_FORMAT_AI88] = 16;
	b[a.PIXEL_FORMAT_RGBA4444] = 16;
	b[a.PIXEL_FORMAT_RGB5A1] = 16;
	b[a.PIXEL_FORMAT_PVRTC4] = 4;
	b[a.PIXEL_FORMAT_PVRTC2] = 3;
	a = cc.Texture2D.prototype;
	cc.defineGetterSetter(a, "name", a.getName);
	cc.defineGetterSetter(a, "pixelFormat", a.getPixelFormat);
	cc.defineGetterSetter(a, "pixelsWidth", a.getPixelsWide);
	cc.defineGetterSetter(a, "pixelsHeight", a.getPixelsHigh);
	cc.defineGetterSetter(a, "width", a._getWidth);
	cc.defineGetterSetter(a, "height", a._getHeight)
};
cc._tmp.PrototypeTextureAtlas = function() {
	var a = cc.TextureAtlas.prototype;
	cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
	cc.defineGetterSetter(a, "capacity", a.getCapacity);
	cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.Texture2D = cc.Class.extend({
	_contentSize: null,
	_textureLoaded: !1,
	_htmlElementObj: null,
	url: null,
	_pattern: null,
	ctor: function() {
		this._contentSize = cc.size(0, 0);
		this._textureLoaded = !1;
		this._htmlElementObj = null;
		this._pattern = ""
	},
	getPixelsWide: function() {
		return this._contentSize.width
	},
	getPixelsHigh: function() {
		return this._contentSize.height
	},
	getContentSize: function() {
		var a = cc.contentScaleFactor();
		return cc.size(this._contentSize.width / a, this._contentSize.height / a)
	},
	_getWidth: function() {
		return this._contentSize.width / cc.contentScaleFactor()
	},
	_getHeight: function() {
		return this._contentSize.height / cc.contentScaleFactor()
	},
	getContentSizeInPixels: function() {
		return this._contentSize
	},
	initWithElement: function(a) {
		a && (this._htmlElementObj = a, this._contentSize.width = a.width, this._contentSize.height = a.height, this._textureLoaded = !0)
	},
	getHtmlElementObj: function() {
		return this._htmlElementObj
	},
	isLoaded: function() {
		return this._textureLoaded
	},
	handleLoadedTexture: function() {
		if (!this._textureLoaded) {
			if (!this._htmlElementObj) {
				var a = cc.loader.getRes(this.url);
				if (!a) return;
				this.initWithElement(a)
			}
			a = this._htmlElementObj;
			this._contentSize.width = a.width;
			this._contentSize.height = a.height;
			this.dispatchEvent("load")
		}
	},
	description: function() {
		return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
	},
	initWithData: function(a, b, c, d, e) {
		return !1
	},
	initWithImage: function(a) {
		return !1
	},
	initWithString: function(a, b, c, d, e, f) {
		return !1
	},
	releaseTexture: function() {
		cc.loader.release(this.url)
	},
	getName: function() {
		return null
	},
	getMaxS: function() {
		return 1
	},
	setMaxS: function(a) {},
	getMaxT: function() {
		return 1
	},
	setMaxT: function(a) {},
	getPixelFormat: function() {
		return null
	},
	getShaderProgram: function() {
		return null
	},
	setShaderProgram: function(a) {},
	hasPremultipliedAlpha: function() {
		return !1
	},
	hasMipmaps: function() {
		return !1
	},
	releaseData: function(a) {},
	keepData: function(a, b) {
		return a
	},
	drawAtPoint: function(a) {},
	drawInRect: function(a) {},
	initWithETCFile: function(a) {
		cc.log(cc._LogInfos.Texture2D_initWithETCFile);
		return !1
	},
	initWithPVRFile: function(a) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
		return !1
	},
	initWithPVRTCData: function(a, b, c, d, e, f) {
		cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
		return !1
	},
	setTexParameters: function(a, b, c, d) {
		void 0 !== b && (a = {
			minFilter: a,
			magFilter: b,
			wrapS: c,
			wrapT: d
		});
		this._pattern = a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? "repeat" : a.wrapS === cc.REPEAT ? "repeat-x" : a.wrapT === cc.REPEAT ? "repeat-y" : ""
	},
	setAntiAliasTexParameters: function() {},
	setAliasTexParameters: function() {},
	generateMipmap: function() {},
	stringForFormat: function() {
		return ""
	},
	bitsPerPixelForFormat: function(a) {
		return -1
	},
	addLoadedEventListener: function(a, b) {
		this.addEventListener("load", a, b)
	},
	removeLoadedEventListener: function(a) {
		this.removeEventListener("load", a)
	},
	_grayElementObj: null,
	_backupElement: null,
	_isGray: !1,
	_switchToGray: function(a) {
		this._textureLoaded && this._isGray !== a && ((this._isGray = a) ? (this._backupElement = this._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj = this._backupElement))
	}
}), cc.Texture2D._generateGrayTexture = function(a, b, c) {
	if (null === a) return null;
	c = c || cc.newElement("canvas");
	b = b || cc.rect(0, 0, a.width, a.height);
	c.width = b.width;
	c.height = b.height;
	var d = c.getContext("2d");
	d.drawImage(a, b.x, b.y, b.width, b.height, 0, 0, b.width, b.height);
	a = d.getImageData(0, 0, b.width, b.height);
	b = a.data;
	for (var e = 0, f = b.length; e < f; e += 4) b[e] = b[e + 1] = b[e + 2] = 0.34 * b[e] + 0.5 * b[e + 1] + 0.16 * b[e + 2];
	d.putImageData(a, 0, 0);
	return c
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
	_textures: {},
	_textureColorsCache: {},
	_textureKeySeq: 0 | 1E3 * Math.random(),
	_loadedTexturesBefore: {},
	_initializingRenderer: function() {
		var a, b = this._loadedTexturesBefore,
			c = this._textures;
		for (a in b) {
			var d = b[a];
			d.handleLoadedTexture();
			c[a] = d
		}
		this._loadedTexturesBefore = {}
	},
	addPVRTCImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addPVRTCImage)
	},
	addETCImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addETCImage)
	},
	description: function() {
		return "<TextureCache | Number of textures = " + this._textures.length + ">"
	},
	textureForKey: function(a) {
		cc.log(cc._LogInfos.textureCache_textureForKey);
		return this.getTextureForKey(a)
	},
	getTextureForKey: function(a) {
		return this._textures[a] || this._textures[cc.loader._aliases[a]]
	},
	getKeyByTexture: function(a) {
		for (var b in this._textures)
		if (this._textures[b] === a) return b;
		return null
	},
	_generalTextureKey: function() {
		this._textureKeySeq++;
		return "_textureKey_" + this._textureKeySeq
	},
	getTextureColors: function(a) {
		var b = this.getKeyByTexture(a);
		b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
		this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor(a));
		return this._textureColorsCache[b]
	},
	addPVRImage: function(a) {
		cc.log(cc._LogInfos.textureCache_addPVRImage)
	},
	removeAllTextures: function() {
		var a = this._textures,
			b;
		for (b in a) a[b] && a[b].releaseTexture();
		this._textures = {}
	},
	removeTexture: function(a) {
		if (a) {
			var b = this._textures,
				c;
			for (c in b) b[c] === a && (b[c].releaseTexture(), delete b[c])
		}
	},
	removeTextureForKey: function(a) {
		null != a && this._textures[a] && delete this._textures[a]
	},
	cacheImage: function(a, b) {
		if (b instanceof cc.Texture2D) this._textures[a] = b;
		else {
			var c = new cc.Texture2D;
			c.initWithElement(b);
			c.handleLoadedTexture();
			this._textures[a] = c
		}
	},
	addUIImage: function(a, b) {
		cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
		if (b && this._textures[b]) return this._textures[b];
		var c = new cc.Texture2D;
		c.initWithImage(a);
		null != b ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage);
		return c
	},
	dumpCachedTextureInfo: function() {
		var a = 0,
			b = 0,
			c = this._textures,
			d;
		for (d in c) {
			var e = c[d];
			a++;
			e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight);
			b += 4 * e.pixelsWidth * e.pixelsHeight
		}
		c = this._textureColorsCache;
		for (d in c) {
			var e = c[d],
				f;
			for (f in e) {
				var k = e[f];
				a++;
				cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, k.width, k.height);
				b += 4 * k.width * k.height
			}
		}
		cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
	},
	_clear: function() {
		this._textures = {};
		this._textureColorsCache = {};
		this._textureKeySeq = 0 | 1E3 * Math.random();
		this._loadedTexturesBefore = {}
	}
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
	var b = this._textures,
		c = b[a];
	c || (c = b[a] = new cc.Texture2D, c.url = a);
	c.handleLoadedTexture()
}, _p.addImage = function(a, b, c) {
	cc.assert(a, cc._LogInfos.Texture2D_addImage);
	var d = this._textures,
		e = d[a] || d[cc.loader._aliases[a]];
	if (e) return e.isLoaded() ? b && b.call(c, e) : e.addEventListener("load", function() {
		b && b.call(c, e)
	}, c), e;
	e = d[a] = new cc.Texture2D;
	e.url = a;
	(cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(e, k) {
		if (e) return b && b.call(c, e);
		cc.textureCache.handleLoadedTexture(a);
		var m = d[a];
		b && b.call(c, m)
	});
	return e
}, _p.addImageAsync = _p.addImage, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
	dirty: !1,
	texture: null,
	_indices: null,
	_buffersVBO: null,
	_capacity: 0,
	_quads: null,
	_quadsArrayBuffer: null,
	_quadsWebBuffer: null,
	_quadsReader: null,
	ctor: function(a, b) {
		this._buffersVBO = [];
		cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
	},
	getTotalQuads: function() {
		return this._totalQuads
	},
	getCapacity: function() {
		return this._capacity
	},
	getTexture: function() {
		return this.texture
	},
	setTexture: function(a) {
		this.texture = a
	},
	setDirty: function(a) {
		this.dirty = a
	},
	isDirty: function() {
		return this.dirty
	},
	getQuads: function() {
		return this._quads
	},
	setQuads: function(a) {
		this._quads = a
	},
	_copyQuadsToTextureAtlas: function(a, b) {
		if (a) for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
	},
	_setQuadToArray: function(a, b) {
		var c = this._quads;
		c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
	},
	description: function() {
		return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
	},
	_setupIndices: function() {
		if (0 !== this._capacity) for (var a = this._indices, b = this._capacity, c = 0; c < b; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
	},
	_setupVBO: function() {
		var a = cc._renderContext;
		this._buffersVBO[0] = a.createBuffer();
		this._buffersVBO[1] = a.createBuffer();
		this._quadsWebBuffer = a.createBuffer();
		this._mapBuffers()
	},
	_mapBuffers: function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
	},
	initWithFile: function(a, b) {
		var c = cc.textureCache.addImage(a);
		if (c) return this.initWithTexture(c, b);
		cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
		return !1
	},
	initWithTexture: function(a, b) {
		cc.assert(a, cc._LogInfos.TextureAtlas_initWithTexture);
		this._capacity = b |= 0;
		this._totalQuads = 0;
		this.texture = a;
		this._quads = [];
		this._indices = new Uint16Array(6 * b);
		var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._quadsArrayBuffer = new ArrayBuffer(c * b);
		this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
		if ((!this._quads || !this._indices) && 0 < b) return !1;
		for (var d = this._quads, e = 0; e < b; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
		this._setupIndices();
		this._setupVBO();
		return this.dirty = !0
	},
	updateQuad: function(a, b) {
		cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
		cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
		this._totalQuads = Math.max(b + 1, this._totalQuads);
		this._setQuadToArray(a, b);
		this.dirty = !0
	},
	insertQuad: function(a, b) {
		cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
		this._totalQuads++;
		if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = b * c,
				e = (this._totalQuads - 1 - b) * c;
			this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c);
			this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c);
			this._setQuadToArray(a, b);
			this.dirty = !0
		}
	},
	insertQuads: function(a, b, c) {
		c = c || a.length;
		cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
		var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads += c;
		if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
		else {
			var e = b * d,
				f = (this._totalQuads - 1 - b - c) * d,
				k = this._totalQuads - 1 - c,
				m;
			for (m = 0; m < c; m++) this._quads[k + m] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
			this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * c);
			for (m = 0; m < c; m++) this._setQuadToArray(a[m], b + m);
			this.dirty = !0
		}
	},
	insertQuadFromIndex: function(a, b) {
		if (a !== b) {
			cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
			cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
			var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = this._quadsReader,
				e = d.subarray(a * c, c),
				f;
			a > b ? (f = b * c, d.set(d.subarray(f, f + (a - b) * c), f + c), d.set(e, f)) : (f = (a + 1) * c, d.set(d.subarray(f, f + (b - a) * c), f - c), d.set(e, b * c));
			this.dirty = !0
		}
	},
	removeQuadAtIndex: function(a) {
		cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
		var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
		this._totalQuads--;
		this._quads.length = this._totalQuads;
		if (a !== this._totalQuads) {
			var c = (a + 1) * b;
			this._quadsReader.set(this._quadsReader.subarray(c, c + (this._totalQuads - a) * b), c - b)
		}
		this.dirty = !0
	},
	removeQuadsAtIndex: function(a, b) {
		cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
		this._totalQuads -= b;
		if (a !== this._totalQuads) {
			var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
				d = (a + b) * c;
			this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), a * c)
		}
		this.dirty = !0
	},
	removeAllQuads: function() {
		this._totalQuads = this._quads.length = 0
	},
	_setDirty: function(a) {
		this.dirty = a
	},
	resizeCapacity: function(a) {
		if (a === this._capacity) return !0;
		var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			c = this._capacity;
		this._totalQuads = Math.min(this._totalQuads, a);
		var d = this._capacity = 0 | a,
			e = this._totalQuads;
		if (null === this._quads) {
			this._quads = [];
			this._quadsArrayBuffer = new ArrayBuffer(b * d);
			this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
			for (a = 0; a < d; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b)
		} else {
			var f, k, m = this._quads;
			if (d > c) {
				f = [];
				k = new ArrayBuffer(b * d);
				for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(m[a].tl, m[a].bl, m[a].tr, m[a].br, k, a * b);
				for (; a < d; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, k, a * b)
			} else {
				e = Math.max(e, d);
				f = [];
				k = new ArrayBuffer(b * d);
				for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(m[a].tl, m[a].bl, m[a].tr, m[a].br, k, a * b)
			}
			this._quadsReader = new Uint8Array(k);
			this._quads = f;
			this._quadsArrayBuffer = k
		}
		null === this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d);
		this._setupIndices();
		this._mapBuffers();
		return this.dirty = !0
	},
	increaseTotalQuadsWith: function(a) {
		this._totalQuads += a
	},
	moveQuadsFromIndex: function(a, b, c) {
		if (void 0 === c) {
			if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
		} else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a === c) return;
		var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			e = a * d,
			f = b * d,
			k = this._quadsReader,
			m = k.subarray(e, e + f),
			n = c * d;
		c < a ? (b = c * d, k.set(k.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, k.set(k.subarray(b, b + (c - a) * d), e));
		k.set(m, n);
		this.dirty = !0
	},
	fillWithEmptyQuadsFromIndex: function(a, b) {
		for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; e < c; e++) d[e] = 0
	},
	drawQuads: function() {
		this.drawNumberOfQuads(this._totalQuads, 0)
	},
	_releaseBuffer: function() {
		var a = cc._renderContext;
		this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
		this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
	}
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, b) {
	return new cc.TextureAtlas(a, b)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
	_className: "Scene",
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(0.5, 0.5);
		this.setContentSize(cc.director.getWinSize())
	}
});
cc.Scene.create = function() {
	return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
	_interval: null,
	_label: null,
	_className: "LoaderScene",
	cb: null,
	target: null,
	init: function() {
		var a = this,
			b = 200,
			c = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
		a.addChild(c, 0);
		var d = 24,
			e = -b / 2 + 100;
		cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
			isCrossOrigin: !1
		}, function(c, d) {
			b = d.height;
			a._initStage(d, cc.visibleRect.center)
		}), d = 14, e = -b / 2 - 10);
		d = a._label = new cc.LabelTTF("Loading... 0%", "Arial", d);
		d.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, e)));
		d.setColor(cc.color(180, 180, 180));
		c.addChild(this._label, 10);
		return !0
	},
	_initStage: function(a, b) {
		var c = this._texture2d = new cc.Texture2D;
		c.initWithElement(a);
		c.handleLoadedTexture();
		c = this._logo = new cc.Sprite(c);
		c.setScale(cc.contentScaleFactor());
		c.x = b.x;
		c.y = b.y;
		this._bgLayer.addChild(c, 10)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.schedule(this._startLoading, 0.3)
	},
	onExit: function() {
		cc.Node.prototype.onExit.call(this);
		this._label.setString("Loading... 0%")
	},
	initWithResources: function(a, b, c) {
		cc.isString(a) && (a = [a]);
		this.resources = a || [];
		this.cb = b;
		this.target = c
	},
	_startLoading: function() {
		var a = this;
		a.unschedule(a._startLoading);
		cc.loader.load(a.resources, function(b, c, d) {
			b = Math.min(100 * (d / c) | 0, 100);
			a._label.setString("Loading... " + b + "%")
		}, function() {
			a.cb && a.cb.call(a.target)
		})
	}
});
cc.LoaderScene.preload = function(a, b, c) {
	var d = cc;
	d.loaderScene || (d.loaderScene = new cc.LoaderScene, d.loaderScene.init());
	d.loaderScene.initWithResources(a, b, c);
	cc.director.runScene(d.loaderScene);
	return d.loaderScene
};
cc.Layer = cc.Node.extend({
	_className: "Layer",
	ctor: function() {
		var a = cc.Node.prototype;
		a.ctor.call(this);
		this._ignoreAnchorPointForPosition = !0;
		a.setAnchorPoint.call(this, 0.5, 0.5);
		a.setContentSize.call(this, cc.winSize)
	},
	init: function() {
		this._ignoreAnchorPointForPosition = !0;
		this.setAnchorPoint(0.5, 0.5);
		this.setContentSize(cc.winSize);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
		return !0
	},
	bake: function() {
		this._renderCmd.bake()
	},
	unbake: function() {
		this._renderCmd.unbake()
	},
	isBaked: function() {
		return this._renderCmd._isBaked
	},
	addChild: function(a, b, c) {
		cc.Node.prototype.addChild.call(this, a, b, c);
		this._renderCmd._bakeForAddChild(a)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
	}
});
cc.Layer.create = function() {
	return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
	_blendFunc: null,
	_className: "LayerColor",
	getBlendFunc: function() {
		return this._blendFunc
	},
	changeWidthAndHeight: function(a, b) {
		this.width = a;
		this.height = b
	},
	changeWidth: function(a) {
		this.width = a
	},
	changeHeight: function(a) {
		this.height = a
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	ctor: function(a, b, c) {
		cc.Layer.prototype.ctor.call(this);
		this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		cc.LayerColor.prototype.init.call(this, a, b, c)
	},
	init: function(a, b, c) {
		cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
		var d = cc.director.getWinSize();
		a = a || cc.color(0, 0, 0, 255);
		b = void 0 === b ? d.width : b;
		c = void 0 === c ? d.height : c;
		d = this._realColor;
		d.r = a.r;
		d.g = a.g;
		d.b = a.b;
		this._realOpacity = a.a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
		cc.LayerColor.prototype.setContentSize.call(this, b, c);
		return !0
	},
	setBlendFunc: function(a, b) {
		var c = this._blendFunc;
		void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
		this._renderCmd.updateBlendFunc(c)
	},
	_setWidth: function(a) {
		cc.Node.prototype._setWidth.call(this, a);
		this._renderCmd._updateSquareVerticesWidth(a)
	},
	_setHeight: function(a) {
		cc.Node.prototype._setHeight.call(this, a);
		this._renderCmd._updateSquareVerticesHeight(a)
	},
	setContentSize: function(a, b) {
		cc.Layer.prototype.setContentSize.call(this, a, b);
		this._renderCmd._updateSquareVertices(a, b)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
	}
});
cc.LayerColor.create = function(a, b, c) {
	return new cc.LayerColor(a, b, c)
};
(function() {
	var a = cc.LayerColor.prototype;
	cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
	cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
	_endColor: null,
	_startOpacity: 255,
	_endOpacity: 255,
	_alongVector: null,
	_compressedInterpolation: !1,
	_className: "LayerGradient",
	_colorStops: [],
	ctor: function(a, b, c, d) {
		cc.LayerColor.prototype.ctor.call(this);
		this._endColor = cc.color(0, 0, 0, 255);
		this._alongVector = cc.p(0, -1);
		this._endOpacity = this._startOpacity = 255;
		d && d instanceof Array ? (this._colorStops = d, d.splice(0, 0, {
			p: 0,
			color: a || cc.color.BLACK
		}), d.push({
			p: 1,
			color: b || cc.color.BLACK
		})) : this._colorStops = [{
			p: 0,
			color: a || cc.color.BLACK
		}, {
			p: 1,
			color: b || cc.color.BLACK
		}];
		cc.LayerGradient.prototype.init.call(this, a, b, c, d)
	},
	init: function(a, b, c, d) {
		a = a || cc.color(0, 0, 0, 255);
		b = b || cc.color(0, 0, 0, 255);
		c = c || cc.p(0, -1);
		d = this._endColor;
		this._startOpacity = a.a;
		d.r = b.r;
		d.g = b.g;
		d.b = b.b;
		this._endOpacity = b.a;
		this._alongVector = c;
		this._compressedInterpolation = !0;
		cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
		return !0
	},
	setContentSize: function(a, b) {
		cc.LayerColor.prototype.setContentSize.call(this, a, b);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setWidth: function(a) {
		cc.LayerColor.prototype._setWidth.call(this, a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	_setHeight: function(a) {
		cc.LayerColor.prototype._setHeight.call(this, a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getStartColor: function() {
		return cc.color(this._realColor)
	},
	setStartColor: function(a) {
		this.color = a;
		var b = this._colorStops;
		b && 0 < b.length && (b = b[0].color, b.r = a.r, b.g = a.g, b.b = a.b)
	},
	setEndColor: function(a) {
		var b = this._endColor;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		if ((b = this._colorStops) && 0 < b.length) b = b[b.length - 1].color, b.r = a.r, b.g = a.g, b.b = a.b;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	getEndColor: function() {
		return cc.color(this._endColor)
	},
	setStartOpacity: function(a) {
		this._startOpacity = a;
		var b = this._colorStops;
		b && 0 < b.length && (b[0].color.a = a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getStartOpacity: function() {
		return this._startOpacity
	},
	setEndOpacity: function(a) {
		this._endOpacity = a;
		var b = this._colorStops;
		b && 0 < b.length && (b[b.length - 1].color.a = a);
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getEndOpacity: function() {
		return this._endOpacity
	},
	setVector: function(a) {
		this._alongVector.x = a.x;
		this._alongVector.y = a.y;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getVector: function() {
		return cc.p(this._alongVector.x, this._alongVector.y)
	},
	isCompressedInterpolation: function() {
		return this._compressedInterpolation
	},
	setCompressedInterpolation: function(a) {
		this._compressedInterpolation = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
	},
	getColorStops: function() {
		return this._colorStops
	},
	setColorStops: function(a) {
		this._colorStops = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
	}
});
cc.LayerGradient.create = function(a, b, c, d) {
	return new cc.LayerGradient(a, b, c, d)
};
(function() {
	var a = cc.LayerGradient.prototype;
	cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
	cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
	cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
	cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
	cc.defineGetterSetter(a, "vector", a.getVector, a.setVector);
	cc.defineGetterSetter(a, "colorStops", a.getColorStops, a.setColorStops)
})();
cc.LayerMultiplex = cc.Layer.extend({
	_enabledLayer: 0,
	_layers: null,
	_className: "LayerMultiplex",
	ctor: function(a) {
		cc.Layer.prototype.ctor.call(this);
		a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
	},
	initWithLayers: function(a) {
		0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
		this._layers = a;
		this._enabledLayer = 0;
		this.addChild(this._layers[this._enabledLayer]);
		return !0
	},
	switchTo: function(a) {
		a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
	},
	switchToAndReleaseMe: function(a) {
		a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
	},
	addLayer: function(a) {
		a ? this._layers.push(a) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
	}
});
cc.LayerMultiplex.create = function() {
	return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function() {
	cc.Layer.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._isBaked = !1;
		this._bakeSprite = null;
		this._updateCache = 2
	};
	var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.Layer.CanvasRenderCmd;
	a._setCacheDirty = function(a) {
		a && 0 === this._updateCache && (this._updateCache = 2);
		!1 === this._cacheDirty && (this._cacheDirty = !0, (a = this._cachedParent) && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache())
	};
	a.transform = function(a, c) {
		var d = this._worldTransform,
			e = d.a,
			f = d.b,
			k = d.c,
			m = d.d;
		cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, c);
		if ((d.a !== e || d.b !== f || d.c !== k || d.d !== m) && 0 === this._updateCache) this._updateCache = 2
	};
	a.bake = function() {
		if (!this._isBaked) {
			this._needDraw = !0;
			this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
			0 === this._updateCache && (this._updateCache = 2);
			for (var a = this._node._children, c = 0, d = a.length; c < d; c++) a[c]._renderCmd._setCachedParent(this);
			this._bakeSprite || (this._bakeSprite = new cc.BakeSprite, this._bakeSprite.setAnchorPoint(0, 0))
		}
	};
	a.unbake = function() {
		if (this._isBaked) {
			cc.renderer.childrenOrderDirty = !0;
			this._isBaked = this._needDraw = !1;
			this._cacheDirty = !0;
			0 === this._updateCache && (this._updateCache = 2);
			for (var a = this._node._children, c = 0, d = a.length; c < d; c++) a[c]._renderCmd._setCachedParent(null)
		}
	};
	a.isBaked = function() {
		return this._isBaked
	};
	a.rendering = function() {
		if (this._cacheDirty) {
			var a = this._node,
				c = a._children,
				d = this._bakeSprite;
			this.transform(this.getParentRenderCmd(), !0);
			var e = this._getBoundingBoxForBake();
			e.width = 0 | e.width + 0.5;
			e.height = 0 | e.height + 0.5;
			var f = d.getCacheContext(),
				k = f.getContext();
			d.setPosition(e.x, e.y);
			if (0 < this._updateCache) {
				d.resetCanvasSize(e.width, e.height);
				f.setOffset(0 - e.x, k.canvas.height - e.height + e.y);
				a.sortAllChildren();
				cc.renderer._turnToCacheMode(this.__instanceId);
				a = 0;
				for (e = c.length; a < e; a++) c[a].visit(this);
				cc.renderer._renderingToCacheCanvas(f, this.__instanceId);
				d.transform();
				this._updateCache--
			}
			this._cacheDirty = !1
		}
	};
	a.visit = function(a) {
		if (this._isBaked) {
			var c = this._node,
				d = c._children.length;
			c._visible && 0 !== d && (this._syncStatus(a), cc.renderer.pushRenderCommand(this), this._cacheDirty = !0, 0 === this._updateCache && (this._updateCache = 2), this._bakeSprite.visit(this), this._dirtyFlag = 0)
		} else cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
	};
	a._bakeForAddChild = function(a) {
		a._parent === this._node && this._isBaked && a._renderCmd._setCachedParent(this)
	};
	a._getBoundingBoxForBake = function() {
		var a = null,
			c = this._node;
		if (!c._children || 0 === c._children.length) return cc.rect(0, 0, 10, 10);
		for (var d = c.getNodeToWorldTransform(), c = c._children, e = 0, f = c.length; e < f; e++) {
			var k = c[e];
			k && k._visible && (a ? (k = k._getBoundingBoxToCurrentNode(d)) && (a = cc.rectUnion(a, k)) : a = k._getBoundingBoxToCurrentNode(d))
		}
		return a
	}
})();
(function() {
	cc.LayerColor.CanvasRenderCmd = function(a) {
		cc.Layer.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._blendFuncStr = "source-over";
		this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
	};
	var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
	a.constructor = cc.LayerColor.CanvasRenderCmd;
	a.unbake = function() {
		cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
		this._needDraw = !0
	};
	a.rendering = function(a, c, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			k = this._displayedColor,
			m = this._displayedOpacity / 255,
			n = f._contentSize.width,
			f = f._contentSize.height;
		0 !== m && (a.setCompositeOperation(this._blendFuncStr), a.setGlobalAlpha(m), a.setFillStyle("rgba(" + (0 | k.r) + "," + (0 | k.g) + "," + (0 | k.b) + ", 1)"), a.setTransform(this._worldTransform, c, d), e.fillRect(0, 0, n * c, -f * d), cc.g_NumberOfDraws++)
	};
	a.updateBlendFunc = function(a) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
	};
	a._updateSquareVertices = a._updateSquareVerticesWidth = a._updateSquareVerticesHeight = function() {};
	a._bakeRendering = function() {
		if (this._cacheDirty) {
			var a = this._node,
				c = this._bakeSprite,
				d = a._children,
				e = d.length;
			this.transform(this.getParentRenderCmd(), !0);
			var f = this._getBoundingBoxForBake();
			f.width = 0 | f.width + 0.5;
			f.height = 0 | f.height + 0.5;
			var k = c.getCacheContext(),
				m = k.getContext();
			c.setPosition(f.x, f.y);
			if (0 < this._updateCache) {
				m.fillStyle = k._currentFillStyle;
				c.resetCanvasSize(f.width, f.height);
				k.setOffset(0 - f.x, m.canvas.height - f.height + f.y);
				cc.renderer._turnToCacheMode(this.__instanceId);
				if (0 < e) {
					a.sortAllChildren();
					for (a = 0; a < e; a++)
					if (f = d[a], 0 > f._localZOrder) f._renderCmd.visit(this);
					else break;
					for (cc.renderer.pushRenderCommand(this); a < e; a++) d[a]._renderCmd.visit(this)
				} else cc.renderer.pushRenderCommand(this);
				cc.renderer._renderingToCacheCanvas(k, this.__instanceId);
				c.transform();
				this._updateCache--
			}
			this._cacheDirty = !1
		}
	};
	a.visit = function(a) {
		this._isBaked ? this._node._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
	};
	a._getBoundingBoxForBake = function() {
		var a = this._node,
			c = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
			d = a.getNodeToWorldTransform(),
			c = cc.rectApplyAffineTransform(c, a.getNodeToWorldTransform());
		if (!a._children || 0 === a._children.length) return c;
		for (var a = a._children, e = 0; e < a.length; e++) {
			var f = a[e];
			f && f._visible && (f = f._getBoundingBoxToCurrentNode(d), c = cc.rectUnion(c, f))
		}
		return c
	}
})();
(function() {
	cc.LayerGradient.RenderCmd = {
		updateStatus: function() {
			var a = cc.Node._dirtyFlags,
				b = this._dirtyFlag,
				c = b & a.colorDirty,
				d = b & a.opacityDirty;
			c && this._updateDisplayColor();
			d && this._updateDisplayOpacity();
			(c || d || b & a.gradientDirty) && this._updateColor();
			b & a.transformDirty && this.transform(this.getParentRenderCmd(), !0);
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.LayerGradient.CanvasRenderCmd = function(a) {
		cc.LayerColor.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._startPoint = cc.p(0, 0);
		this._endPoint = cc.p(0, 0);
		this._endStopStr = this._startStopStr = null
	};
	var a = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, a);
	a.constructor = cc.LayerGradient.CanvasRenderCmd;
	a.rendering = function(a, c, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			k = this._displayedOpacity / 255;
		if (0 !== k) {
			var m = f._contentSize.width,
				n = f._contentSize.height;
			a.setCompositeOperation(this._blendFuncStr);
			a.setGlobalAlpha(k);
			k = e.createLinearGradient(this._startPoint.x * c, this._startPoint.y * d, this._endPoint.x * c, this._endPoint.y * d);
			if (f._colorStops) for (var p = 0; p < f._colorStops.length; p++) k.addColorStop(f._colorStops[p].p, this._colorStopsStr[p]);
			else k.addColorStop(0, this._startStopStr), k.addColorStop(1, this._endStopStr);
			a.setFillStyle(k);
			a.setTransform(this._worldTransform, c, d);
			e.fillRect(0, 0, m * c, -n * d);
			cc.g_NumberOfDraws++
		}
	};
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		var e = d & c.colorDirty,
			f = d & c.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		d & c.transformDirty && this.transform(a);
		(e || f || d & c.gradientDirty) && this._updateColor()
	};
	a._updateColor = function() {
		var a = this._node,
			c = a._contentSize,
			d = 0.5 * c.width,
			c = 0.5 * c.height;
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		var e = cc.pAngleSigned(cc.p(0, -1), a._alongVector),
			e = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), e),
			f = Math.min(Math.abs(1 / e.x), Math.abs(1 / e.y));
		this._startPoint.x = d * -e.x * f + d;
		this._startPoint.y = c * e.y * f - c;
		this._endPoint.x = d * e.x * f + d;
		this._endPoint.y = c * -e.y * f - c;
		d = this._displayedColor;
		c = a._endColor;
		e = a._startOpacity / 255;
		f = a._endOpacity / 255;
		this._startStopStr = "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + e.toFixed(4) + ")";
		this._endStopStr = "rgba(" + Math.round(c.r) + "," + Math.round(c.g) + "," + Math.round(c.b) + "," + f.toFixed(4) + ")";
		if (a._colorStops) {
			this._endOpacity = this._startOpacity = 0;
			this._colorStopsStr = [];
			for (d = 0; d < a._colorStops.length; d++) c = a._colorStops[d].color, e = null == c.a ? 1 : c.a / 255, this._colorStopsStr.push("rgba(" + Math.round(c.r) + "," + Math.round(c.g) + "," + Math.round(c.b) + "," + e.toFixed(4) + ")")
		}
	}
})();
(function() {
	cc.Layer.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a)
	};
	var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.Layer.WebGLRenderCmd;
	a.bake = function() {};
	a.unbake = function() {};
	a._bakeForAddChild = function() {}
})();
(function() {
	cc.LayerColor.WebGLRenderCmd = function(a) {
		cc.Layer.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._squareVerticesAB = new ArrayBuffer(32);
		this._squareColorsAB = new ArrayBuffer(16);
		a = this._squareVerticesAB;
		var c = this._squareColorsAB,
			d = cc.Vertex2F.BYTES_PER_ELEMENT,
			e = cc.Color.BYTES_PER_ELEMENT;
		this._squareVertices = [new cc.Vertex2F(0, 0, a, 0), new cc.Vertex2F(0, 0, a, d), new cc.Vertex2F(0, 0, a, 2 * d), new cc.Vertex2F(0, 0, a, 3 * d)];
		this._squareColors = [cc.color(0, 0, 0, 255, c, 0), cc.color(0, 0, 0, 255, c, e), cc.color(0, 0, 0, 255, c, 2 * e), cc.color(0, 0, 0, 255, c, 3 * e)];
		this._verticesFloat32Buffer = cc._renderContext.createBuffer();
		this._colorsUint8Buffer = cc._renderContext.createBuffer()
	};
	var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
	a.constructor = cc.LayerColor.WebGLRenderCmd;
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var c = this._node;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
		cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
		a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length)
	};
	a._updateSquareVertices = function(a, c) {
		var d = this._squareVertices;
		void 0 === c ? (d[1].x = a.width, d[2].y = a.height, d[3].x = a.width, d[3].y = a.height) : (d[1].x = a, d[2].y = c, d[3].x = a, d[3].y = c);
		this._bindLayerVerticesBufferData()
	};
	a._updateSquareVerticesWidth = function(a) {
		var c = this._squareVertices;
		c[1].x = a;
		c[3].x = a;
		this._bindLayerVerticesBufferData()
	};
	a._updateSquareVerticesHeight = function(a) {
		var c = this._squareVertices;
		c[2].y = a;
		c[3].y = a;
		this._bindLayerVerticesBufferData()
	};
	a._updateColor = function() {
		for (var a = this._displayedColor, c = this._displayedOpacity, d = this._squareColors, e = 0; 4 > e; e++) d[e].r = a.r, d[e].g = a.g, d[e].b = a.b, d[e].a = c;
		this._bindLayerColorsBufferData()
	};
	a._bindLayerVerticesBufferData = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
	};
	a._bindLayerColorsBufferData = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
	};
	a.updateBlendFunc = function(a) {}
})();
(function() {
	cc.LayerGradient.WebGLRenderCmd = function(a) {
		cc.LayerColor.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._clipRect = new cc.Rect;
		this._clippingRectDirty = !1
	};
	var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
	cc.inject(cc.LayerGradient.RenderCmd, a);
	a.constructor = cc.LayerGradient.WebGLRenderCmd;
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		var e = d & c.colorDirty,
			f = d & c.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		this.transform(a);
		(e || f || d & c.gradientDirty) && this._updateColor()
	};
	a._updateColor = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
		var a = this._node,
			c = a._colorStops;
		if (c && !(2 > c.length)) {
			this._clippingRectDirty = !0;
			var d = c.length,
				e = 2 * d,
				f, k = a._contentSize;
			this._squareVerticesAB = new ArrayBuffer(8 * e);
			this._squareColorsAB = new ArrayBuffer(4 * e);
			var m = this._squareVertices,
				n = this._squareColors;
			m.length = 0;
			n.length = 0;
			var p = this._squareVerticesAB,
				r = this._squareColorsAB,
				s = cc.Vertex2F.BYTES_PER_ELEMENT,
				u = cc.Color.BYTES_PER_ELEMENT;
			for (f = 0; f < e; f++) m.push(new cc.Vertex2F(0, 0, p, s * f)), n.push(cc.color(0, 0, 0, 255, r, u * f));
			r = Math.PI + cc.pAngleSigned(cc.p(0, -1), a._alongVector);
			a = cc.p(k.width / 2, k.height / 2);
			f = Math.round(cc.radiansToDegrees(r));
			e = cc.affineTransformMake(1, 0, 0, 1, a.x, a.y);
			e = cc.affineTransformRotate(e, r);
			90 > f ? (s = cc.p(-a.x, a.y), f = cc.p(a.x, a.y)) : 180 > f ? (s = cc.p(a.x, a.y), f = cc.p(a.x, -a.y)) : 270 > f ? (s = cc.p(a.x, -a.y), f = cc.p(-a.x, -a.y)) : (s = cc.p(-a.x, -a.y), f = cc.p(-a.x, a.y));
			p = Math.sin(r);
			r = Math.cos(r);
			s = Math.abs((s.x * r - s.y * p) / a.x);
			f = Math.abs((f.x * p + f.y * r) / a.y);
			e = cc.affineTransformScale(e, s, f);
			for (f = 0; f < d; f++) p = c[f].p * k.height, r = cc.pointApplyAffineTransform(-a.x, p - a.y, e), m[2 * f].x = r.x, m[2 * f].y = r.y, p = cc.pointApplyAffineTransform(k.width - a.x, p - a.y, e), m[2 * f + 1].x = p.x, m[2 * f + 1].y = p.y;
			k = this._displayedOpacity / 255;
			for (f = 0; f < d; f++) m = c[f].color, a = n[2 * f], e = n[2 * f + 1], a.r = m.r, a.g = m.g, a.b = m.b, a.a = m.a * k, e.r = m.r, e.g = m.g, e.b = m.b, e.a = m.a * k;
			this._bindLayerVerticesBufferData();
			this._bindLayerColorsBufferData()
		}
	};
	a.rendering = function(a) {
		a = a || cc._renderContext;
		var c = this._node,
			d = this._getClippingRect();
		a.enable(a.SCISSOR_TEST);
		cc.view.setScissorInPoints(d.x, d.y, d.width, d.height);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
		cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
		a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length);
		a.disable(a.SCISSOR_TEST)
	};
	a._getClippingRect = function() {
		if (this._clippingRectDirty) {
			var a = this._node,
				c = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
				a = a.getNodeToWorldTransform();
			this._clipRect = cc._rectApplyAffineTransformIn(c, a)
		}
		return this._clipRect
	}
})();
cc._tmp.PrototypeSprite = function() {
	var a = cc.Sprite.prototype;
	cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
	cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
	cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
	cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
	cc.defineGetterSetter(a, "texture", a.getTexture, a.setTexture);
	cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
	cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
	cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.Sprite = cc.Node.extend({
	dirty: !1,
	atlasIndex: 0,
	textureAtlas: null,
	_batchNode: null,
	_recursiveDirty: null,
	_hasChildren: null,
	_shouldBeHidden: !1,
	_transformToBatch: null,
	_blendFunc: null,
	_texture: null,
	_rect: null,
	_rectRotated: !1,
	_offsetPosition: null,
	_unflippedOffsetPositionFromCenter: null,
	_opacityModifyRGB: !1,
	_flippedX: !1,
	_flippedY: !1,
	_textureLoaded: !1,
	_className: "Sprite",
	ctor: function(a, b, c) {
		cc.Node.prototype.ctor.call(this);
		this._shouldBeHidden = !1;
		this._offsetPosition = cc.p(0, 0);
		this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._rect = cc.rect(0, 0, 0, 0);
		this._softInit(a, b, c)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, b) {
		this.addEventListener("load", a, b)
	},
	isDirty: function() {
		return this.dirty
	},
	setDirty: function(a) {
		this.dirty = a
	},
	isTextureRectRotated: function() {
		return this._rectRotated
	},
	getAtlasIndex: function() {
		return this.atlasIndex
	},
	setAtlasIndex: function(a) {
		this.atlasIndex = a
	},
	getTextureRect: function() {
		return cc.rect(this._rect)
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	setTextureAtlas: function(a) {
		this.textureAtlas = a
	},
	getOffsetPosition: function() {
		return cc.p(this._offsetPosition)
	},
	_getOffsetX: function() {
		return this._offsetPosition.x
	},
	_getOffsetY: function() {
		return this._offsetPosition.y
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	initWithSpriteFrame: function(a) {
		cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
		a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback, this));
		var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
			b = this.initWithTexture(a.getTexture(), a.getRect(), b);
		this.setSpriteFrame(a);
		return b
	},
	initWithSpriteFrameName: function(a) {
		cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
		var b = cc.spriteFrameCache.getSpriteFrame(a);
		cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
		return this.initWithSpriteFrame(b)
	},
	useBatchNode: function(a) {
		this.textureAtlas = a.getTextureAtlas();
		this._batchNode = a
	},
	setVertexRect: function(a) {
		var b = this._rect;
		b.x = a.x;
		b.y = a.y;
		b.width = a.width;
		b.height = a.height
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var a = this._children,
				b = a.length,
				c, d, e;
			for (c = 1; c < b; c++) {
				e = a[c];
				for (d = c - 1; 0 <= d;) {
					if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
					else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
					else break;
					d--
				}
				a[d + 1] = e
			}
			this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren);
			this._reorderChildDirty = !1
		}
	},
	reorderChild: function(a, b) {
		cc.assert(a, cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
	},
	removeChild: function(a, b) {
		this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
		cc.Node.prototype.removeChild.call(this, a, b)
	},
	setVisible: function(a) {
		cc.Node.prototype.setVisible.call(this, a);
		this._renderCmd.setDirtyRecursively(!0)
	},
	removeAllChildren: function(a) {
		var b = this._children,
			c = this._batchNode;
		if (c && null != b) for (var d = 0, e = b.length; d < e; d++) c.removeSpriteFromAtlas(b[d]);
		cc.Node.prototype.removeAllChildren.call(this, a);
		this._hasChildren = !1
	},
	ignoreAnchorPointForPosition: function(a) {
		this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
	},
	setFlippedX: function(a) {
		this._flippedX !== a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
	},
	setFlippedY: function(a) {
		this._flippedY !== a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
	},
	isFlippedX: function() {
		return this._flippedX
	},
	isFlippedY: function() {
		return this._flippedY
	},
	setOpacityModifyRGB: function(a) {
		this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setDisplayFrameWithAnimationName: function(a, b) {
		cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
		var c = cc.animationCache.getAnimation(a);
		c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
	},
	getBatchNode: function() {
		return this._batchNode
	},
	_setReorderChildDirtyRecursively: function() {
		if (!this._reorderChildDirty) {
			this._reorderChildDirty = !0;
			for (var a = this._parent; a && a !== this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
		}
	},
	getTexture: function() {
		return this._texture
	},
	_softInit: function(a, b, c) {
		if (void 0 === a) cc.Sprite.prototype.init.call(this);
		else if (cc.isString(a))"#" === a[0] ? (b = a.substr(1, a.length - 1), (b = cc.spriteFrameCache.getSpriteFrame(b)) ? this.initWithSpriteFrame(b) : cc.log("%s does not exist", a)) : cc.Sprite.prototype.init.call(this, a, b);
		else if ("object" === typeof a) if (a instanceof cc.Texture2D) this.initWithTexture(a, b, c);
		else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
		else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
	},
	getQuad: function() {
		return this._renderCmd.getQuad()
	},
	setBlendFunc: function(a, b) {
		var c = this._blendFunc;
		void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
		this._renderCmd.updateBlendFunc(c)
	},
	init: function() {
		if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
		cc.Node.prototype.init.call(this);
		this.dirty = this._recursiveDirty = !1;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this.texture = null;
		this._flippedX = this._flippedY = !1;
		this.anchorY = this.anchorX = 0.5;
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
		return !0
	},
	initWithFile: function(a, b) {
		cc.assert(a, cc._LogInfos.Sprite_initWithFile);
		var c = cc.textureCache.getTextureForKey(a);
		if (c) {
			if (!b) {
				var d = c.getContentSize();
				b = cc.rect(0, 0, d.width, d.height)
			}
			return this.initWithTexture(c, b)
		}
		c = cc.textureCache.addImage(a);
		return this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
	},
	initWithTexture: function(a, b, c, d) {
		cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
		c = c || !1;
		a = this._renderCmd._handleTextureForRotatedTexture(a, b, c, d);
		if (!cc.Node.prototype.init.call(this)) return !1;
		this._batchNode = null;
		this.dirty = this._recursiveDirty = !1;
		this._opacityModifyRGB = !0;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this._flippedX = this._flippedY = !1;
		this.setAnchorPoint(0.5, 0.5);
		this._offsetPosition.x = 0;
		this._offsetPosition.y = 0;
		this._hasChildren = !1;
		this._renderCmd._init();
		var e = a.isLoaded();
		this._textureLoaded = e;
		if (!e) return this._rectRotated = c, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeEventListener("load", this), a.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.texture = a, !0;
		b || (b = cc.rect(0, 0, a.width, a.height));
		this._renderCmd._checkTextureBoundary(a, b, c);
		this.setTexture(a);
		this.setTextureRect(b, c);
		this.setBatchNode(null);
		return !0
	},
	setTextureRect: function(a, b, c, d) {
		this._rectRotated = b || !1;
		this.setContentSize(c || a);
		this.setVertexRect(a);
		this._renderCmd._setTextureCoords(a, d);
		a = this._unflippedOffsetPositionFromCenter.x;
		b = this._unflippedOffsetPositionFromCenter.y;
		this._flippedX && (a = -a);
		this._flippedY && (b = -b);
		c = this._rect;
		this._offsetPosition.x = a + (this._contentSize.width - c.width) / 2;
		this._offsetPosition.y = b + (this._contentSize.height - c.height) / 2;
		this._batchNode ? this.dirty = !0 : this._renderCmd._resetForBatchNode()
	},
	updateTransform: function() {
		this._renderCmd.updateTransform()
	},
	addChild: function(a, b, c) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
		null == b && (b = a._localZOrder);
		null == c && (c = a.tag);
		this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, b, c), this._hasChildren = !0)
	},
	setSpriteFrame: function(a) {
		var b = this;
		cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
		this.setNodeDirty(!0);
		var c = a.getOffset();
		b._unflippedOffsetPositionFromCenter.x = c.x;
		b._unflippedOffsetPositionFromCenter.y = c.y;
		c = a.getTexture();
		a.textureLoaded() ? (c !== b._texture && (b.texture = c), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize())) : (b._textureLoaded = !1, a.addEventListener("load", function(a) {
			b._textureLoaded = !0;
			var c = a.getTexture();
			c !== b._texture && (b.texture = c);
			b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
			b.dispatchEvent("load");
			b.setColor(b.color)
		}, b));
		this._renderCmd._updateForSetSpriteFrame(c)
	},
	setDisplayFrame: function(a) {
		cc.log(cc._LogInfos.Sprite_setDisplayFrame);
		this.setSpriteFrame(a)
	},
	isFrameDisplayed: function(a) {
		return this._renderCmd.isFrameDisplayed(a)
	},
	displayFrame: function() {
		return this.getSpriteFrame()
	},
	getSpriteFrame: function() {
		return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
	},
	setBatchNode: function(a) {
		(this._batchNode = a) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
	},
	setTexture: function(a) {
		if (!a) return this._renderCmd._setTexture(null);
		var b = this._texture;
		cc.isString(a) ? (a = cc.textureCache.addImage(a), a._textureLoaded ? (this._renderCmd._setTexture(a), this._changeRectWithTexture(a, b), this.setColor(this._realColor), this._textureLoaded = !0) : a.addEventListener("load", function() {
			this._renderCmd._setTexture(a);
			this._changeRectWithTexture(a, b);
			this.setColor(this._realColor);
			this._textureLoaded = !0
		}, this)) : (cc.assert(a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._changeRectWithTexture(a, b), this._renderCmd._setTexture(a))
	},
	_changeRectWithTexture: function(a, b) {
		var c = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
			d = b ? b._contentSize : cc.size(),
			e = this._contentSize,
			f = c.width,
			k = c.height,
			m = d.width,
			d = d.height,
			n = e.width,
			e = e.height;
		if (c && (f || k)) {
			var p = this._rect;
			if (!(0 !== n && 0 !== e) || !(n !== m && e !== d) || !(m === f && d === k) || !(0 !== p.height || 0 !== p.width)) c.x = c.x || 0, c.y = c.y || 0, c.width = c.width || 0, c.height = c.height || 0, this.setTextureRect(c)
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
	}
});
cc.Sprite.create = function(a, b, c) {
	return new cc.Sprite(a, b, c)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
	cc.Sprite.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureCoord = {
			renderX: 0,
			renderY: 0,
			x: 0,
			y: 0,
			width: 0,
			height: 0,
			validRect: !1
		};
		this._blendFuncStr = "source-over";
		this._colorized = !1;
		this._originalTexture = null
	};
	var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.Sprite.CanvasRenderCmd;
	a._init = function() {};
	a.setDirtyRecursively = function(a) {};
	a._resetForBatchNode = function() {};
	a._setTexture = function(a) {
		var c = this._node;
		c._texture !== a && (a ? (a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), c._textureLoaded = a._textureLoaded) : c._textureLoaded = !1, c._texture = a)
	};
	a._setColorDirty = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
	};
	a.isFrameDisplayed = function(a) {
		var c = this._node;
		return a.getTexture() !== c._texture ? !1 : cc.rectEqualToRect(a.getRect(), c._rect)
	};
	a.updateBlendFunc = function(a) {
		this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
	};
	a._setBatchNodeForAddChild = function(a) {
		return !0
	};
	a._handleTextureForRotatedTexture = function(a, c, d, e) {
		d && a.isLoaded() && (a = a.getHtmlElementObj(), a = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(a, c, e), e = new cc.Texture2D, e.initWithElement(a), e.handleLoadedTexture(), a = e, c.x = c.y = 0, this._node._rect = cc.rect(0, 0, c.width, c.height));
		return a
	};
	a._checkTextureBoundary = function(a, c, d) {
		a && a.url && (d = c.y + c.height, c.x + c.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
		this._node._originalTexture = a
	};
	a.rendering = function(a, c, d) {
		var e = this._node,
			f = this._textureCoord,
			k = this._displayedOpacity / 255;
		if (!(e._texture && (0 === f.width || 0 === f.height || !e._texture._textureLoaded) || 0 === k)) {
			a = a || cc._renderContext;
			var m = a.getContext(),
				n = e._offsetPosition.x,
				p = e._rect.height,
				r = e._rect.width,
				s = -e._offsetPosition.y - p;
			a.setTransform(this._worldTransform, c, d);
			a.setCompositeOperation(this._blendFuncStr);
			a.setGlobalAlpha(k);
			(e._flippedX || e._flippedY) && a.save();
			e._flippedX && (n = -n - r, m.scale(-1, 1));
			e._flippedY && (s = e._offsetPosition.y, m.scale(1, -1));
			e._texture ? (k = e._texture._htmlElementObj, "" !== e._texture._pattern ? (a.setFillStyle(m.createPattern(k, e._texture._pattern)), m.fillRect(n * c, s * d, r * c, p * d)) : this._colorized ? m.drawImage(k, 0, 0, f.width, f.height, n * c, s * d, r * c, p * d) : m.drawImage(k, f.renderX, f.renderY, f.width, f.height, n * c, s * d, r * c, p * d)) : (k = e._contentSize, f.validRect && (f = this._displayedColor, a.setFillStyle("rgba(" + f.r + "," + f.g + "," + f.b + ",1)"), m.fillRect(n * c, s * d, k.width * c, k.height * d)));
			(e._flippedX || e._flippedY) && a.restore();
			cc.g_NumberOfDraws++
		}
	};
	a._updateColor = cc.sys._supportCanvasNewBlendModes ?
	function() {
		var a = this._node,
			c = this._displayedColor;
		if (255 === c.r && 255 === c.g && 255 === c.b) this._setOriginalTexture();
		else {
			var d, e = a._texture,
				f = this._textureCoord;
			if (e && (f.validRect && this._originalTexture) && (d = e.getHtmlElementObj())) this._colorized = !0, d instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj !== d ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, c, f, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, c, f), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(), a.setTexture(e))
		}
	} : function() {
		var a = this._node,
			c = this._displayedColor;
		if (255 === c.r && 255 === c.g && 255 === c.b) this._setOriginalTexture();
		else {
			var d, e = a._texture,
				f = this._textureCoord;
			if (e && (f.validRect && this._originalTexture) && (d = e.getHtmlElementObj())) if (e = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) this._colorized = !0, d instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, c, f, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, c, f), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(), a.texture = e)
		}
	};
	a._setOriginalTexture = function() {
		if (this._colorized) {
			this._colorized = !1;
			var a = this._node,
				c = cc.rect(a._rect),
				d = cc.size(a._contentSize),
				e = a._rectRotated;
			a.setTexture(this._originalTexture);
			a.setTextureRect(c, e, d)
		}
	};
	a.getQuad = function() {
		return null
	};
	a._updateForSetSpriteFrame = function(a, c) {
		this._originalTexture = a;
		this._colorized = !1;
		this._textureCoord.renderX = this._textureCoord.x;
		this._textureCoord.renderY = this._textureCoord.y;
		if (c = c || a._textureLoaded) {
			var d = this._node.getColor();
			(255 !== d.r || 255 !== d.g || 255 !== d.b) && this._updateColor()
		}
	};
	a.updateTransform = function() {
		var a = this._node;
		if (a.dirty) {
			var c = a._parent;
			!a._visible || c && c !== a._batchNode && c._shouldBeHidden ? a._shouldBeHidden = !0 : (a._shouldBeHidden = !1, a._transformToBatch = !c || c === a._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), c._transformToBatch));
			a._recursiveDirty = !1;
			a.dirty = !1
		}
		a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
	};
	a._updateDisplayColor = function(a) {
		cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a)
	};
	a._spriteFrameLoadedCallback = function(a) {
		this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
		this._renderCmd._updateColor();
		this.dispatchEvent("load")
	};
	a._textureLoadedCallback = function(a) {
		if (!this._textureLoaded) {
			this._textureLoaded = !0;
			var c = this._rect,
				d = this._renderCmd;
			c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height);
			this.texture = d._originalTexture = a;
			this.setTextureRect(c, this._rectRotated);
			a = d._displayedColor;
			(255 !== a.r || 255 !== a.g || 255 !== a.b) && d._updateColor();
			this.setBatchNode(this._batchNode);
			this.dispatchEvent("load")
		}
	};
	a._setTextureCoords = function(a, c) {
		void 0 === c && (c = !0);
		var d = this._textureCoord,
			e = c ? cc.contentScaleFactor() : 1;
		d.renderX = d.x = 0 | a.x * e;
		d.renderY = d.y = 0 | a.y * e;
		d.width = 0 | a.width * e;
		d.height = 0 | a.height * e;
		d.validRect = !(0 === d.width || 0 === d.height || 0 > d.x || 0 > d.y)
	};
	cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply = function(a, c, d, e) {
		e = e || cc.newElement("canvas");
		d = d || cc.rect(0, 0, a.width, a.height);
		var f = e.getContext("2d");
		e.width !== d.width || e.height !== d.height ? (e.width = d.width, e.height = d.height) : f.globalCompositeOperation = "source-over";
		f.fillStyle = "rgb(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ")";
		f.fillRect(0, 0, d.width, d.height);
		f.globalCompositeOperation = "multiply";
		f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
		f.globalCompositeOperation = "destination-atop";
		f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
		return e
	};
	cc.Sprite.CanvasRenderCmd._generateTintImage = function(a, c, d, e, f) {
		e || (e = cc.rect(0, 0, a.width, a.height));
		a = d.r / 255;
		var k = d.g / 255;
		d = d.b / 255;
		var m = Math.min(e.width, c[0].width),
			n = Math.min(e.height, c[0].height),
			p;
		f ? (p = f.getContext("2d"), p.clearRect(0, 0, m, n)) : (f = cc.newElement("canvas"), f.width = m, f.height = n, p = f.getContext("2d"));
		p.save();
		p.globalCompositeOperation = "lighter";
		var r = p.globalAlpha;
		0 < a && (p.globalAlpha = a * r, p.drawImage(c[0], e.x, e.y, m, n, 0, 0, m, n));
		0 < k && (p.globalAlpha = k * r, p.drawImage(c[1], e.x, e.y, m, n, 0, 0, m, n));
		0 < d && (p.globalAlpha = d * r, p.drawImage(c[2], e.x, e.y, m, n, 0, 0, m, n));
		1 > a + k + d && (p.globalAlpha = r, p.drawImage(c[3], e.x, e.y, m, n, 0, 0, m, n));
		p.restore();
		return f
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor = function(a) {
		function c() {
			var c = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor,
				e = a.width,
				m = a.height;
			d[0].width = e;
			d[0].height = m;
			d[1].width = e;
			d[1].height = m;
			d[2].width = e;
			d[2].height = m;
			d[3].width = e;
			d[3].height = m;
			c.canvas.width = e;
			c.canvas.height = m;
			var n = c.canvas.getContext("2d");
			n.drawImage(a, 0, 0);
			c.tempCanvas.width = e;
			c.tempCanvas.height = m;
			for (var n = n.getImageData(0, 0, e, m).data, p = 0; 4 > p; p++) {
				var r = d[p].getContext("2d");
				r.getImageData(0, 0, e, m).data;
				c.tempCtx.drawImage(a, 0, 0);
				for (var s = c.tempCtx.getImageData(0, 0, e, m), u = s.data, t = 0; t < n.length; t += 4) u[t] = 0 === p ? n[t] : 0, u[t + 1] = 1 === p ? n[t + 1] : 0, u[t + 2] = 2 === p ? n[t + 2] : 0, u[t + 3] = n[t + 3];
				r.putImageData(s, 0, 0)
			}
			a.onload = null
		}
		if (a.channelCache) return a.channelCache;
		var d = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
		try {
			c()
		} catch (e) {
			a.onload = c
		}
		return a.channelCache = d
	};
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.canvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
	cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCtx = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas.getContext("2d");
	cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(a, c, d) {
		if (!a) return null;
		if (!c) return a;
		d = null == d ? !0 : d;
		var e = cc.newElement("canvas");
		e.width = c.width;
		e.height = c.height;
		var f = e.getContext("2d");
		f.translate(e.width / 2, e.height / 2);
		d ? f.rotate(-1.5707963267948966) : f.rotate(1.5707963267948966);
		f.drawImage(a, c.x, c.y, c.height, c.width, -c.height / 2, -c.width / 2, c.height, c.width);
		return e
	}
})();
(function() {
	cc.Sprite.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._quad = new cc.V3F_C4B_T2F_Quad;
		this._quadWebBuffer = cc._renderContext.createBuffer();
		this._quadDirty = !0;
		this._recursiveDirty = this._dirty = !1
	};
	var a = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.Sprite.WebGLRenderCmd;
	a.updateBlendFunc = function(a) {};
	a.setDirtyFlag = function(a) {
		cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, a);
		this._dirty = !0
	};
	a.setDirtyRecursively = function(a) {
		this._dirty = this._recursiveDirty = a;
		for (var c = this._node._children, d, e = c ? c.length : 0, f = 0; f < e; f++) d = c[f], d instanceof cc.Sprite && d._renderCmd.setDirtyRecursively(a)
	};
	a._setBatchNodeForAddChild = function(a) {
		var c = this._node;
		if (c._batchNode) {
			if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
			a.texture._webTextureObj !== c.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
			c._batchNode.appendChild(a);
			c._reorderChildDirty || c._setReorderChildDirtyRecursively()
		}
		return !0
	};
	a._handleTextureForRotatedTexture = function(a) {
		return a
	};
	a.isFrameDisplayed = function(a) {
		var c = this._node;
		return cc.rectEqualToRect(a.getRect(), c._rect) && a.getTexture().getName() === c._texture.getName() && cc.pointEqualToPoint(a.getOffset(), c._unflippedOffsetPositionFromCenter)
	};
	a._init = function() {
		var a = {
			r: 255,
			g: 255,
			b: 255,
			a: 255
		},
			c = this._quad;
		c.bl.colors = a;
		c.br.colors = a;
		c.tl.colors = a;
		c.tr.colors = a;
		this._quadDirty = !0
	};
	a._resetForBatchNode = function() {
		var a = this._node,
			c = a._offsetPosition.x,
			d = a._offsetPosition.y,
			e = c + a._rect.width,
			a = d + a._rect.height,
			f = this._quad;
		f.bl.vertices = {
			x: c,
			y: d,
			z: 0
		};
		f.br.vertices = {
			x: e,
			y: d,
			z: 0
		};
		f.tl.vertices = {
			x: c,
			y: a,
			z: 0
		};
		f.tr.vertices = {
			x: e,
			y: a,
			z: 0
		};
		this._quadDirty = !0
	};
	a.getQuad = function() {
		return this._quad
	};
	a._updateForSetSpriteFrame = function() {};
	a._spriteFrameLoadedCallback = function(a) {
		this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
		this.dispatchEvent("load")
	};
	a._textureLoadedCallback = function(a) {
		var c = this._renderCmd;
		if (!this._textureLoaded) {
			this._textureLoaded = !0;
			var d = this._rect;
			d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
			this.texture = a;
			this.setTextureRect(d, this._rectRotated);
			this.setBatchNode(this._batchNode);
			c._quadDirty = !0;
			this.dispatchEvent("load")
		}
	};
	a._setTextureCoords = function(a, c) {
		void 0 === c && (c = !0);
		c && (a = cc.rectPointsToPixels(a));
		var d = this._node,
			e = d._batchNode ? d.textureAtlas.texture : d._texture;
		if (e) {
			var f = e.pixelsWidth,
				k = e.pixelsHeight,
				m, n, p = this._quad;
			d._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.height - 2) / (2 * f), m = (2 * a.y + 1) / (2 * k), k = m + (2 * a.width - 2) / (2 * k)) : (e = a.x / f, f = (a.x + a.height) / f, m = a.y / k, k = (a.y + a.width) / k), d._flippedX && (n = m, m = k, k = n), d._flippedY && (n = e, e = f, f = n), p.bl.texCoords.u = e, p.bl.texCoords.v = m, p.br.texCoords.u = e, p.br.texCoords.v = k, p.tl.texCoords.u = f, p.tl.texCoords.v = m, p.tr.texCoords.u = f, p.tr.texCoords.v = k) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.width - 2) / (2 * f), m = (2 * a.y + 1) / (2 * k), k = m + (2 * a.height - 2) / (2 * k)) : (e = a.x / f, f = (a.x + a.width) / f, m = a.y / k, k = (a.y + a.height) / k), d._flippedX && (n = e, e = f, f = n), d._flippedY && (n = m, m = k, k = n), p.bl.texCoords.u = e, p.bl.texCoords.v = k, p.br.texCoords.u = f, p.br.texCoords.v = k, p.tl.texCoords.u = e, p.tl.texCoords.v = m, p.tr.texCoords.u = f, p.tr.texCoords.v = m);
			this._quadDirty = !0
		}
	};
	a.transform = function(a, c) {
		cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, c);
		this._dirty = !0
	};
	a._setColorDirty = function() {};
	a._updateColor = function() {
		var a = this._displayedColor,
			c = this._displayedOpacity,
			d = this._node,
			a = {
				r: a.r,
				g: a.g,
				b: a.b,
				a: c
			};
		d._opacityModifyRGB && (a.r *= c / 255, a.g *= c / 255, a.b *= c / 255);
		c = this._quad;
		c.bl.colors = a;
		c.br.colors = a;
		c.tl.colors = a;
		c.tr.colors = a;
		d._batchNode && (d.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? d.textureAtlas.updateQuad(c, d.atlasIndex) : this._dirty = !0);
		this._quadDirty = !0
	};
	a._updateBlendFunc = function() {
		if (this._batchNode) cc.log(cc._LogInfos.Sprite__updateBlendFunc);
		else {
			var a = this._node;
			!a._texture || !a._texture.hasPremultipliedAlpha() ? (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, a.opacityModifyRGB = !1) : (a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst = cc.BLEND_DST, a.opacityModifyRGB = !0)
		}
	};
	a._setTexture = function(a) {
		var c = this._node;
		if (c._batchNode) {
			if (c._batchNode.texture !== a) {
				cc.log(cc._LogInfos.Sprite_setTexture);
				return
			}
		} else c._texture !== a && (c._textureLoaded = a ? a._textureLoaded : !1, c._texture = a, this._updateBlendFunc());
		this._shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR)
	};
	a.updateTransform = function() {
		var a = this._node;
		if (this._dirty) {
			var c = this._quad,
				d = a._parent;
			if (!a._visible || d && d !== a._batchNode && d._shouldBeHidden) c.br.vertices = c.tl.vertices = c.tr.vertices = c.bl.vertices = {
				x: 0,
				y: 0,
				z: 0
			}, a._shouldBeHidden = !0;
			else {
				a._shouldBeHidden = !1;
				0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
				a._transformToBatch = !d || d === a._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), d._transformToBatch);
				var e = a._transformToBatch,
					f = a._rect,
					d = a._offsetPosition.x,
					k = a._offsetPosition.y,
					m = d + f.width,
					n = k + f.height,
					p = e.tx,
					r = e.ty,
					s = e.a,
					u = e.b,
					t = e.d,
					w = -e.c,
					e = d * s - k * w + p,
					f = d * u + k * t + r,
					v = m * s - k * w + p,
					k = m * u + k * t + r,
					y = m * s - n * w + p,
					m = m * u + n * t + r,
					p = d * s - n * w + p,
					d = d * u + n * t + r,
					n = a._vertexZ;
				cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (e |= 0, f |= 0, v |= 0, k |= 0, y |= 0, m |= 0, p |= 0, d |= 0);
				c.bl.vertices = {
					x: e,
					y: f,
					z: n
				};
				c.br.vertices = {
					x: v,
					y: k,
					z: n
				};
				c.tl.vertices = {
					x: p,
					y: d,
					z: n
				};
				c.tr.vertices = {
					x: y,
					y: m,
					z: n
				}
			}
			a.textureAtlas.updateQuad(c, a.atlasIndex);
			this._dirty = a._recursiveDirty = !1
		}
		a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
	};
	a._checkTextureBoundary = function(a, c, d) {
		a && a.url && (d ? (d = c.x + c.height, c = c.y + c.width) : (d = c.x + c.width, c = c.y + c.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), c > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
	};
	a.rendering = function(a) {
		var c = this._node,
			d = c._texture;
		if (!(d && !d._textureLoaded || 0 === this._displayedOpacity)) if (a = a || cc._renderContext, d ? d._textureLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++, 0 !== cc.SPRITE_DEBUG_DRAW || c._showNode) cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || c._showNode ? (c = this._quad, c = [cc.p(c.tl.vertices.x, c.tl.vertices.y), cc.p(c.bl.vertices.x, c.bl.vertices.y), cc.p(c.br.vertices.x, c.br.vertices.y), cc.p(c.tr.vertices.x, c.tr.vertices.y)], cc._drawingUtil.drawPoly(c, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (d = c.getTextureRect(), c = c.getOffsetPosition(), c = [cc.p(c.x, c.y), cc.p(c.x + d.width, c.y), cc.p(c.x + d.width, c.y + d.height), cc.p(c.x, c.y + d.height)], cc._drawingUtil.drawPoly(c, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop()
	}
})();
cc.SpriteBatchNode = cc.Node.extend({
	_blendFunc: null,
	_descendants: null,
	_className: "SpriteBatchNode",
	ctor: function(a, b) {
		cc.Node.prototype.ctor.call(this);
		this._descendants = [];
		this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
		var c;
		b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		cc.isString(a) ? (c = cc.textureCache.getTextureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
		c && this.initWithTexture(c, b)
	},
	addSpriteWithoutQuad: function(a, b, c) {
		cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
		if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
		a.atlasIndex = b;
		var d = 0,
			e, f = this._descendants;
		if (f && 0 < f.length) {
			d = 0;
			for (e = f.length; d < e; d++) {
				var k = f[d];
				if (k && k.atlasIndex >= b) break
			}
		}
		f.splice(d, 0, a);
		cc.Node.prototype.addChild.call(this, a, b, c);
		this.reorderBatch(!1);
		return this
	},
	getTextureAtlas: function() {
		return this._renderCmd.getTextureAtlas()
	},
	setTextureAtlas: function(a) {
		this._renderCmd.getTextureAtlas(a)
	},
	getDescendants: function() {
		return this._descendants
	},
	initWithFile: function(a, b) {
		var c = cc.textureCache.getTextureForKey(a);
		c || (c = cc.textureCache.addImage(a));
		return this.initWithTexture(c, b)
	},
	_setNodeDirtyForCache: function() {
		this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
	},
	init: function(a, b) {
		var c = cc.textureCache.getTextureForKey(a);
		c || (c = cc.textureCache.addImage(a));
		return this.initWithTexture(c, b)
	},
	increaseAtlasCapacity: function() {
		this._renderCmd.increaseAtlasCapacity()
	},
	removeChildAtIndex: function(a, b) {
		this.removeChild(this._children[a], b)
	},
	rebuildIndexInOrder: function(a, b) {
		var c = a.children;
		if (c && 0 < c.length) for (var d = 0; d < c.length; d++) {
			var e = c[d];
			e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
		}!a === this && (a.atlasIndex = b, b++);
		if (c && 0 < c.length) for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
		return b
	},
	highestAtlasIndexInChild: function(a) {
		var b = a.children;
		return !b || 0 === b.length ? a.atlasIndex : this.highestAtlasIndexInChild(b[b.length - 1])
	},
	lowestAtlasIndexInChild: function(a) {
		var b = a.children;
		return !b || 0 === b.length ? a.atlasIndex : this.lowestAtlasIndexInChild(b[b.length - 1])
	},
	atlasIndexForChild: function(a, b) {
		var c = a.parent,
			d = c.children,
			e = d.indexOf(a),
			f = null;
		0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
		return c === this ? 0 === e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 === e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && 0 <= b ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
	},
	reorderBatch: function(a) {
		this._reorderChildDirty = a
	},
	setBlendFunc: function(a, b) {
		this._blendFunc = void 0 === b ? a : {
			src: a,
			dst: b
		}
	},
	getBlendFunc: function() {
		return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
	},
	reorderChild: function(a, b) {
		cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : b !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, b)
	},
	removeChild: function(a, b) {
		null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)))
	},
	updateQuadFromSprite: function(a, b) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
		a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
	},
	insertQuadFromSprite: function(a, b) {
		cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
		a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, b), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(), this._renderCmd.cutting(a, b)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
	},
	initWithTexture: function(a, b) {
		this._children.length = 0;
		this._descendants.length = 0;
		b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
		this._renderCmd.initWithTexture(a, b);
		return !0
	},
	insertChild: function(a, b) {
		a.batchNode = this;
		a.atlasIndex = b;
		a.dirty = !0;
		this._renderCmd.insertQuad(a, b);
		this._descendants.splice(b, 0, a);
		var c = b + 1,
			d = this._descendants;
		if (d && 0 < d.length) for (; c < d.length; c++) d[c].atlasIndex++;
		var d = a.children,
			e, f;
		if (d) {
			c = 0;
			for (f = d.length || 0; c < f; c++)
			if (e = d[c]) {
				var k = this.atlasIndexForChild(e, e.zIndex);
				this.insertChild(e, k)
			}
		}
	},
	appendChild: function(a) {
		this._reorderChildDirty = !0;
		a.batchNode = this;
		a.dirty = !0;
		this._descendants.push(a);
		var b = this._descendants.length - 1;
		a.atlasIndex = b;
		this._renderCmd.insertQuad(a, b);
		a = a.children;
		for (var b = 0, c = a.length || 0; b < c; b++) this.appendChild(a[b])
	},
	removeSpriteFromAtlas: function(a) {
		this._renderCmd.removeQuadAtIndex(a.atlasIndex);
		a.batchNode = null;
		var b = this._descendants,
			c = b.indexOf(a);
		if (-1 !== c) {
			b.splice(c, 1);
			for (var d = b.length; c < d; ++c) b[c].atlasIndex--
		}
		if (a = a.children) {
			b = 0;
			for (c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
		}
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	addChild: function(a, b, c) {
		cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
		this._renderCmd.isValidChild(a) && (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a))
	},
	removeAllChildren: function(a) {
		var b = this._descendants;
		if (b && 0 < b.length) for (var c = 0, d = b.length; c < d; c++) b[c] && (b[c].batchNode = null);
		cc.Node.prototype.removeAllChildren.call(this, a);
		this._descendants.length = 0;
		this._renderCmd.removeAllQuads()
	},
	sortAllChildren: function() {
		if (this._reorderChildDirty) {
			var a = this._children,
				b, c = 0,
				d = a.length,
				e;
			for (b = 1; b < d; b++) {
				var f = a[b],
					c = b - 1;
				for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder === e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[c + 1] = e, c -= 1, e = a[c];
				a[c + 1] = f
			}
			0 < a.length && (this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(a));
			this._reorderChildDirty = !1
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
	}
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function(a, b) {
	return new cc.SpriteBatchNode(a, b)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function() {
	cc.SpriteBatchNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._originalTexture = this._texture = null
	};
	var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
	a.checkAtlasCapacity = function() {};
	a.isValidChild = function(a) {
		return !(a instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : !0
	};
	a.initWithTexture = function(a, c) {
		this._texture = this._originalTexture = a
	};
	a.insertQuad = function(a, c) {};
	a.increaseAtlasCapacity = function() {};
	a.removeQuadAtIndex = function() {};
	a.removeAllQuads = function() {};
	a.getTexture = function() {
		return this._texture
	};
	a.setTexture = function(a) {
		this._texture = a;
		for (var c = this._node._children, d = 0; d < c.length; d++) c[d].setTexture(a)
	};
	a.updateChildrenAtlasIndex = function(a) {
		for (var c = this._node._descendants.length = 0, d = a.length; c < d; c++) this._updateAtlasIndex(a[c])
	};
	a._updateAtlasIndex = function(a) {
		var c = this._node._descendants,
			d = a.children,
			e, f = d.length;
		for (e = 0; e < f; e++)
		if (0 > d[e]._localZOrder) c.push(d[e]);
		else break;
		for (c.push(a); e < f; e++) c.push(d[e])
	};
	a.getTextureAtlas = function() {};
	a.setTextureAtlas = function(a) {};
	a.cutting = function(a, c) {
		this._node._children.splice(c, 0, a)
	}
})();
(function() {
	cc.SpriteBatchNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._textureAtlas = null
	};
	var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
	a.isValidChild = function(a) {
		return !(a instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0
	};
	a.rendering = function() {
		var a = this._node;
		0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
	};
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) {
			c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._dirtyFlag & cc.Node._dirtyFlags.transformDirty || this.transform(a);
			this.updateStatus(a);
			d.top = this._stackMatrix;
			c.sortAllChildren();
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.checkAtlasCapacity = function(a) {
		for (var c = this._textureAtlas; a >= c.capacity || c.capacity === c.totalQuads;) this.increaseAtlasCapacity()
	};
	a.increaseAtlasCapacity = function() {
		var a = this._textureAtlas.capacity,
			c = Math.floor(4 * (a + 1) / 3);
		cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, c);
		this._textureAtlas.resizeCapacity(c) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
	};
	a.initWithTexture = function(a, c) {
		this._textureAtlas = new cc.TextureAtlas;
		this._textureAtlas.initWithTexture(a, c);
		this._updateBlendFunc();
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a.insertQuad = function(a, c) {
		var d = this._textureAtlas;
		d.totalQuads >= d.capacity && this.increaseAtlasCapacity();
		d.insertQuad(a.quad, c)
	};
	a.removeQuadAtIndex = function(a) {
		this._textureAtlas.removeQuadAtIndex(a)
	};
	a.getTexture = function() {
		return this._textureAtlas.texture
	};
	a.setTexture = function(a) {
		this._textureAtlas.setTexture(a);
		a && this._updateBlendFunc()
	};
	a.removeAllQuads = function() {
		this._textureAtlas.removeAllQuads()
	};
	a._swap = function(a, c) {
		var d = this._node._descendants,
			e = this._textureAtlas,
			f = e.quads,
			k = d[a],
			m = cc.V3F_C4B_T2F_QuadCopy(f[a]);
		d[c].atlasIndex = a;
		d[a] = d[c];
		e.updateQuad(f[c], a);
		d[c] = k;
		e.updateQuad(m, c)
	};
	a._updateAtlasIndex = function(a, c) {
		var d = 0,
			e = a.children;
		e && (d = e.length);
		var f = 0;
		if (0 === d) f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++;
		else {
			f = !0;
			0 <= e[0].zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++, f = !1);
			for (d = 0; d < e.length; d++) {
				var k = e[d];
				f && 0 <= k.zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++, f = !1);
				c = this._updateAtlasIndex(k, c)
			}
			f && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++)
		}
		return c
	};
	a.updateChildrenAtlasIndex = function(a) {
		for (var c = 0, d = 0; d < a.length; d++) c = this._updateAtlasIndex(a[d], c)
	};
	a._updateBlendFunc = function() {
		if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
			var a = this._node._blendFunc;
			a.src = cc.SRC_ALPHA;
			a.dst = cc.ONE_MINUS_SRC_ALPHA
		}
	};
	a.getTextureAtlas = function() {
		return this._textureAtlas
	};
	a.setTextureAtlas = function(a) {
		a !== this._textureAtlas && (this._textureAtlas = a)
	};
	a.cutting = function() {}
})();
cc.BakeSprite = cc.Sprite.extend({
	_cacheCanvas: null,
	_cacheContext: null,
	ctor: function() {
		cc.Sprite.prototype.ctor.call(this);
		var a = document.createElement("canvas");
		a.width = a.height = 10;
		this._cacheCanvas = a;
		this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
		var b = new cc.Texture2D;
		b.initWithElement(a);
		b.handleLoadedTexture();
		this.setTexture(b)
	},
	getCacheContext: function() {
		return this._cacheContext
	},
	getCacheCanvas: function() {
		return this._cacheCanvas
	},
	resetCanvasSize: function(a, b) {
		var c = this._cacheCanvas,
			d = this._cacheContext,
			e = d._context.strokeStyle,
			f = d._context.fillStyle;
		void 0 === b && (b = a.height, a = a.width);
		c.width = a;
		c.height = b;
		e !== d._context.strokeStyle && (d._context.strokeStyle = e);
		f !== d._context.fillStyle && (d._context.fillStyle = f);
		this.getTexture().handleLoadedTexture();
		this.setTextureRect(cc.rect(0, 0, a, b), !1)
	}
});
cc.AnimationFrame = cc.Class.extend({
	_spriteFrame: null,
	_delayPerUnit: 0,
	_userInfo: null,
	ctor: function(a, b, c) {
		this._spriteFrame = a || null;
		this._delayPerUnit = b || 0;
		this._userInfo = c || null
	},
	clone: function() {
		var a = new cc.AnimationFrame;
		a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return a
	},
	copyWithZone: function(a) {
		return cc.clone(this)
	},
	copy: function(a) {
		a = new cc.AnimationFrame;
		a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
		return a
	},
	initWithSpriteFrame: function(a, b, c) {
		this._spriteFrame = a;
		this._delayPerUnit = b;
		this._userInfo = c;
		return !0
	},
	getSpriteFrame: function() {
		return this._spriteFrame
	},
	setSpriteFrame: function(a) {
		this._spriteFrame = a
	},
	getDelayUnits: function() {
		return this._delayPerUnit
	},
	setDelayUnits: function(a) {
		this._delayPerUnit = a
	},
	getUserInfo: function() {
		return this._userInfo
	},
	setUserInfo: function(a) {
		this._userInfo = a
	}
});
cc.AnimationFrame.create = function(a, b, c) {
	return new cc.AnimationFrame(a, b, c)
};
cc.Animation = cc.Class.extend({
	_frames: null,
	_loops: 0,
	_restoreOriginalFrame: !1,
	_duration: 0,
	_delayPerUnit: 0,
	_totalDelayUnits: 0,
	ctor: function(a, b, c) {
		this._frames = [];
		if (void 0 === a) this.initWithSpriteFrames(null, 0);
		else {
			var d = a[0];
			d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
		}
	},
	getFrames: function() {
		return this._frames
	},
	setFrames: function(a) {
		this._frames = a
	},
	addSpriteFrame: function(a) {
		var b = new cc.AnimationFrame;
		b.initWithSpriteFrame(a, 1, null);
		this._frames.push(b);
		this._totalDelayUnits++
	},
	addSpriteFrameWithFile: function(a) {
		a = cc.textureCache.addImage(a);
		var b = cc.rect(0, 0, 0, 0);
		b.width = a.width;
		b.height = a.height;
		a = new cc.SpriteFrame(a, b);
		this.addSpriteFrame(a)
	},
	addSpriteFrameWithTexture: function(a, b) {
		var c = new cc.SpriteFrame(a, b);
		this.addSpriteFrame(c)
	},
	initWithAnimationFrames: function(a, b, c) {
		cc.arrayVerifyType(a, cc.AnimationFrame);
		this._delayPerUnit = b;
		this._loops = void 0 === c ? 1 : c;
		this._totalDelayUnits = 0;
		b = this._frames;
		for (c = b.length = 0; c < a.length; c++) {
			var d = a[c];
			b.push(d);
			this._totalDelayUnits += d.getDelayUnits()
		}
		return !0
	},
	clone: function() {
		var a = new cc.Animation;
		a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		a.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return a
	},
	copyWithZone: function(a) {
		a = new cc.Animation;
		a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
		a.setRestoreOriginalFrame(this._restoreOriginalFrame);
		return a
	},
	_copyFrames: function() {
		for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
		return a
	},
	copy: function(a) {
		return this.copyWithZone(null)
	},
	getLoops: function() {
		return this._loops
	},
	setLoops: function(a) {
		this._loops = a
	},
	setRestoreOriginalFrame: function(a) {
		this._restoreOriginalFrame = a
	},
	getRestoreOriginalFrame: function() {
		return this._restoreOriginalFrame
	},
	getDuration: function() {
		return this._totalDelayUnits * this._delayPerUnit
	},
	getDelayPerUnit: function() {
		return this._delayPerUnit
	},
	setDelayPerUnit: function(a) {
		this._delayPerUnit = a
	},
	getTotalDelayUnits: function() {
		return this._totalDelayUnits
	},
	initWithSpriteFrames: function(a, b, c) {
		cc.arrayVerifyType(a, cc.SpriteFrame);
		this._loops = void 0 === c ? 1 : c;
		this._delayPerUnit = b || 0;
		this._totalDelayUnits = 0;
		b = this._frames;
		b.length = 0;
		if (a) {
			for (c = 0; c < a.length; c++) {
				var d = a[c],
					e = new cc.AnimationFrame;
				e.initWithSpriteFrame(d, 1, null);
				b.push(e)
			}
			this._totalDelayUnits += a.length
		}
		return !0
	},
	retain: function() {},
	release: function() {}
});
cc.Animation.create = function(a, b, c) {
	return new cc.Animation(a, b, c)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
	_animations: {},
	addAnimation: function(a, b) {
		this._animations[b] = a
	},
	removeAnimation: function(a) {
		a && this._animations[a] && delete this._animations[a]
	},
	getAnimation: function(a) {
		return this._animations[a] ? this._animations[a] : null
	},
	_addAnimationsWithDictionary: function(a, b) {
		var c = a.animations;
		if (c) {
			var d = 1,
				e = a.properties;
			if (e) for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, k = cc.path, m = 0; m < e.length; m++) f.addSpriteFrames(k.changeBasename(b, e[m]));
			switch (d) {
			case 1:
				this._parseVersion1(c);
				break;
			case 2:
				this._parseVersion2(c);
				break;
			default:
				cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
			}
		} else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
	},
	addAnimations: function(a) {
		cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
		var b = cc.loader.getRes(a);
		b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
	},
	_parseVersion1: function(a) {
		var b = cc.spriteFrameCache,
			c;
		for (c in a) {
			var d = a[c],
				e = d.frames,
				d = parseFloat(d.delay) || 0,
				f = null;
			if (e) {
				for (var f = [], k = 0; k < e.length; k++) {
					var m = b.getSpriteFrame(e[k]);
					if (m) {
						var n = new cc.AnimationFrame;
						n.initWithSpriteFrame(m, 1, null);
						f.push(n)
					} else cc.log(cc._LogInfos.animationCache__parseVersion1_2, c, e[k])
				}
				0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, c) : (f.length !== e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, c), f = new cc.Animation(f, d, 1), cc.animationCache.addAnimation(f, c))
			} else cc.log(cc._LogInfos.animationCache__parseVersion1, c)
		}
	},
	_parseVersion2: function(a) {
		var b = cc.spriteFrameCache,
			c;
		for (c in a) {
			var d = a[c],
				e = d.loop,
				f = parseInt(d.loops),
				e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
				f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1,
				k = d.frames;
			if (k) {
				for (var m = [], n = 0; n < k.length; n++) {
					var p = k[n],
						r = p.spriteframe,
						s = b.getSpriteFrame(r);
					if (s) {
						var r = parseFloat(p.delayUnits) || 0,
							p = p.notification,
							u = new cc.AnimationFrame;
						u.initWithSpriteFrame(s, r, p);
						m.push(u)
					} else cc.log(cc._LogInfos.animationCache__parseVersion2_2, c, r)
				}
				d = parseFloat(d.delayPerUnit) || 0;
				k = new cc.Animation;
				k.initWithAnimationFrames(m, d, e);
				k.setRestoreOriginalFrame(f);
				cc.animationCache.addAnimation(k, c)
			} else cc.log(cc._LogInfos.animationCache__parseVersion2, c)
		}
	},
	_clear: function() {
		this._animations = {}
	}
};
cc.SpriteFrame = cc.Class.extend({
	_offset: null,
	_originalSize: null,
	_rectInPixels: null,
	_rotated: !1,
	_rect: null,
	_offsetInPixels: null,
	_originalSizeInPixels: null,
	_texture: null,
	_textureFilename: "",
	_textureLoaded: !1,
	ctor: function(a, b, c, d, e) {
		this._offset = cc.p(0, 0);
		this._offsetInPixels = cc.p(0, 0);
		this._originalSize = cc.size(0, 0);
		this._rotated = !1;
		this._originalSizeInPixels = cc.size(0, 0);
		this._textureFilename = "";
		this._texture = null;
		this._textureLoaded = !1;
		void 0 !== a && void 0 !== b && (void 0 === c || void 0 === d || void 0 === e ? this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, b) {
		this.addEventListener("load", a, b)
	},
	getRectInPixels: function() {
		var a = this._rectInPixels;
		return cc.rect(a.x, a.y, a.width, a.height)
	},
	setRectInPixels: function(a) {
		this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
		this._rectInPixels.x = a.x;
		this._rectInPixels.y = a.y;
		this._rectInPixels.width = a.width;
		this._rectInPixels.height = a.height;
		this._rect = cc.rectPixelsToPoints(a)
	},
	isRotated: function() {
		return this._rotated
	},
	setRotated: function(a) {
		this._rotated = a
	},
	getRect: function() {
		var a = this._rect;
		return cc.rect(a.x, a.y, a.width, a.height)
	},
	setRect: function(a) {
		this._rect || (this._rect = cc.rect(0, 0, 0, 0));
		this._rect.x = a.x;
		this._rect.y = a.y;
		this._rect.width = a.width;
		this._rect.height = a.height;
		this._rectInPixels = cc.rectPointsToPixels(this._rect)
	},
	getOffsetInPixels: function() {
		return cc.p(this._offsetInPixels)
	},
	setOffsetInPixels: function(a) {
		this._offsetInPixels.x = a.x;
		this._offsetInPixels.y = a.y;
		cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
	},
	getOriginalSizeInPixels: function() {
		return cc.size(this._originalSizeInPixels)
	},
	setOriginalSizeInPixels: function(a) {
		this._originalSizeInPixels.width = a.width;
		this._originalSizeInPixels.height = a.height
	},
	getOriginalSize: function() {
		return cc.size(this._originalSize)
	},
	setOriginalSize: function(a) {
		this._originalSize.width = a.width;
		this._originalSize.height = a.height
	},
	getTexture: function() {
		if (this._texture) return this._texture;
		if ("" !== this._textureFilename) {
			var a = cc.textureCache.addImage(this._textureFilename);
			a && (this._textureLoaded = a.isLoaded());
			return a
		}
		return null
	},
	setTexture: function(a) {
		if (this._texture !== a) {
			var b = a.isLoaded();
			this._textureLoaded = b;
			this._texture = a;
			b || a.addEventListener("load", function(a) {
				this._textureLoaded = !0;
				if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
					var b = a.getHtmlElementObj(),
						b = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(b, this.getRect()),
						e = new cc.Texture2D;
					e.initWithElement(b);
					e.handleLoadedTexture();
					this.setTexture(e);
					b = this.getRect();
					this.setRect(cc.rect(0, 0, b.width, b.height))
				}
				b = this._rect;
				0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
				this.dispatchEvent("load")
			}, this)
		}
	},
	getOffset: function() {
		return cc.p(this._offset)
	},
	setOffset: function(a) {
		this._offset.x = a.x;
		this._offset.y = a.y
	},
	clone: function() {
		var a = new cc.SpriteFrame;
		a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		a.setTexture(this._texture);
		return a
	},
	copyWithZone: function() {
		var a = new cc.SpriteFrame;
		a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
		a.setTexture(this._texture);
		return a
	},
	copy: function() {
		return this.copyWithZone()
	},
	initWithTexture: function(a, b, c, d, e) {
		2 === arguments.length && (b = cc.rectPointsToPixels(b));
		d = d || cc.p(0, 0);
		e = e || b;
		c = c || !1;
		cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
		a = this.getTexture();
		this._rectInPixels = b;
		b = this._rect = cc.rectPixelsToPoints(b);
		if (a && a.url && a.isLoaded()) {
			var f, k;
			c ? (f = b.x + b.height, k = b.y + b.width) : (f = b.x + b.width, k = b.y + b.height);
			f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
			k > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
		}
		this._offsetInPixels.x = d.x;
		this._offsetInPixels.y = d.y;
		cc._pointPixelsToPointsOut(d, this._offset);
		this._originalSizeInPixels.width = e.width;
		this._originalSizeInPixels.height = e.height;
		cc._sizePixelsToPointsOut(e, this._originalSize);
		this._rotated = c;
		return !0
	}
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(a, b, c, d, e) {
	return new cc.SpriteFrame(a, b, c, d, e)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, c, d, e) {
	var f = new cc.SpriteFrame;
	f._texture = a;
	f._rectInPixels = b;
	f._rect = cc.rectPixelsToPoints(b);
	f._offsetInPixels.x = d.x;
	f._offsetInPixels.y = d.y;
	cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset);
	f._originalSizeInPixels.width = e.width;
	f._originalSizeInPixels.height = e.height;
	cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize);
	f._rotated = c;
	return f
};
cc.spriteFrameCache = {
	_CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
	_CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
	_spriteFrames: {},
	_spriteFramesAliases: {},
	_frameConfigCache: {},
	_rectFromString: function(a) {
		a = this._CCNS_REG2.exec(a);
		return !a ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4]))
	},
	_pointFromString: function(a) {
		a = this._CCNS_REG1.exec(a);
		return !a ? cc.p(0, 0) : cc.p(parseFloat(a[1]), parseFloat(a[2]))
	},
	_sizeFromString: function(a) {
		a = this._CCNS_REG1.exec(a);
		return !a ? cc.size(0, 0) : cc.size(parseFloat(a[1]), parseFloat(a[2]))
	},
	_getFrameConfig: function(a) {
		var b = cc.loader.getRes(a);
		cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
		cc.loader.release(a);
		if (b._inited) return this._frameConfigCache[a] = b;
		this._frameConfigCache[a] = this._parseFrameConfig(b);
		return this._frameConfigCache[a]
	},
	_getFrameConfigByJsonObject: function(a, b) {
		cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
		this._frameConfigCache[a] = this._parseFrameConfig(b);
		return this._frameConfigCache[a]
	},
	_parseFrameConfig: function(a) {
		var b = a.frames,
			c = a.metadata || a.meta;
		a = {};
		var d = {},
			e = 0;
		c && (e = c.format, e = 1 >= e.length ? parseInt(e) : e, d.image = c.textureFileName || c.textureFileName || c.image);
		for (var f in b) {
			var k = b[f];
			if (k) {
				c = {};
				if (0 == e) {
					c.rect = cc.rect(k.x, k.y, k.width, k.height);
					c.rotated = !1;
					c.offset = cc.p(k.offsetX, k.offsetY);
					var m = k.originalWidth,
						k = k.originalHeight;
					(!m || !k) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
					m = Math.abs(m);
					k = Math.abs(k);
					c.size = cc.size(m, k)
				} else if (1 == e || 2 == e) c.rect = this._rectFromString(k.frame), c.rotated = k.rotated || !1, c.offset = this._pointFromString(k.offset), c.size = this._sizeFromString(k.sourceSize);
				else if (3 == e) {
					var m = this._sizeFromString(k.spriteSize),
						n = this._rectFromString(k.textureRect);
					m && (n = cc.rect(n.x, n.y, m.width, m.height));
					c.rect = n;
					c.rotated = k.textureRotated || !1;
					c.offset = this._pointFromString(k.spriteOffset);
					c.size = this._sizeFromString(k.spriteSourceSize);
					c.aliases = k.aliases
				} else m = k.frame, n = k.sourceSize, f = k.filename || f, c.rect = cc.rect(m.x, m.y, m.w, m.h), c.rotated = k.rotated || !1, c.offset = cc.p(0, 0), c.size = cc.size(n.w, n.h);
				a[f] = c
			}
		}
		return {
			_inited: !0,
			frames: a,
			meta: d
		}
	},
	_addSpriteFramesByObject: function(a, b, c) {
		cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
		b && b.frames && (b = this._frameConfigCache[a] || this._getFrameConfigByJsonObject(a, b), this._createSpriteFrames(a, b, c))
	},
	_createSpriteFrames: function(a, b, c) {
		var d = b.frames;
		b = b.meta;
		c ? c instanceof cc.Texture2D || (cc.isString(c) ? c = cc.textureCache.addImage(c) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (c = cc.path.changeBasename(a, b.image || ".png"), c = cc.textureCache.addImage(c));
		a = this._spriteFramesAliases;
		b = this._spriteFrames;
		for (var e in d) {
			var f = d[e],
				k = b[e];
			if (!k) {
				k = new cc.SpriteFrame(c, f.rect, f.rotated, f.offset, f.size);
				if (f = f.aliases) for (var m = 0, n = f.length; m < n; m++) {
					var p = f[m];
					a[p] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, p);
					a[p] = e
				}
				cc._renderType === cc._RENDER_TYPE_CANVAS && k.isRotated() && k.getTexture().isLoaded() && (f = k.getTexture().getHtmlElementObj(), f = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(f, k.getRectInPixels()), m = new cc.Texture2D, m.initWithElement(f), m.handleLoadedTexture(), k.setTexture(m), f = k._rect, k.setRect(cc.rect(0, 0, f.width, f.height)));
				b[e] = k
			}
		}
	},
	addSpriteFrames: function(a, b) {
		cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
		var c = this._frameConfigCache[a] || cc.loader.getRes(a);
		c && c.frames && (c = this._frameConfigCache[a] || this._getFrameConfig(a), this._createSpriteFrames(a, c, b))
	},
	_checkConflict: function(a) {
		a = a.frames;
		for (var b in a) this._spriteFrames[b] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
	},
	addSpriteFrame: function(a, b) {
		this._spriteFrames[b] = a
	},
	removeSpriteFrames: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {}
	},
	removeSpriteFrameByName: function(a) {
		a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
	},
	removeSpriteFramesFromFile: function(a) {
		var b = this._spriteFrames,
			c = this._spriteFramesAliases;
		if (a = this._frameConfigCache[a]) {
			a = a.frames;
			for (var d in a)
			if (b[d]) {
				delete b[d];
				for (var e in c) c[e] === d && delete c[e]
			}
		}
	},
	removeSpriteFramesFromTexture: function(a) {
		var b = this._spriteFrames,
			c = this._spriteFramesAliases,
			d;
		for (d in b) {
			var e = b[d];
			if (e && e.getTexture() === a) {
				delete b[d];
				for (var f in c) c[f] === d && delete c[f]
			}
		}
	},
	getSpriteFrame: function(a) {
		var b = this._spriteFrames[a];
		if (!b) {
			var c = this._spriteFramesAliases[a];
			c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
		}
		return b
	},
	_clear: function() {
		this._spriteFrames = {};
		this._spriteFramesAliases = {};
		this._frameConfigCache = {}
	}
};
cc.configuration = {
	ERROR: 0,
	STRING: 1,
	INT: 2,
	DOUBLE: 3,
	BOOLEAN: 4,
	_maxTextureSize: 0,
	_maxModelviewStackDepth: 0,
	_supportsPVRTC: !1,
	_supportsNPOT: !1,
	_supportsBGRA8888: !1,
	_supportsDiscardFramebuffer: !1,
	_supportsShareableVAO: !1,
	_maxSamplesAllowed: 0,
	_maxTextureUnits: 0,
	_GlExtensions: "",
	_valueDict: {},
	_inited: !1,
	_init: function() {
		var a = this._valueDict;
		a["cocos2d.x.version"] = cc.ENGINE_VERSION;
		a["cocos2d.x.compiled_with_profiler"] = !1;
		a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
		this._inited = !0
	},
	getMaxTextureSize: function() {
		return this._maxTextureSize
	},
	getMaxModelviewStackDepth: function() {
		return this._maxModelviewStackDepth
	},
	getMaxTextureUnits: function() {
		return this._maxTextureUnits
	},
	supportsNPOT: function() {
		return this._supportsNPOT
	},
	supportsPVRTC: function() {
		return this._supportsPVRTC
	},
	supportsETC: function() {
		return !1
	},
	supportsS3TC: function() {
		return !1
	},
	supportsATITC: function() {
		return !1
	},
	supportsBGRA8888: function() {
		return this._supportsBGRA8888
	},
	supportsDiscardFramebuffer: function() {
		return this._supportsDiscardFramebuffer
	},
	supportsShareableVAO: function() {
		return this._supportsShareableVAO
	},
	checkForGLExtension: function(a) {
		return -1 < this._GlExtensions.indexOf(a)
	},
	getValue: function(a, b) {
		this._inited || this._init();
		var c = this._valueDict;
		return c[a] ? c[a] : b
	},
	setValue: function(a, b) {
		this._valueDict[a] = b
	},
	dumpInfo: function() {
		0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
	},
	gatherGPUInfo: function() {
		if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
			this._inited || this._init();
			var a = cc._renderContext,
				b = this._valueDict;
			b["gl.vendor"] = a.getParameter(a.VENDOR);
			b["gl.renderer"] = a.getParameter(a.RENDERER);
			b["gl.version"] = a.getParameter(a.VERSION);
			this._GlExtensions = "";
			for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
			this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
			b["gl.max_texture_size"] = this._maxTextureSize;
			this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			b["gl.max_texture_units"] = this._maxTextureUnits;
			this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
			b["gl.supports_PVRTC"] = this._supportsPVRTC;
			this._supportsNPOT = !1;
			b["gl.supports_NPOT"] = this._supportsNPOT;
			this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
			b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
			this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
			b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
			this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
			b["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
			cc.checkGLErrorDebug()
		}
	},
	loadConfigFile: function(a) {
		this._inited || this._init();
		var b = cc.loader.getRes(a);
		if (!b) throw Error("Please load the resource first : " + a);
		cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
		if (b = b.data) for (var c in b) this._valueDict[c] = b[c];
		else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
	}
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
	cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
	var b = new cc.math.Matrix4;
	cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
	a.multiply(b)
};
cc.Director = cc.Class.extend({
	_landscape: !1,
	_nextDeltaTimeZero: !1,
	_paused: !1,
	_purgeDirectorInNextLoop: !1,
	_sendCleanupToScene: !1,
	_animationInterval: 0,
	_oldAnimationInterval: 0,
	_projection: 0,
	_accumDt: 0,
	_contentScaleFactor: 1,
	_displayStats: !1,
	_deltaTime: 0,
	_frameRate: 0,
	_FPSLabel: null,
	_SPFLabel: null,
	_drawsLabel: null,
	_winSizeInPoints: null,
	_lastUpdate: null,
	_nextScene: null,
	_notificationNode: null,
	_openGLView: null,
	_scenesStack: null,
	_projectionDelegate: null,
	_runningScene: null,
	_frames: 0,
	_totalFrames: 0,
	_secondsPerFrame: 0,
	_dirtyRegion: null,
	_scheduler: null,
	_actionManager: null,
	_eventProjectionChanged: null,
	_eventAfterDraw: null,
	_eventAfterVisit: null,
	_eventAfterUpdate: null,
	ctor: function() {
		var a = this;
		a._lastUpdate = Date.now();
		cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
			a._lastUpdate = Date.now()
		})
	},
	init: function() {
		this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
		this._scenesStack = [];
		this._projection = cc.Director.PROJECTION_DEFAULT;
		this._projectionDelegate = null;
		this._frameRate = this._accumDt = 0;
		this._displayStats = !1;
		this._totalFrames = this._frames = 0;
		this._lastUpdate = Date.now();
		this._purgeDirectorInNextLoop = this._paused = !1;
		this._winSizeInPoints = cc.size(0, 0);
		this._openGLView = null;
		this._contentScaleFactor = 1;
		this._scheduler = new cc.Scheduler;
		cc.ActionManager ? (this._actionManager = new cc.ActionManager, this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null;
		this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
		this._eventAfterDraw.setUserData(this);
		this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
		this._eventAfterVisit.setUserData(this);
		this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
		this._eventAfterUpdate.setUserData(this);
		this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
		this._eventProjectionChanged.setUserData(this);
		return !0
	},
	calculateDeltaTime: function() {
		var a = Date.now();
		this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) / 1E3;
		0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
		this._lastUpdate = a
	},
	convertToGL: null,
	convertToUI: null,
	drawScene: function() {
		var a = cc.renderer;
		this.calculateDeltaTime();
		this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
		a.clear();
		this._nextScene && this.setNextScene();
		this._beforeVisitScene && this._beforeVisitScene();
		this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(), this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
		this._notificationNode && this._notificationNode.visit();
		this._displayStats && this._showStats();
		this._afterVisitScene && this._afterVisitScene();
		a.rendering(cc._renderContext);
		cc.eventManager.dispatchEvent(this._eventAfterDraw);
		this._totalFrames++;
		this._displayStats && this._calculateMPF()
	},
	_beforeVisitScene: null,
	_afterVisitScene: null,
	end: function() {
		this._purgeDirectorInNextLoop = !0
	},
	getContentScaleFactor: function() {
		return this._contentScaleFactor
	},
	getNotificationNode: function() {
		return this._notificationNode
	},
	getWinSize: function() {
		return cc.size(this._winSizeInPoints)
	},
	getWinSizeInPixels: function() {
		return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
	},
	getVisibleSize: null,
	getVisibleOrigin: null,
	getZEye: null,
	pause: function() {
		this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
	},
	popScene: function() {
		cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
		this._scenesStack.pop();
		var a = this._scenesStack.length;
		0 === a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
	},
	purgeCachedData: function() {
		cc.animationCache._clear();
		cc.spriteFrameCache._clear();
		cc.textureCache._clear()
	},
	purgeDirector: function() {
		this.getScheduler().unscheduleAll();
		cc.eventManager && cc.eventManager.setEnabled(!1);
		this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
		this._nextScene = this._runningScene = null;
		this._scenesStack.length = 0;
		this.stopAnimation();
		this.purgeCachedData();
		cc.checkGLErrorDebug()
	},
	pushScene: function(a) {
		cc.assert(a, cc._LogInfos.Director_pushScene);
		this._sendCleanupToScene = !1;
		this._scenesStack.push(a);
		this._nextScene = a
	},
	runScene: function(a) {
		cc.assert(a, cc._LogInfos.Director_pushScene);
		if (this._runningScene) {
			var b = this._scenesStack.length;
			0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
			this._nextScene = a
		} else this.pushScene(a), this.startAnimation()
	},
	resume: function() {
		this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
	},
	setContentScaleFactor: function(a) {
		a !== this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
	},
	setDepthTest: null,
	setClearColor: null,
	setDefaultValues: function() {},
	setNextDeltaTimeZero: function(a) {
		this._nextDeltaTimeZero = a
	},
	setNextScene: function() {
		var a = !1,
			b = !1;
		cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
		if (!b) {
			if (b = this._runningScene) b.onExitTransitionDidStart(), b.onExit();
			this._sendCleanupToScene && b && b.cleanup()
		}
		this._runningScene = this._nextScene;
		cc.renderer.childrenOrderDirty = !0;
		this._nextScene = null;
		!a && null !== this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
	},
	setNotificationNode: function(a) {
		this._notificationNode = a
	},
	getDelegate: function() {
		return this._projectionDelegate
	},
	setDelegate: function(a) {
		this._projectionDelegate = a
	},
	setOpenGLView: null,
	setProjection: null,
	setViewport: null,
	getOpenGLView: null,
	getProjection: null,
	setAlphaBlending: null,
	_showStats: function() {
		this._frames++;
		this._accumDt += this._deltaTime;
		this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
		cc.g_NumberOfDraws = 0
	},
	isSendCleanupToScene: function() {
		return this._sendCleanupToScene
	},
	getRunningScene: function() {
		return this._runningScene
	},
	getAnimationInterval: function() {
		return this._animationInterval
	},
	isDisplayStats: function() {
		return this._displayStats
	},
	setDisplayStats: function(a) {
		this._displayStats = a
	},
	getSecondsPerFrame: function() {
		return this._secondsPerFrame
	},
	isNextDeltaTimeZero: function() {
		return this._nextDeltaTimeZero
	},
	isPaused: function() {
		return this._paused
	},
	getTotalFrames: function() {
		return this._totalFrames
	},
	popToRootScene: function() {
		this.popToSceneStackLevel(1)
	},
	popToSceneStackLevel: function(a) {
		cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
		var b = this._scenesStack,
			c = b.length;
		if (0 === c) this.end();
		else if (!(a > c)) {
			for (; c > a;) {
				var d = b.pop();
				d.running && (d.onExitTransitionDidStart(), d.onExit());
				d.cleanup();
				c--
			}
			this._nextScene = b[b.length - 1];
			this._sendCleanupToScene = !1
		}
	},
	getScheduler: function() {
		return this._scheduler
	},
	setScheduler: function(a) {
		this._scheduler !== a && (this._scheduler = a)
	},
	getActionManager: function() {
		return this._actionManager
	},
	setActionManager: function(a) {
		this._actionManager !== a && (this._actionManager = a)
	},
	getDeltaTime: function() {
		return this._deltaTime
	},
	_createStatsLabel: null,
	_calculateMPF: function() {
		this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
	}
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
	invalid: !1,
	startAnimation: function() {
		this._nextDeltaTimeZero = !0;
		this.invalid = !1
	},
	mainLoop: function() {
		this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
	},
	stopAnimation: function() {
		this.invalid = !0
	},
	setAnimationInterval: function(a) {
		this._animationInterval = a;
		this.invalid || (this.stopAnimation(), this.startAnimation())
	}
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
	cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
	return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
	this._projection = a;
	cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setClearColor = function(a) {
	cc.renderer._clearColor = a;
	cc.renderer._clearFillStyle = "rgb(" + a.r + "," + a.g + "," + a.b + ")"
}, _p.setOpenGLView = function(a) {
	this._winSizeInPoints.width = cc._canvas.width;
	this._winSizeInPoints.height = cc._canvas.height;
	this._openGLView = a || cc.view;
	cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._createStatsLabel = function() {
	var a = 0,
		a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
	this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
	this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
	this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
	a = cc.DIRECTOR_STATS_POSITION;
	this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
	this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
	this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function() {
	return this.getWinSize()
}, _p.getVisibleOrigin = function() {
	return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
	cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage));
cc._renderType === cc._RENDER_TYPE_WEBGL &&
function() {
	cc.DirectorDelegate = cc.Class.extend({
		updateProjection: function() {}
	});
	var a = cc.Director.prototype;
	a.setProjection = function(a) {
		var c = this._winSizeInPoints;
		this.setViewport();
		var d = this._openGLView,
			e = d._viewPortRect.x / d._scaleX,
			f = d._viewPortRect.y / d._scaleY;
		switch (a) {
		case cc.Director.PROJECTION_2D:
			cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
			cc.kmGLLoadIdentity();
			d = cc.math.Matrix4.createOrthographicProjection(-e, c.width - e, -f, c.height - f, -1024, 1024);
			cc.kmGLMultMatrix(d);
			cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
			cc.kmGLLoadIdentity();
			break;
		case cc.Director.PROJECTION_3D:
			var k = this.getZEye(),
				m = new cc.math.Matrix4,
				d = new cc.math.Matrix4;
			cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
			cc.kmGLLoadIdentity();
			m = cc.math.Matrix4.createPerspectiveProjection(60, c.width / c.height, 0.1, 2 * k);
			cc.kmGLMultMatrix(m);
			cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
			cc.kmGLLoadIdentity();
			k = new cc.math.Vec3(-e + c.width / 2, -f + c.height / 2, k);
			c = new cc.math.Vec3(-e + c.width / 2, -f + c.height / 2, 0);
			e = new cc.math.Vec3(0, 1, 0);
			d.lookAt(k, c, e);
			cc.kmGLMultMatrix(d);
			break;
		case cc.Director.PROJECTION_CUSTOM:
			this._projectionDelegate && this._projectionDelegate.updateProjection();
			break;
		default:
			cc.log(cc._LogInfos.Director_setProjection)
		}
		this._projection = a;
		cc.eventManager.dispatchEvent(this._eventProjectionChanged);
		cc.setProjectionMatrixDirty();
		cc.renderer.childrenOrderDirty = !0
	};
	a.setDepthTest = function(a) {
		var c = cc._renderContext;
		a ? (c.clearDepth(1), c.enable(c.DEPTH_TEST), c.depthFunc(c.LEQUAL)) : c.disable(c.DEPTH_TEST)
	};
	a.setClearColor = function(a) {
		cc.renderer._clearColor = a
	};
	a.setOpenGLView = function(a) {
		this._winSizeInPoints.width = cc._canvas.width;
		this._winSizeInPoints.height = cc._canvas.height;
		this._openGLView = a || cc.view;
		a = cc.configuration;
		a.gatherGPUInfo();
		a.dumpInfo();
		this._createStatsLabel();
		this.setGLDefaultValues();
		cc.eventManager && cc.eventManager.setEnabled(!0)
	};
	a._clear = function() {
		var a = cc._renderContext;
		a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
	};
	a._beforeVisitScene = function() {
		cc.kmGLPushMatrix()
	};
	a._afterVisitScene = function() {
		cc.kmGLPopMatrix()
	};
	a._createStatsLabel = function() {
		if (cc.LabelAtlas) {
			if (!(null == cc.Director._fpsImageLoaded || !1 === cc.Director._fpsImageLoaded)) {
				var a = new cc.Texture2D;
				a.initWithElement(cc.Director._fpsImage);
				a.handleLoadedTexture();
				var c = cc.view.getDesignResolutionSize().height / 320;
				0 === c && (c = this._winSizeInPoints.height / 320);
				var d = new cc.LabelAtlas;
				d._setIgnoreContentScaleFactor(!0);
				d.initWithString("00.0", a, 12, 32, ".");
				d.scale = c;
				this._FPSLabel = d;
				d = new cc.LabelAtlas;
				d._setIgnoreContentScaleFactor(!0);
				d.initWithString("0.000", a, 12, 32, ".");
				d.scale = c;
				this._SPFLabel = d;
				d = new cc.LabelAtlas;
				d._setIgnoreContentScaleFactor(!0);
				d.initWithString("000", a, 12, 32, ".");
				d.scale = c;
				this._drawsLabel = d;
				a = cc.DIRECTOR_STATS_POSITION;
				this._drawsLabel.setPosition(a.x, 34 * c + a.y);
				this._SPFLabel.setPosition(a.x, 17 * c + a.y);
				this._FPSLabel.setPosition(a)
			}
		} else this._createStatsLabelForCanvas()
	};
	a._createStatsLabelForCanvas = function() {
		var a = 0,
			a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
		this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
		this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
		this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
		a = cc.DIRECTOR_STATS_POSITION;
		this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
		this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
		this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
	};
	a.convertToGL = function(a) {
		var c = new cc.math.Matrix4;
		cc.GLToClipTransform(c);
		var d = c.inverse(),
			c = c.mat[14] / c.mat[15],
			e = this._openGLView.getDesignResolutionSize();
		a = new cc.math.Vec3(2 * a.x / e.width - 1, 1 - 2 * a.y / e.height, c);
		a.transformCoord(d);
		return cc.p(a.x, a.y)
	};
	a.convertToUI = function(a) {
		var c = new cc.math.Matrix4;
		cc.GLToClipTransform(c);
		a = new cc.math.Vec3(a.x, a.y, 0);
		a.transformCoord(c);
		c = this._openGLView.getDesignResolutionSize();
		return cc.p(c.width * (0.5 * a.x + 0.5), c.height * (0.5 * -a.y + 0.5))
	};
	a.getVisibleSize = function() {
		return this._openGLView.getVisibleSize()
	};
	a.getVisibleOrigin = function() {
		return this._openGLView.getVisibleOrigin()
	};
	a.getZEye = function() {
		return this._winSizeInPoints.height / 1.1566
	};
	a.setViewport = function() {
		var a = this._openGLView;
		if (a) {
			var c = this._winSizeInPoints;
			a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, c.width, c.height)
		}
	};
	a.getOpenGLView = function() {
		return this._openGLView
	};
	a.getProjection = function() {
		return this._projection
	};
	a.setAlphaBlending = function(a) {
		a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
	};
	a.setGLDefaultValues = function() {
		this.setAlphaBlending(!0);
		this.setDepthTest(!1);
		this.setProjection(this._projection);
		cc._renderContext.clearColor(0, 0, 0, 0)
	}
}();
cc.Camera = cc.Class.extend({
	_eyeX: null,
	_eyeY: null,
	_eyeZ: null,
	_centerX: null,
	_centerY: null,
	_centerZ: null,
	_upX: null,
	_upY: null,
	_upZ: null,
	_dirty: !1,
	_lookupMatrix: null,
	ctor: function() {
		this._lookupMatrix = new cc.math.Matrix4;
		this.restore()
	},
	description: function() {
		return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
	},
	setDirty: function(a) {
		this._dirty = a
	},
	isDirty: function() {
		return this._dirty
	},
	restore: function() {
		this._eyeX = this._eyeY = 0;
		this._eyeZ = cc.Camera.getZEye();
		this._upX = this._centerX = this._centerY = this._centerZ = 0;
		this._upY = 1;
		this._upZ = 0;
		this._lookupMatrix.identity();
		this._dirty = !1
	},
	locate: function() {
		if (this._dirty) {
			var a = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
				b = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
				c = new cc.math.Vec3(this._upX, this._upY, this._upZ);
			this._lookupMatrix.lookAt(a, b, c);
			this._dirty = !1
		}
		cc.kmGLMultMatrix(this._lookupMatrix)
	},
	_locateForRenderer: function(a) {
		if (this._dirty) {
			var b = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
				c = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
				d = new cc.math.Vec3(this._upX, this._upY, this._upZ);
			this._lookupMatrix.lookAt(b, c, d);
			this._dirty = !1
		}
		a.multiply(this._lookupMatrix)
	},
	setEyeXYZ: function(a, b, c) {
		this.setEye(a, b, c)
	},
	setEye: function(a, b, c) {
		this._eyeX = a;
		this._eyeY = b;
		this._eyeZ = c;
		this._dirty = !0
	},
	setCenterXYZ: function(a, b, c) {
		this.setCenter(a, b, c)
	},
	setCenter: function(a, b, c) {
		this._centerX = a;
		this._centerY = b;
		this._centerZ = c;
		this._dirty = !0
	},
	setUpXYZ: function(a, b, c) {
		this.setUp(a, b, c)
	},
	setUp: function(a, b, c) {
		this._upX = a;
		this._upY = b;
		this._upZ = c;
		this._dirty = !0
	},
	getEyeXYZ: function(a, b, c) {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getEye: function() {
		return {
			x: this._eyeX,
			y: this._eyeY,
			z: this._eyeZ
		}
	},
	getCenterXYZ: function(a, b, c) {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getCenter: function() {
		return {
			x: this._centerX,
			y: this._centerY,
			z: this._centerZ
		}
	},
	getUpXYZ: function(a, b, c) {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	getUp: function() {
		return {
			x: this._upX,
			y: this._upY,
			z: this._upZ
		}
	},
	_DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
	return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(a, b, c, d, e, f, k) {
	this.prev = a;
	this.next = b;
	this.callback = c;
	this.target = d;
	this.priority = e;
	this.paused = f;
	this.markedForDeletion = k
};
cc.HashUpdateEntry = function(a, b, c, d, e) {
	this.list = a;
	this.entry = b;
	this.target = c;
	this.callback = d;
	this.hh = e
};
cc.HashTimerEntry = cc.hashSelectorEntry = function(a, b, c, d, e, f, k) {
	this.timers = a;
	this.target = b;
	this.timerIndex = c;
	this.currentTimer = d;
	this.currentTimerSalvaged = e;
	this.paused = f;
	this.hh = k
};
cc.Timer = cc.Class.extend({
	_scheduler: null,
	_elapsed: 0,
	_runForever: !1,
	_useDelay: !1,
	_timesExecuted: 0,
	_repeat: 0,
	_delay: 0,
	_interval: 0,
	getInterval: function() {
		return this._interval
	},
	setInterval: function(a) {
		this._interval = a
	},
	setupTimerWithInterval: function(a, b, c) {
		this._elapsed = -1;
		this._interval = a;
		this._delay = c;
		this._useDelay = 0 < this._delay;
		this._repeat = b;
		this._runForever = this._repeat === cc.REPEAT_FOREVER
	},
	trigger: function() {
		return 0
	},
	cancel: function() {
		return 0
	},
	ctor: function() {
		this._scheduler = null;
		this._elapsed = -1;
		this._useDelay = this._runForever = !1;
		this._interval = this._delay = this._repeat = this._timesExecuted = 0
	},
	update: function(a) {
		-1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted += 1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
	}
});
cc.TimerTargetSelector = cc.Timer.extend({
	_target: null,
	_selector: null,
	ctor: function() {
		this._selector = this._target = null
	},
	initWithSelector: function(a, b, c, d, e, f) {
		this._scheduler = a;
		this._target = c;
		this._selector = b;
		this.setupTimerWithInterval(d, e, f);
		return !0
	},
	getSelector: function() {
		return this._selector
	},
	trigger: function() {
		this._target && this._selector && this._target.call(this._selector, this._elapsed)
	},
	cancel: function() {
		this._scheduler.unschedule(this._selector, this._target)
	}
});
cc.TimerTargetCallback = cc.Timer.extend({
	_target: null,
	_callback: null,
	_key: null,
	ctor: function() {
		this._callback = this._target = null
	},
	initWithCallback: function(a, b, c, d, e, f, k) {
		this._scheduler = a;
		this._target = c;
		this._callback = b;
		this._key = d;
		this.setupTimerWithInterval(e, f, k);
		return !0
	},
	getCallback: function() {
		return this._callback
	},
	getKey: function() {
		return this._key
	},
	trigger: function() {
		this._callback && this._callback.call(this._target, this._elapsed)
	},
	cancel: function() {
		this._scheduler.unschedule(this._callback, this._target)
	}
});
cc.Scheduler = cc.Class.extend({
	_timeScale: 1,
	_updatesNegList: null,
	_updates0List: null,
	_updatesPosList: null,
	_hashForTimers: null,
	_arrayForTimers: null,
	_hashForUpdates: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_updateHashLocked: !1,
	ctor: function() {
		this._timeScale = 1;
		this._updatesNegList = [];
		this._updates0List = [];
		this._updatesPosList = [];
		this._hashForUpdates = {};
		this._hashForTimers = {};
		this._currentTarget = null;
		this._updateHashLocked = this._currentTargetSalvaged = !1;
		this._arrayForTimers = []
	},
	_schedulePerFrame: function(a, b, c, d) {
		var e = this._hashForUpdates[b.__instanceId];
		if (e && e.entry) if (e.entry.priority !== c) {
			if (this._updateHashLocked) {
				cc.log("warning: you CANNOT change update priority in scheduled function");
				e.entry.markedForDeletion = !1;
				e.entry.paused = d;
				return
			}
			this.unscheduleUpdate(b)
		} else {
			e.entry.markedForDeletion = !1;
			e.entry.paused = d;
			return
		}
		0 === c ? this._appendIn(this._updates0List, a, b, d) : 0 > c ? this._priorityIn(this._updatesNegList, a, b, c, d) : this._priorityIn(this._updatesPosList, a, b, c, d)
	},
	_removeHashElement: function(a) {
		delete this._hashForTimers[a.target.__instanceId];
		cc.arrayRemoveObject(this._arrayForTimers, a);
		a.Timer = null;
		a.target = null
	},
	_removeUpdateFromHash: function(a) {
		if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], a.entry = null, a.target = null
	},
	_priorityIn: function(a, b, c, d, e) {
		b = new cc.ListEntry(null, null, b, c, d, e, !1);
		if (a) {
			e = a.length - 1;
			for (var f = 0; f <= e && !(d < a[f].priority); f++);
			a.splice(f, 0, b)
		} else a = [], a.push(b);
		this._hashForUpdates[c.__instanceId] = new cc.HashUpdateEntry(a, b, c, null);
		return a
	},
	_appendIn: function(a, b, c, d) {
		b = new cc.ListEntry(null, null, b, c, 0, d, !1);
		a.push(b);
		this._hashForUpdates[c.__instanceId] = new cc.HashUpdateEntry(a, b, c, null, null)
	},
	setTimeScale: function(a) {
		this._timeScale = a
	},
	getTimeScale: function() {
		return this._timeScale
	},
	update: function(a) {
		this._updateHashLocked = !0;
		1 !== this._timeScale && (a *= this._timeScale);
		var b, c, d, e;
		b = 0;
		c = this._updatesNegList;
		for (d = c.length; b < d; b++) e = c[b], !e.paused && !e.markedForDeletion && e.callback(a);
		b = 0;
		c = this._updates0List;
		for (d = c.length; b < d; b++) e = c[b], !e.paused && !e.markedForDeletion && e.callback(a);
		b = 0;
		c = this._updatesPosList;
		for (d = c.length; b < d; b++) e = c[b], !e.paused && !e.markedForDeletion && e.callback(a);
		d = this._arrayForTimers;
		for (b = 0; b < d.length; b++) {
			this._currentTarget = c = d[b];
			this._currentTargetSalvaged = !1;
			if (!c.paused) for (c.timerIndex = 0; c.timerIndex < c.timers.length; ++c.timerIndex) c.currentTimer = c.timers[c.timerIndex], c.currentTimerSalvaged = !1, c.currentTimer.update(a), c.currentTimer = null;
			this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && this._removeHashElement(this._currentTarget)
		}
		b = 0;
		for (c = this._updatesNegList; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
		b = 0;
		for (c = this._updates0List; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
		b = 0;
		for (c = this._updatesPosList; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
		this._updateHashLocked = !1;
		this._currentTarget = null
	},
	scheduleCallbackForTarget: function(a, b, c, d, e, f) {
		this.schedule(b, a, c, d, e, f, a.__instanceId + "")
	},
	schedule: function(a, b, c, d, e, f, k) {
		var m = !1;
		if ("function" !== typeof a) var n = a,
			m = !0;
		!1 === m ? 5 === arguments.length && (k = e, f = d, e = 0, d = cc.REPEAT_FOREVER) : 4 === arguments.length && (f = d, d = cc.REPEAT_FOREVER, e = 0);
		cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
		!1 === m && cc.assert(k, "key should not be empty!");
		var p = this._hashForTimers[b.__instanceId];
		p ? cc.assert(p.paused === f, "") : (p = new cc.HashTimerEntry(null, b, 0, null, null, f, null), this._arrayForTimers.push(p), this._hashForTimers[b.__instanceId] = p);
		var r, s;
		if (null == p.timers) p.timers = [];
		else if (!1 === m) for (s = 0; s < p.timers.length; s++) {
			if (r = p.timers[s], a === r._callback) {
				cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, r.getInterval().toFixed(4), c.toFixed(4));
				r._interval = c;
				return
			}
		} else for (s = 0; s < p.timers.length; ++s)
		if ((r = p.timers[s]) && n === r.getSelector()) {
			cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", r.getInterval(), c);
			r.setInterval(c);
			return
		}!1 === m ? (r = new cc.TimerTargetCallback, r.initWithCallback(this, a, b, k, c, d, e)) : (r = new cc.TimerTargetSelector, r.initWithSelector(this, n, b, c, d, e));
		p.timers.push(r)
	},
	scheduleUpdate: function(a, b, c) {
		this._schedulePerFrame(function(b) {
			a.update(b)
		}, a, b, c)
	},
	_getUnscheduleMark: function(a, b) {
		switch (typeof a) {
		case "number":
		case "string":
			return a === b.getKey();
		case "function":
			return a === b._callback;
		default:
			return a === b.getSelector()
		}
	},
	unschedule: function(a, b) {
		if (b && a) {
			var c = this._hashForTimers[b.__instanceId];
			if (c) for (var d = c.timers, e = 0, f = d.length; e < f; e++) {
				var k = d[e];
				if (this._getUnscheduleMark(a, k)) {
					k === c.currentTimer && !c.currentTimerSalvaged && (c.currentTimerSalvaged = !0);
					d.splice(e, 1);
					c.timerIndex >= e && c.timerIndex--;
					0 === d.length && (this._currentTarget === c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
					break
				}
			}
		}
	},
	unscheduleUpdate: function(a) {
		if (null != a && (a = this._hashForUpdates[a.__instanceId])) this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)
	},
	unscheduleAllForTarget: function(a) {
		if (null != a) {
			var b = this._hashForTimers[a.__instanceId];
			b && (-1 < b.timers.indexOf(b.currentTimer) && !b.currentTimerSalvaged && (b.currentTimerSalvaged = !0), b.timers.length = 0, this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b));
			this.unscheduleUpdate(a)
		}
	},
	unscheduleAll: function() {
		this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	unscheduleAllWithMinPriority: function(a) {
		var b, c, d = this._arrayForTimers;
		for (b = d.length - 1; 0 <= b; b--) c = d[b], this.unscheduleAllForTarget(c.target);
		d = 0;
		if (0 > a) for (b = 0; b < this._updatesNegList.length;) d = this._updatesNegList.length, (c = this._updatesNegList[b]) && c.priority >= a && this.unscheduleUpdate(c.target), d == this._updatesNegList.length && b++;
		if (0 >= a) for (b = 0; b < this._updates0List.length;) d = this._updates0List.length, (c = this._updates0List[b]) && this.unscheduleUpdate(c.target), d == this._updates0List.length && b++;
		for (b = 0; b < this._updatesPosList.length;) d = this._updatesPosList.length, (c = this._updatesPosList[b]) && c.priority >= a && this.unscheduleUpdate(c.target), d == this._updatesPosList.length && b++
	},
	isScheduled: function(a, b) {
		cc.assert(a, "Argument key must not be empty");
		cc.assert(b, "Argument target must be non-nullptr");
		var c = this._hashForUpdates[b.__instanceId];
		if (!c) return !1;
		if (null != c.timers) for (var c = c.timers, d = 0; d < c.length; ++d)
		if (a === c[d].getKey()) return !0;
		return !1
	},
	pauseAllTargets: function() {
		return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	pauseAllTargetsWithMinPriority: function(a) {
		var b = [],
			c, d = this._arrayForTimers,
			e, f;
		e = 0;
		for (f = d.length; e < f; e++)
		if (c = d[e]) c.paused = !0, b.push(c.target);
		if (0 > a) for (e = 0; e < this._updatesNegList.length; e++)
		if ((c = this._updatesNegList[e]) && c.priority >= a) c.paused = !0, b.push(c.target);
		if (0 >= a) for (e = 0; e < this._updates0List.length; e++)
		if (c = this._updates0List[e]) c.paused = !0, b.push(c.target);
		for (e = 0; e < this._updatesPosList.length; e++)
		if ((c = this._updatesPosList[e]) && c.priority >= a) c.paused = !0, b.push(c.target);
		return b
	},
	resumeTargets: function(a) {
		if (a) for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
	},
	pauseTarget: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
		var b = this._hashForTimers[a.__instanceId];
		b && (b.paused = !0);
		if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !0
	},
	resumeTarget: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
		var b = this._hashForTimers[a.__instanceId];
		b && (b.paused = !1);
		if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !1
	},
	isTargetPaused: function(a) {
		cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
		var b = this._hashForTimers[a.__instanceId];
		return b ? b.paused : (a = this._hashForUpdates[a.__instanceId]) ? a.entry.paused : !1
	},
	scheduleUpdateForTarget: function(a, b, c) {
		this.scheduleUpdate(a, b, c)
	},
	unscheduleCallbackForTarget: function(a, b) {
		this.unschedule(b, a)
	},
	unscheduleUpdateForTarget: function(a) {
		this.unscheduleUpdate(a)
	},
	unscheduleAllCallbacksForTarget: function(a) {
		this.unschedule(a.__instanceId + "", a)
	},
	unscheduleAllCallbacks: function() {
		this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
	},
	unscheduleAllCallbacksWithMinPriority: function(a) {
		this.unscheduleAllWithMinPriority(a)
	}
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
	_cacheArray: [],
	_renderContext: null,
	ctor: function(a) {
		this._renderContext = a
	},
	drawPoint: function(a, b) {
		b || (b = 1);
		var c = cc.view.getScaleX(),
			d = cc.view.getScaleY(),
			d = cc.p(a.x * c, a.y * d),
			e = this._renderContext.getContext();
		e.beginPath();
		e.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1);
		e.closePath();
		e.fill()
	},
	drawPoints: function(a, b, c) {
		if (null != a) {
			c || (c = 1);
			b = this._renderContext.getContext();
			var d = cc.view.getScaleX(),
				e = cc.view.getScaleY();
			b.beginPath();
			for (var f = 0, k = a.length; f < k; f++) b.arc(a[f].x * d, -a[f].y * e, c * d, 0, 2 * Math.PI, !1);
			b.closePath();
			b.fill()
		}
	},
	drawLine: function(a, b) {
		var c = this._renderContext.getContext(),
			d = cc.view.getScaleX(),
			e = cc.view.getScaleY();
		c.beginPath();
		c.moveTo(a.x * d, -a.y * e);
		c.lineTo(b.x * d, -b.y * e);
		c.closePath();
		c.stroke()
	},
	drawRect: function(a, b) {
		this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
		this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
		this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
		this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
	},
	drawSolidRect: function(a, b, c) {
		a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
		this.drawSolidPoly(a, 4, c)
	},
	drawPoly: function(a, b, c, d) {
		d = d || !1;
		if (null != a) {
			if (3 > a.length) throw Error("Polygon's point must greater than 2");
			var e = a[0];
			b = this._renderContext.getContext();
			var f = cc.view.getScaleX(),
				k = cc.view.getScaleY();
			b.beginPath();
			b.moveTo(e.x * f, -e.y * k);
			for (var e = 1, m = a.length; e < m; e++) b.lineTo(a[e].x * f, -a[e].y * k);
			c && b.closePath();
			d ? b.fill() : b.stroke()
		}
	},
	drawSolidPoly: function(a, b, c) {
		this.setDrawColor(c.r, c.g, c.b, c.a);
		this.drawPoly(a, b, !0, !0)
	},
	drawCircle: function(a, b, c, d, e) {
		e = e || !1;
		d = this._renderContext.getContext();
		var f = cc.view.getScaleX(),
			k = cc.view.getScaleY();
		d.beginPath();
		d.arc(0 | a.x * f, 0 | -(a.y * k), b * f, -c, -(c - 2 * Math.PI), !1);
		e && d.lineTo(0 | a.x * f, 0 | -(a.y * k));
		d.stroke()
	},
	drawQuadBezier: function(a, b, c, d) {
		for (var e = this._cacheArray, f = e.length = 0, k = 0; k < d; k++) {
			var m = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
				n = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
			e.push(cc.p(m, n));
			f += 1 / d
		}
		e.push(cc.p(c.x, c.y));
		this.drawPoly(e, d + 1, !1, !1)
	},
	drawCubicBezier: function(a, b, c, d, e) {
		for (var f = this._cacheArray, k = f.length = 0, m = 0; m < e; m++) {
			var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x,
				p = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
			f.push(cc.p(n, p));
			k += 1 / e
		}
		f.push(cc.p(d.x, d.y));
		this.drawPoly(f, e + 1, !1, !1)
	},
	drawCatmullRom: function(a, b) {
		this.drawCardinalSpline(a, 0.5, b)
	},
	drawCardinalSpline: function(a, b, c) {
		cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
		var d = this._cacheArray;
		d.length = 0;
		for (var e, f, k = 1 / a.length, m = 0; m < c + 1; m++) f = m / c, 1 === f ? (e = a.length - 1, f = 1) : (e = 0 | f / k, f = (f - k * e) / k), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
		this.drawPoly(d, c + 1, !1, !1)
	},
	drawImage: function(a, b, c, d, e) {
		var f = arguments.length,
			k = this._renderContext.getContext();
		switch (f) {
		case 2:
			k.drawImage(a, b.x, -(b.y + a.height));
			break;
		case 3:
			k.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
			break;
		case 5:
			k.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
			break;
		default:
			throw Error("Argument must be non-nil");
		}
	},
	drawStar: function(a, b, c) {
		a = a || this._renderContext;
		var d = a.getContext();
		b *= cc.view.getScaleX();
		c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
		a.setFillStyle(c + ",1)");
		var e = b / 10;
		d.beginPath();
		d.moveTo(-b, b);
		d.lineTo(0, e);
		d.lineTo(b, b);
		d.lineTo(e, 0);
		d.lineTo(b, -b);
		d.lineTo(0, -e);
		d.lineTo(-b, -b);
		d.lineTo(-e, 0);
		d.lineTo(-b, b);
		d.closePath();
		d.fill();
		var f = d.createRadialGradient(0, 0, e, 0, 0, b);
		f.addColorStop(0, c + ", 1)");
		f.addColorStop(0.3, c + ", 0.8)");
		f.addColorStop(1, c + ", 0.0)");
		a.setFillStyle(f);
		d.beginPath();
		d.arc(0, 0, b - e, 0, cc.PI2, !1);
		d.closePath();
		d.fill()
	},
	drawColorBall: function(a, b, c) {
		a = a || this._renderContext;
		var d = a.getContext();
		b *= cc.view.getScaleX();
		c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
		var e = d.createRadialGradient(0, 0, b / 10, 0, 0, b);
		e.addColorStop(0, c + ", 1)");
		e.addColorStop(0.3, c + ", 0.8)");
		e.addColorStop(0.6, c + ", 0.4)");
		e.addColorStop(1, c + ", 0.0)");
		a.setFillStyle(e);
		d.beginPath();
		d.arc(0, 0, b, 0, cc.PI2, !1);
		d.closePath();
		d.fill()
	},
	fillText: function(a, b, c) {
		this._renderContext.getContext().fillText(a, b, -c)
	},
	setDrawColor: function(a, b, c, d) {
		this._renderContext.setFillStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")");
		this._renderContext.setStrokeStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")")
	},
	setPointSize: function(a) {},
	setLineWidth: function(a) {
		this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
	}
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
	_renderContext: null,
	_initialized: !1,
	_shader: null,
	_colorLocation: -1,
	_colorArray: null,
	_pointSizeLocation: -1,
	_pointSize: -1,
	ctor: function(a) {
		null == a && (a = cc._renderContext);
		if (!a instanceof WebGLRenderingContext) throw Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
		this._renderContext = a;
		this._colorArray = new Float32Array([1, 1, 1, 1])
	},
	lazy_init: function() {
		this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
	},
	drawInit: function() {
		this._initialized = !1
	},
	drawPoint: function(a) {
		this.lazy_init();
		var b = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		b.uniform4fv(this._colorLocation, this._colorArray);
		this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
		var c = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, c);
		b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
		b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
		b.drawArrays(b.POINTS, 0, 1);
		b.deleteBuffer(c);
		cc.incrementGLDraws(1)
	},
	drawPoints: function(a, b) {
		if (a && 0 !== a.length) {
			this.lazy_init();
			var c = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			c.uniform4fv(this._colorLocation, this._colorArray);
			this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
			var d = c.createBuffer();
			c.bindBuffer(c.ARRAY_BUFFER, d);
			c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
			c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
			c.drawArrays(c.POINTS, 0, a.length);
			c.deleteBuffer(d);
			cc.incrementGLDraws(1)
		}
	},
	_pointsToTypeArray: function(a) {
		for (var b = new Float32Array(2 * a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
		return b
	},
	drawLine: function(a, b) {
		this.lazy_init();
		var c = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		c.uniform4fv(this._colorLocation, this._colorArray);
		var d = c.createBuffer();
		c.bindBuffer(c.ARRAY_BUFFER, d);
		c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW);
		c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
		c.drawArrays(c.LINES, 0, 2);
		c.deleteBuffer(d);
		cc.incrementGLDraws(1)
	},
	drawRect: function(a, b) {
		this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
		this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
		this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
		this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
	},
	drawSolidRect: function(a, b, c) {
		a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
		this.drawSolidPoly(a, 4, c)
	},
	drawPoly: function(a, b, c) {
		this.lazy_init();
		b = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		b.uniform4fv(this._colorLocation, this._colorArray);
		var d = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, d);
		b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
		b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
		c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
		b.deleteBuffer(d);
		cc.incrementGLDraws(1)
	},
	drawSolidPoly: function(a, b, c) {
		this.lazy_init();
		c && this.setDrawColor(c.r, c.g, c.b, c.a);
		b = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		b.uniform4fv(this._colorLocation, this._colorArray);
		c = b.createBuffer();
		b.bindBuffer(b.ARRAY_BUFFER, c);
		b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
		b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
		b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
		b.deleteBuffer(c);
		cc.incrementGLDraws(1)
	},
	drawCircle: function(a, b, c, d, e) {
		this.lazy_init();
		var f = 1;
		e && f++;
		var k = 2 * Math.PI / d;
		if (e = new Float32Array(2 * (d + 2))) {
			for (var m = 0; m <= d; m++) {
				var n = m * k,
					p = b * Math.cos(n + c) + a.x,
					n = b * Math.sin(n + c) + a.y;
				e[2 * m] = p;
				e[2 * m + 1] = n
			}
			e[2 * (d + 1)] = a.x;
			e[2 * (d + 1) + 1] = a.y;
			a = this._renderContext;
			this._shader.use();
			this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
			a.uniform4fv(this._colorLocation, this._colorArray);
			b = a.createBuffer();
			a.bindBuffer(a.ARRAY_BUFFER, b);
			a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
			a.drawArrays(a.LINE_STRIP, 0, d + f);
			a.deleteBuffer(b);
			cc.incrementGLDraws(1)
		}
	},
	drawQuadBezier: function(a, b, c, d) {
		this.lazy_init();
		for (var e = new Float32Array(2 * (d + 1)), f = 0, k = 0; k < d; k++) e[2 * k] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * k + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
		e[2 * d] = c.x;
		e[2 * d + 1] = c.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		b = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, b);
		a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, d + 1);
		a.deleteBuffer(b);
		cc.incrementGLDraws(1)
	},
	drawCubicBezier: function(a, b, c, d, e) {
		this.lazy_init();
		for (var f = new Float32Array(2 * (e + 1)), k = 0, m = 0; m < e; m++) f[2 * m] = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x, f[2 * m + 1] = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y, k += 1 / e;
		f[2 * e] = d.x;
		f[2 * e + 1] = d.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		b = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, b);
		a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, e + 1);
		a.deleteBuffer(b);
		cc.incrementGLDraws(1)
	},
	drawCatmullRom: function(a, b) {
		this.drawCardinalSpline(a, 0.5, b)
	},
	drawCardinalSpline: function(a, b, c) {
		this.lazy_init();
		for (var d = new Float32Array(2 * (c + 1)), e, f, k = 1 / a.length, m = 0; m < c + 1; m++) f = m / c, 1 === f ? (e = a.length - 1, f = 1) : (e = 0 | f / k, f = (f - k * e) / k), e = cc.cardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d[2 * m] = e.x, d[2 * m + 1] = e.y;
		a = this._renderContext;
		this._shader.use();
		this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
		a.uniform4fv(this._colorLocation, this._colorArray);
		b = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, b);
		a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
		a.drawArrays(a.LINE_STRIP, 0, c + 1);
		a.deleteBuffer(b);
		cc.incrementGLDraws(1)
	},
	setDrawColor: function(a, b, c, d) {
		this._colorArray[0] = a / 255;
		this._colorArray[1] = b / 255;
		this._colorArray[2] = c / 255;
		this._colorArray[3] = d / 255
	},
	setPointSize: function(a) {
		this._pointSize = a * cc.contentScaleFactor()
	},
	setLineWidth: function(a) {
		this._renderContext.lineWidth && this._renderContext.lineWidth(a)
	}
});
cc._tmp.PrototypeLabelTTF = function() {
	var a = cc.LabelTTF.prototype;
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "string", a.getString, a.setString);
	cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
	cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
	cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
	cc.defineGetterSetter(a, "fontName", a.getFontName, a.setFontName);
	cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
	cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
	cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
	cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
	cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
	cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
	cc.defineGetterSetter(a, "shadowOffsetX", a._getShadowOffsetX, a._setShadowOffsetX);
	cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
	cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
	cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
	_dimensions: null,
	_hAlignment: cc.TEXT_ALIGNMENT_CENTER,
	_vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
	_fontName: null,
	_fontSize: 0,
	_string: "",
	_originalText: null,
	_shadowEnabled: !1,
	_shadowOffset: null,
	_shadowOpacity: 0,
	_shadowBlur: 0,
	_shadowColor: null,
	_strokeEnabled: !1,
	_strokeColor: null,
	_strokeSize: 0,
	_textFillColor: null,
	_strokeShadowOffsetX: 0,
	_strokeShadowOffsetY: 0,
	_needUpdateTexture: !1,
	_lineWidths: null,
	_className: "LabelTTF",
	_fontStyle: "normal",
	_fontWeight: "normal",
	_lineHeight: "normal",
	initWithString: function(a, b, c, d, e, f) {
		a = a ? a + "" : "";
		c = c || 16;
		d = d || cc.size(0, 0);
		e = e || cc.TEXT_ALIGNMENT_LEFT;
		f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._dimensions = cc.size(d.width, d.height);
		this._fontName = b || "Arial";
		this._hAlignment = e;
		this._vAlignment = f;
		this._fontSize = c;
		this._renderCmd._setFontStyle(this._fontName, c, this._fontStyle, this._fontWeight);
		this.string = a;
		this._renderCmd._setColorsString();
		this._renderCmd._updateTexture();
		this._setUpdateTextureDirty();
		return !0
	},
	_setUpdateTextureDirty: function() {
		this._needUpdateTexture = !0;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
	},
	ctor: function(a, b, c, d, e, f) {
		cc.Sprite.prototype.ctor.call(this);
		this._dimensions = cc.size(0, 0);
		this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
		this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
		this._opacityModifyRGB = !1;
		this._fontName = "Arial";
		this._shadowEnabled = !1;
		this._shadowOffset = cc.p(0, 0);
		this._shadowBlur = this._shadowOpacity = 0;
		this._strokeEnabled = !1;
		this._strokeColor = cc.color(255, 255, 255, 255);
		this._strokeSize = 0;
		this._textFillColor = cc.color(255, 255, 255, 255);
		this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
		this._needUpdateTexture = !1;
		this._lineWidths = [];
		this._renderCmd._setColorsString();
		this._textureLoaded = !0;
		b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, c, d, e, f)
	},
	init: function() {
		return this.initWithString(" ", this._fontName, this._fontSize)
	},
	description: function() {
		return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
	},
	getLineHeight: function() {
		return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
	},
	setLineHeight: function(a) {
		this._lineHeight = a
	},
	getString: function() {
		return this._string
	},
	getHorizontalAlignment: function() {
		return this._hAlignment
	},
	getVerticalAlignment: function() {
		return this._vAlignment
	},
	getDimensions: function() {
		return cc.size(this._dimensions)
	},
	getFontSize: function() {
		return this._fontSize
	},
	getFontName: function() {
		return this._fontName
	},
	initWithStringAndTextDefinition: function(a, b) {
		this._updateWithTextDefinition(b, !1);
		this.string = a;
		return !0
	},
	setTextDefinition: function(a) {
		a && this._updateWithTextDefinition(a, !0)
	},
	getTextDefinition: function() {
		return this._prepareTextDefinition(!1)
	},
	enableShadow: function(a, b, c, d) {
		null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, c) : this._enableShadowNoneColor(a, b, c, d)
	},
	_enableShadowNoneColor: function(a, b, c, d) {
		c = c || 0.5;
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		var e = this._shadowOffset;
		if (e && e.x !== a || e._y !== b) e.x = a, e.y = b;
		this._shadowOpacity !== c && (this._shadowOpacity = c);
		this._renderCmd._setColorsString();
		this._shadowBlur !== d && (this._shadowBlur = d);
		this._setUpdateTextureDirty()
	},
	_enableShadow: function(a, b, c) {
		this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
		this._shadowColor.r = a.r;
		this._shadowColor.g = a.g;
		this._shadowColor.b = a.b;
		this._enableShadowNoneColor(b.width || b.x || 0, b.height || b.y || 0, null != a.a ? a.a / 255 : 0.5, c)
	},
	_getShadowOffsetX: function() {
		return this._shadowOffset.x
	},
	_setShadowOffsetX: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset.x !== a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
	},
	_getShadowOffsetY: function() {
		return this._shadowOffset._y
	},
	_setShadowOffsetY: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOffset._y !== a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
	},
	_getShadowOffset: function() {
		return cc.p(this._shadowOffset.x, this._shadowOffset.y)
	},
	_setShadowOffset: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		if (this._shadowOffset.x !== a.x || this._shadowOffset.y !== a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
	},
	_getShadowOpacity: function() {
		return this._shadowOpacity
	},
	_setShadowOpacity: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowOpacity !== a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
	},
	_getShadowBlur: function() {
		return this._shadowBlur
	},
	_setShadowBlur: function(a) {
		!1 === this._shadowEnabled && (this._shadowEnabled = !0);
		this._shadowBlur !== a && (this._shadowBlur = a, this._setUpdateTextureDirty())
	},
	disableShadow: function() {
		this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
	},
	enableStroke: function(a, b) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var c = this._strokeColor;
		if (c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._renderCmd._setColorsString();
		this._strokeSize !== b && (this._strokeSize = b || 0);
		this._setUpdateTextureDirty()
	},
	_getStrokeStyle: function() {
		return this._strokeColor
	},
	_setStrokeStyle: function(a) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		var b = this._strokeColor;
		if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
	},
	_getLineWidth: function() {
		return this._strokeSize
	},
	_setLineWidth: function(a) {
		!1 === this._strokeEnabled && (this._strokeEnabled = !0);
		this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
	},
	disableStroke: function() {
		this._strokeEnabled && (this._strokeEnabled = !1, this._setUpdateTextureDirty())
	},
	setFontFillColor: function(a) {
		var b = this._textFillColor;
		if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
	},
	_getFillStyle: function() {
		return this._textFillColor
	},
	_updateWithTextDefinition: function(a, b) {
		a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
		this._hAlignment = a.textAlign;
		this._vAlignment = a.verticalAlign;
		this._fontName = a.fontName;
		this._fontSize = a.fontSize || 12;
		this._lineHeight = a.lineHeight ? a.lineHeight : this._fontSize;
		this._renderCmd._setFontStyle(a);
		a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
		a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
		this.setFontFillColor(a.fillStyle);
		b && this._renderCmd._updateTexture();
		var c = cc.Node._dirtyFlags;
		this._renderCmd.setDirtyFlag(c.colorDirty | c.opacityDirty | c.textDirty)
	},
	_prepareTextDefinition: function(a) {
		var b = new cc.FontDefinition;
		a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
		b.fontName = this._fontName;
		b.textAlign = this._hAlignment;
		b.verticalAlign = this._vAlignment;
		if (this._strokeEnabled) {
			b.strokeEnabled = !0;
			var c = this._strokeColor;
			b.strokeStyle = cc.color(c.r, c.g, c.b);
			b.lineWidth = this._strokeSize
		} else b.strokeEnabled = !1;
		this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
		a = this._textFillColor;
		b.fillStyle = cc.color(a.r, a.g, a.b);
		return b
	},
	setString: function(a) {
		a = String(a);
		this._originalText !== a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
	},
	_updateString: function() {
		if ((!this._string || "" === this._string) && this._string !== this._originalText) cc.renderer.childrenOrderDirty = !0;
		this._string = this._originalText
	},
	setHorizontalAlignment: function(a) {
		a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
	},
	setVerticalAlignment: function(a) {
		a !== this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
	},
	setDimensions: function(a, b) {
		var c;
		void 0 === b ? (c = a.width, b = a.height) : c = a;
		if (c !== this._dimensions.width || b !== this._dimensions.height) this._dimensions.width = c, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty()
	},
	_getBoundingWidth: function() {
		return this._dimensions.width
	},
	_setBoundingWidth: function(a) {
		a !== this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
	},
	_getBoundingHeight: function() {
		return this._dimensions.height
	},
	_setBoundingHeight: function(a) {
		a !== this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._setUpdateTextureDirty())
	},
	setFontSize: function(a) {
		this._fontSize !== a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	setFontName: function(a) {
		this._fontName && this._fontName !== a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFont: function() {
		return this._renderCmd._getFontStyle()
	},
	_setFont: function(a) {
		if (a = cc.LabelTTF._fontStyleRE.exec(a)) this._fontSize = parseInt(a[1]), this._fontName = a[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty()
	},
	getContentSize: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype.getContentSize.call(this)
	},
	_getWidth: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getWidth.call(this)
	},
	_getHeight: function() {
		this._needUpdateTexture && this._renderCmd._updateTTF();
		return cc.Sprite.prototype._getHeight.call(this)
	},
	setTextureRect: function(a, b, c) {
		cc.Sprite.prototype.setTextureRect.call(this, a, b, c, !1)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LabelTTF.CanvasRenderCmd(this) : new cc.LabelTTF.WebGLRenderCmd(this)
	},
	_setFontStyle: function(a) {
		this._fontStyle !== a && (this._fontStyle = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFontStyle: function() {
		return this._fontStyle
	},
	_setFontWeight: function(a) {
		this._fontWeight !== a && (this._fontWeight = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
	},
	_getFontWeight: function() {
		return this._fontWeight
	}
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, b, c, d, e, f) {
	return new cc.LabelTTF(a, b, c, d, e, f)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
	this.removeEventListener("load", arguments.callee, !1);
	document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
	if (a instanceof cc.FontDefinition) {
		var c = cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()];
		if (0 < c) return c;
		var d = cc.LabelTTF.__labelHeightDiv;
		d.innerHTML = "ajghl~!";
		d.style.fontFamily = a.fontName;
		d.style.fontSize = a.fontSize + "px";
		d.style.fontStyle = a.fontStyle;
		d.style.fontWeight = a.fontWeight;
		c = d.clientHeight;
		cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()] = c;
		d.innerHTML = "";
		return c
	}
	c = cc.LabelTTF.__fontHeightCache[a + "." + b];
	if (0 < c) return c;
	d = cc.LabelTTF.__labelHeightDiv;
	d.innerHTML = "ajghl~!";
	d.style.fontFamily = a;
	d.style.fontSize = b + "px";
	c = d.clientHeight;
	cc.LabelTTF.__fontHeightCache[a + "." + b] = c;
	d.innerHTML = "";
	return c
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/;
(function() {
	cc.LabelTTF.RenderCmd = function() {
		this._fontClientHeight = 18;
		this._fontStyleStr = "";
		this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
		this._strokeColorStr = "";
		this._fillColorStr = "rgba(255,255,255,1)";
		this._labelContext = this._labelCanvas = null;
		this._lineWidths = [];
		this._strings = [];
		this._isMultiLine = !1
	};
	var a = cc.LabelTTF.RenderCmd.prototype;
	a.constructor = cc.LabelTTF.RenderCmd;
	a._getLabelContext = function() {
		if (this._labelContext) return this._labelContext;
		var a = this._node;
		if (!this._labelCanvas) {
			var c = cc.newElement("canvas");
			c.width = 1;
			c.height = 1;
			var d = new cc.Texture2D;
			d.initWithElement(c);
			a.setTexture(d);
			this._labelCanvas = c
		}
		return this._labelContext = this._labelCanvas.getContext("2d")
	};
	a._setFontStyle = function(a, c, d, e) {
		a instanceof cc.FontDefinition ? (this._fontStyleStr = a._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a)) : (this._fontStyleStr = d + " " + e + " " + c + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, c))
	};
	a._getFontStyle = function() {
		return this._fontStyleStr
	};
	a._getFontClientHeight = function() {
		return this._fontClientHeight
	};
	a._updateTexture = function() {
		this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
		var a = this._node,
			c = this._getLabelContext(),
			d = this._labelCanvas,
			e = a._contentSize;
		if (0 === a._string.length) return d.width = 1, d.height = e.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, e.height)), !0;
		c.font = this._fontStyleStr;
		this._updateTTF();
		var f = e.width,
			e = e.height,
			k = d.width === f && d.height === e;
		d.width = f;
		d.height = e;
		k && c.clearRect(0, 0, f, e);
		this._drawTTFInCanvas(c);
		a._texture && a._texture.handleLoadedTexture();
		a.setTextureRect(cc.rect(0, 0, f, e));
		return !0
	};
	a._measureConfig = function() {
		this._getLabelContext().font = this._fontStyleStr
	};
	a._measure = function(a) {
		return this._getLabelContext().measureText(a).width
	};
	a._updateTTF = function() {
		var a = this._node,
			c = a._dimensions.width,
			d, e, f = this._lineWidths;
		f.length = 0;
		this._isMultiLine = !1;
		this._measureConfig();
		if (0 !== c) {
			this._strings = a._string.split("\n");
			for (d = 0; d < this._strings.length; d++) this._checkWarp(this._strings, d, c)
		} else {
			this._strings = a._string.split("\n");
			d = 0;
			for (e = this._strings.length; d < e; d++) f.push(this._measure(this._strings[d]))
		}
		1 < this._strings.length && (this._isMultiLine = !0);
		e = d = 0;
		a._strokeEnabled && (d = e = 2 * a._strokeSize);
		if (a._shadowEnabled) {
			var k = a._shadowOffset;
			d += 2 * Math.abs(k.x);
			e += 2 * Math.abs(k.y)
		}
		c = 0 === c ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, f) + d), Math.ceil(this._fontClientHeight * this._strings.length + e)) : cc.size(Math.ceil(this._measure(a._string) + d), Math.ceil(this._fontClientHeight + e)) : 0 === a._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(c + d), Math.ceil(a.getLineHeight() * this._strings.length + e)) : cc.size(Math.ceil(c + d), Math.ceil(a.getLineHeight() + e)) : cc.size(Math.ceil(c + d), Math.ceil(a._dimensions.height + e));
		"normal" !== a._getFontStyle() && (c.width = Math.ceil(c.width + 0.3 * a._fontSize));
		a.setContentSize(c);
		a._strokeShadowOffsetX = d;
		a._strokeShadowOffsetY = e;
		a = a._anchorPoint;
		this._anchorPointInPoints.x = 0.5 * d + (c.width - d) * a.x;
		this._anchorPointInPoints.y = 0.5 * e + (c.height - e) * a.y
	};
	a._drawTTFInCanvas = function(a) {
		if (a) {
			var c = this._node,
				d = c._strokeShadowOffsetX,
				e = c._strokeShadowOffsetY,
				f = c._contentSize.height - e,
				k = c._vAlignment,
				m = c._hAlignment,
				n = c._strokeSize;
			a.setTransform(1, 0, 0, 1, 0.5 * d, f + 0.5 * e);
			a.font !== this._fontStyleStr && (a.font = this._fontStyleStr);
			a.fillStyle = this._fillColorStr;
			var p = e = 0,
				r = c._strokeEnabled;
			r && (a.lineWidth = 2 * n, a.strokeStyle = this._strokeColorStr);
			c._shadowEnabled && (n = c._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = n.x, a.shadowOffsetY = -n.y, a.shadowBlur = c._shadowBlur);
			a.textBaseline = cc.LabelTTF._textBaseline[k];
			a.textAlign = cc.LabelTTF._textAlign[m];
			var s = c._contentSize.width - d,
				d = c.getLineHeight(),
				n = (d - this._fontClientHeight) / 2,
				e = m === cc.TEXT_ALIGNMENT_RIGHT ? e + s : m === cc.TEXT_ALIGNMENT_CENTER ? e + s / 2 : e + 0;
			if (this._isMultiLine) {
				c = this._strings.length;
				k === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? p = d - 2 * n + f - d * c : k === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (p = (d - 2 * n) / 2 + (f - d * c) / 2);
				for (k = 0; k < c; k++) m = this._strings[k], s = -f + (d * k + n) + p, r && a.strokeText(m, e, s), a.fillText(m, e, s)
			} else k !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (p = k === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? p - f : p - 0.5 * f), r && a.strokeText(c._string, e, p), a.fillText(c._string, e, p)
		}
	};
	a._checkWarp = function(a, c, d) {
		var e = a[c],
			f = this._measure(e);
		if (f > d && 1 < e.length) {
			for (var k = e.length * (d / f) | 0, m = e.substr(k), n = f - this._measure(m), p, r = 0, s = 0; n > d && 100 > s++;) k *= d / n, k |= 0, m = e.substr(k), n = f - this._measure(m);
			for (s = 0; n < d && 100 > s++;) m && (r = (p = cc.LabelTTF._wordRex.exec(m)) ? p[0].length : 1, p = m), k += r, m = e.substr(k), n = f - this._measure(m);
			k -= r;
			0 === k && (k = 1, p = p.substr(1));
			d = e.substr(0, k);
			if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(p || m)) f = cc.LabelTTF._lastWordRex.exec(d), k -= f ? f[0].length : 0, p = e.substr(k), d = e.substr(0, k);
			if (cc.LabelTTF._firsrEnglish.test(p) && (f = cc.LabelTTF._lastEnglish.exec(d)) && d !== f[0]) k -= f[0].length, p = e.substr(k), d = e.substr(0, k);
			a[c] = p || m;
			a.splice(c, 0, d)
		}
	}
})();
(function() {
	cc.LabelTTF.CanvasRenderCmd = function(a) {
		cc.Sprite.CanvasRenderCmd.call(this, a);
		cc.LabelTTF.RenderCmd.call(this)
	};
	cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
	var a = cc.LabelTTF.CanvasRenderCmd.prototype;
	a.constructor = cc.LabelTTF.CanvasRenderCmd;
	a.updateStatus = function() {
		var a = cc.Node._dirtyFlags,
			c = this._dirtyFlag,
			d = c & a.colorDirty,
			e = c & a.opacityDirty;
		d && this._updateDisplayColor();
		e && this._updateDisplayOpacity();
		d ? this._updateColor() : c & a.textDirty && this._updateTexture();
		this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	};
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		var e = d & c.colorDirty,
			f = d & c.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e ? this._updateColor() : d & c.textDirty && this._updateTexture();
		d & c.transformDirty && this.transform(a)
	};
	a._setColorsString = function() {
		var a = this._displayedColor,
			c = this._node,
			d = c._shadowColor || this._displayedColor,
			e = c._strokeColor,
			f = c._textFillColor,
			k = a.r / 255,
			m = a.g / 255,
			a = a.b / 255;
		this._shadowColorStr = "rgba(" + (0 | k * d.r) + "," + (0 | m * d.g) + "," + (0 | a * d.b) + "," + c._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | k * f.r) + "," + (0 | m * f.g) + "," + (0 | a * f.b) + ", 1)";
		this._strokeColorStr = "rgba(" + (0 | k * e.r) + "," + (0 | m * e.g) + "," + (0 | a * e.b) + ", 1)"
	};
	a._updateColor = function() {
		this._setColorsString();
		this._updateTexture()
	}
})();
(function() {
	cc.LabelTTF.WebGLRenderCmd = function(a) {
		cc.Sprite.WebGLRenderCmd.call(this, a);
		cc.LabelTTF.RenderCmd.call(this);
		this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
	};
	var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
	cc.inject(cc.LabelTTF.RenderCmd.prototype, a);
	a.constructor = cc.LabelTTF.WebGLRenderCmd;
	a._setColorsString = function() {
		this.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
		var a = this._node,
			c = a._strokeColor,
			d = a._textFillColor,
			e = a._shadowColor || this._displayedColor;
		this._shadowColorStr = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + a._shadowOpacity + ")";
		this._fillColorStr = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + ", 1)";
		this._strokeColorStr = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)"
	};
	a.updateStatus = function() {
		var a = cc.Node._dirtyFlags,
			c = this._dirtyFlag,
			d = c & a.colorDirty,
			e = c & a.opacityDirty;
		d && this._updateDisplayColor();
		e && this._updateDisplayOpacity();
		d || e ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : c & a.textDirty && this._updateTexture();
		this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
	};
	a._syncStatus = function(a) {
		var c = cc.Node._dirtyFlags,
			d = this._dirtyFlag,
			e = a ? a._node : null;
		e && (e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty) && (d |= c.colorDirty);
		e && (e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty) && (d |= c.opacityDirty);
		a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
		var e = d & c.colorDirty,
			f = d & c.opacityDirty;
		this._dirtyFlag = d;
		e && this._syncDisplayColor();
		f && this._syncDisplayOpacity();
		e || f ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : d & c.textDirty && this._updateTexture();
		this.transform(a)
	}
})();
cc.HashElement = cc.Class.extend({
	actions: null,
	target: null,
	actionIndex: 0,
	currentAction: null,
	currentActionSalvaged: !1,
	paused: !1,
	hh: null,
	ctor: function() {
		this.actions = [];
		this.target = null;
		this.actionIndex = 0;
		this.currentAction = null;
		this.paused = this.currentActionSalvaged = !1;
		this.hh = null
	}
});
cc.ActionManager = cc.Class.extend({
	_hashTargets: null,
	_arrayTargets: null,
	_currentTarget: null,
	_currentTargetSalvaged: !1,
	_searchElementByTarget: function(a, b) {
		for (var c = 0; c < a.length; c++)
		if (b === a[c].target) return a[c];
		return null
	},
	ctor: function() {
		this._hashTargets = {};
		this._arrayTargets = [];
		this._currentTarget = null;
		this._currentTargetSalvaged = !1
	},
	addAction: function(a, b, c) {
		if (!a) throw Error("cc.ActionManager.addAction(): action must be non-null");
		if (!b) throw Error("cc.ActionManager.addAction(): action must be non-null");
		var d = this._hashTargets[b.__instanceId];
		d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d));
		this._actionAllocWithHashElement(d);
		d.actions.push(a);
		a.startWithTarget(b)
	},
	removeAllActions: function() {
		for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
			var c = a[b];
			c && this.removeAllActionsFromTarget(c.target, !0)
		}
	},
	removeAllActionsFromTarget: function(a, b) {
		if (null != a) {
			var c = this._hashTargets[a.__instanceId];
			c && (-1 !== c.actions.indexOf(c.currentAction) && !c.currentActionSalvaged && (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget === c && !b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(c))
		}
	},
	removeAction: function(a) {
		if (null != a) {
			var b = a.getOriginalTarget();
			if (b = this._hashTargets[b.__instanceId]) for (var c = 0; c < b.actions.length; c++) {
				if (b.actions[c] === a) {
					b.actions.splice(c, 1);
					break
				}
			} else cc.log(cc._LogInfos.ActionManager_removeAction)
		}
	},
	removeActionByTag: function(a, b) {
		a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
		cc.assert(b, cc._LogInfos.ActionManager_addAction);
		var c = this._hashTargets[b.__instanceId];
		if (c) for (var d = c.actions.length, e = 0; e < d; ++e) {
			var f = c.actions[e];
			if (f && f.getTag() === a && f.getOriginalTarget() === b) {
				this._removeActionAtIndex(e, c);
				break
			}
		}
	},
	getActionByTag: function(a, b) {
		a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
		var c = this._hashTargets[b.__instanceId];
		if (c) {
			if (null != c.actions) for (var d = 0; d < c.actions.length; ++d) {
				var e = c.actions[d];
				if (e && e.getTag() === a) return e
			}
			cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
		}
		return null
	},
	numberOfRunningActionsInTarget: function(a) {
		return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
	},
	pauseTarget: function(a) {
		if (a = this._hashTargets[a.__instanceId]) a.paused = !0
	},
	resumeTarget: function(a) {
		if (a = this._hashTargets[a.__instanceId]) a.paused = !1
	},
	pauseAllRunningActions: function() {
		for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
			var d = b[c];
			d && !d.paused && (d.paused = !0, a.push(d.target))
		}
		return a
	},
	resumeTargets: function(a) {
		if (a) for (var b = 0; b < a.length; b++) a[b] && this.resumeTarget(a[b])
	},
	purgeSharedManager: function() {
		cc.director.getScheduler().unscheduleUpdate(this)
	},
	_removeActionAtIndex: function(a, b) {
		b.actions[a] === b.currentAction && !b.currentActionSalvaged && (b.currentActionSalvaged = !0);
		b.actions.splice(a, 1);
		b.actionIndex >= a && b.actionIndex--;
		0 === b.actions.length && (this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
	},
	_deleteHashElement: function(a) {
		var b = !1;
		a && (this._hashTargets[a.target.__instanceId] && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), b = !0), a.actions = null, a.target = null);
		return b
	},
	_actionAllocWithHashElement: function(a) {
		null == a.actions && (a.actions = [])
	},
	update: function(a) {
		for (var b = this._arrayTargets, c, d = 0; d < b.length; d++) {
			c = this._currentTarget = b[d];
			if (!c.paused) for (c.actionIndex = 0; c.actionIndex < (c.actions ? c.actions.length : 0); c.actionIndex++)
			if (c.currentAction = c.actions[c.actionIndex], c.currentAction) {
				c.currentActionSalvaged = !1;
				c.currentAction.step(a * (c.currentAction._speedMethod ? c.currentAction._speed : 1));
				if (c.currentActionSalvaged) c.currentAction = null;
				else if (c.currentAction.isDone()) {
					c.currentAction.stop();
					var e = c.currentAction;
					c.currentAction = null;
					this.removeAction(e)
				}
				c.currentAction = null
			}
			this._currentTargetSalvaged && 0 === c.actions.length && this._deleteHashElement(c) && d--
		}
	}
});
cc.math = cc.math || {};
cc.math.EPSILON = 0.015625;
cc.math.square = function(a) {
	return a * a
};
cc.math.almostEqual = function(a, b) {
	return a + cc.math.EPSILON > b && a - cc.math.EPSILON < b
};
(function(a) {
	a.math.Vec2 = function(a, b) {
		void 0 === b ? (this.x = a.x, this.y = a.y) : (this.x = a || 0, this.y = b || 0)
	};
	var b = a.math.Vec2.prototype;
	b.fill = function(a, b) {
		this.x = a;
		this.y = b
	};
	b.length = function() {
		return Math.sqrt(a.math.square(this.x) + a.math.square(this.y))
	};
	b.lengthSq = function() {
		return a.math.square(this.x) + a.math.square(this.y)
	};
	b.normalize = function() {
		var a = 1 / this.length();
		this.x *= a;
		this.y *= a;
		return this
	};
	a.math.Vec2.add = function(a, b, e) {
		a.x = b.x + e.x;
		a.y = b.y + e.y;
		return a
	};
	b.add = function(a) {
		this.x += a.x;
		this.y += a.y;
		return this
	};
	b.dot = function(a) {
		return this.x * a.x + this.y * a.y
	};
	a.math.Vec2.subtract = function(a, b, e) {
		a.x = b.x - e.x;
		a.y = b.y - e.y;
		return a
	};
	b.subtract = function(a) {
		this.x -= a.x;
		this.y -= a.y;
		return this
	};
	b.transform = function(a) {
		var b = this.x,
			e = this.y;
		this.x = b * a.mat[0] + e * a.mat[3] + a.mat[6];
		this.y = b * a.mat[1] + e * a.mat[4] + a.mat[7];
		return this
	};
	a.math.Vec2.scale = function(a, b, e) {
		a.x = b.x * e;
		a.y = b.y * e;
		return a
	};
	b.scale = function(a) {
		this.x *= a;
		this.y *= a;
		return this
	};
	b.equals = function(b) {
		return this.x < b.x + a.math.EPSILON && this.x > b.x - a.math.EPSILON && this.y < b.y + a.math.EPSILON && this.y > b.y - a.math.EPSILON
	}
})(cc);
(function(a) {
	a.kmVec3 = a.math.Vec3 = function(a, b, e) {
		a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a || 0, this.y = b || 0, this.z = e || 0)
	};
	a.math.vec3 = function(b, d, e) {
		return new a.math.Vec3(b, d, e)
	};
	var b = a.math.Vec3.prototype;
	b.fill = function(a, b, e) {
		a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a, this.y = b, this.z = e);
		return this
	};
	b.length = function() {
		return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z))
	};
	b.lengthSq = function() {
		return a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z)
	};
	b.normalize = function() {
		var a = 1 / this.length();
		this.x *= a;
		this.y *= a;
		this.z *= a;
		return this
	};
	b.cross = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z;
		this.x = e * a.z - f * a.y;
		this.y = f * a.x - b * a.z;
		this.z = b * a.y - e * a.x;
		return this
	};
	b.dot = function(a) {
		return this.x * a.x + this.y * a.y + this.z * a.z
	};
	b.add = function(a) {
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
		return this
	};
	b.subtract = function(a) {
		this.x -= a.x;
		this.y -= a.y;
		this.z -= a.z;
		return this
	};
	b.transform = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z;
		a = a.mat;
		this.x = b * a[0] + e * a[4] + f * a[8] + a[12];
		this.y = b * a[1] + e * a[5] + f * a[9] + a[13];
		this.z = b * a[2] + e * a[6] + f * a[10] + a[14];
		return this
	};
	b.transformNormal = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z;
		a = a.mat;
		this.x = b * a[0] + e * a[4] + f * a[8];
		this.y = b * a[1] + e * a[5] + f * a[9];
		this.z = b * a[2] + e * a[6] + f * a[10];
		return this
	};
	b.transformCoord = function(b) {
		var d = new a.math.Vec4(this.x, this.y, this.z, 1);
		d.transform(b);
		this.x = d.x / d.w;
		this.y = d.y / d.w;
		this.z = d.z / d.w;
		return this
	};
	b.scale = function(a) {
		this.x *= a;
		this.y *= a;
		this.z *= a;
		return this
	};
	b.equals = function(b) {
		var d = a.math.EPSILON;
		return this.x < b.x + d && this.x > b.x - d && this.y < b.y + d && this.y > b.y - d && this.z < b.z + d && this.z > b.z - d
	};
	b.inverseTransform = function(b) {
		b = b.mat;
		var d = new a.math.Vec3(this.x - b[12], this.y - b[13], this.z - b[14]);
		this.x = d.x * b[0] + d.y * b[1] + d.z * b[2];
		this.y = d.x * b[4] + d.y * b[5] + d.z * b[6];
		this.z = d.x * b[8] + d.y * b[9] + d.z * b[10];
		return this
	};
	b.inverseTransformNormal = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z;
		a = a.mat;
		this.x = b * a[0] + e * a[1] + f * a[2];
		this.y = b * a[4] + e * a[5] + f * a[6];
		this.z = b * a[8] + e * a[9] + f * a[10];
		return this
	};
	b.assignFrom = function(a) {
		if (!a) return this;
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		return this
	};
	a.math.Vec3.zero = function(a) {
		a.x = a.y = a.z = 0;
		return a
	};
	b.toTypeArray = function() {
		var a = new Float32Array(3);
		a[0] = this.x;
		a[1] = this.y;
		a[2] = this.z;
		return a
	}
})(cc);
(function(a) {
	a.math.Vec4 = function(a, b, e, f) {
		a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = e || 0, this.w = f || 0)
	};
	a.kmVec4 = a.math.Vec4;
	var b = a.math.Vec4.prototype;
	b.fill = function(a, b, e, f) {
		a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a, this.y = b, this.z = e, this.w = f)
	};
	b.add = function(a) {
		if (!a) return this;
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
		this.w += a.w;
		return this
	};
	b.dot = function(a) {
		return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
	};
	b.length = function() {
		return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w))
	};
	b.lengthSq = function() {
		return a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w)
	};
	b.lerp = function(a, b) {
		return this
	};
	b.normalize = function() {
		var a = 1 / this.length();
		this.x *= a;
		this.y *= a;
		this.z *= a;
		this.w *= a;
		return this
	};
	b.scale = function(a) {
		this.normalize();
		this.x *= a;
		this.y *= a;
		this.z *= a;
		this.w *= a;
		return this
	};
	b.subtract = function(a) {
		this.x -= a.x;
		this.y -= a.y;
		this.z -= a.z;
		this.w -= a.w
	};
	b.transform = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z,
			k = this.w;
		a = a.mat;
		this.x = b * a[0] + e * a[4] + f * a[8] + k * a[12];
		this.y = b * a[1] + e * a[5] + f * a[9] + k * a[13];
		this.z = b * a[2] + e * a[6] + f * a[10] + k * a[14];
		this.w = b * a[3] + e * a[7] + f * a[11] + k * a[15];
		return this
	};
	a.math.Vec4.transformArray = function(b, d) {
		for (var e = [], f = 0; f < b.length; f++) {
			var k = new a.math.Vec4(b[f]);
			k.transform(d);
			e.push(k)
		}
		return e
	};
	b.equals = function(b) {
		var d = a.math.EPSILON;
		return this.x < b.x + d && this.x > b.x - d && this.y < b.y + d && this.y > b.y - d && this.z < b.z + d && this.z > b.z - d && this.w < b.w + d && this.w > b.w - d
	};
	b.assignFrom = function(a) {
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		this.w = a.w;
		return this
	};
	b.toTypeArray = function() {
		var a = new Float32Array(4);
		a[0] = this.x;
		a[1] = this.y;
		a[2] = this.z;
		a[3] = this.w;
		return a
	}
})(cc);
(function(a) {
	function b(b, d, e) {
		d = new a.math.Vec2(d);
		d.subtract(b);
		e.x = -d.y;
		e.y = d.x;
		e.normalize()
	}
	a.math.Ray2 = function(b, d) {
		this.start = b || new a.math.Vec2;
		this.dir = d || new a.math.Vec2
	};
	a.math.Ray2.prototype.fill = function(a, b, e, f) {
		this.start.x = a;
		this.start.y = b;
		this.dir.x = e;
		this.dir.y = f
	};
	a.math.Ray2.prototype.intersectLineSegment = function(b, d, e) {
		var f = this.start.x,
			k = this.start.y,
			m = this.start.x + this.dir.x,
			n = this.start.y + this.dir.y,
			p = b.x,
			r = b.y,
			s = d.x,
			u = d.y,
			t = (u - r) * (m - f) - (s - p) * (n - k);
		if (t > -a.math.EPSILON && t < a.math.EPSILON) return !1;
		r = ((s - p) * (k - r) - (u - r) * (f - p)) / t;
		p = f + r * (m - f);
		r = k + r * (n - k);
		if (p < Math.min(b.x, d.x) - a.math.EPSILON || p > Math.max(b.x, d.x) + a.math.EPSILON || r < Math.min(b.y, d.y) - a.math.EPSILON || r > Math.max(b.y, d.y) + a.math.EPSILON || p < Math.min(f, m) - a.math.EPSILON || p > Math.max(f, m) + a.math.EPSILON || r < Math.min(k, n) - a.math.EPSILON || r > Math.max(k, n) + a.math.EPSILON) return !1;
		e.x = p;
		e.y = r;
		return !0
	};
	a.math.Ray2.prototype.intersectTriangle = function(c, d, e, f, k) {
		var m = new a.math.Vec2,
			n = new a.math.Vec2,
			p = new a.math.Vec2,
			r = 1E4,
			s = !1,
			u;
		this.intersectLineSegment(c, d, m) && (s = !0, u = m.subtract(this.start).length(), u < r && (n.x = m.x, n.y = m.y, r = u, b(c, d, p)));
		this.intersectLineSegment(d, e, m) && (s = !0, u = m.subtract(this.start).length(), u < r && (n.x = m.x, n.y = m.y, r = u, b(d, e, p)));
		this.intersectLineSegment(e, c, m) && (s = !0, u = m.subtract(this.start).length(), u < r && (n.x = m.x, n.y = m.y, b(e, c, p)));
		s && (f.x = n.x, f.y = n.y, k && (k.x = p.x, k.y = p.y));
		return s
	}
})(cc);
window.Uint16Array = window.Uint16Array || window.Array;
window.Float32Array = window.Float32Array || window.Array;
(function(a) {
	a.math.Matrix3 = function(a) {
		this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(9)
	};
	a.kmMat3 = a.math.Matrix3;
	var b = a.math.Matrix3.prototype;
	b.fill = function(a) {
		var b = this.mat;
		a = a.mat;
		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];
		b[3] = a[3];
		b[4] = a[4];
		b[5] = a[5];
		b[6] = a[6];
		b[7] = a[7];
		b[8] = a[8];
		return this
	};
	b.adjugate = function() {
		var a = this.mat,
			b = a[0],
			c = a[1],
			k = a[2],
			m = a[3],
			n = a[4],
			p = a[5],
			r = a[6],
			s = a[7],
			u = a[8];
		a[0] = n * u - p * s;
		a[1] = k * s - c * u;
		a[2] = c * p - k * n;
		a[3] = p * r - m * u;
		a[4] = b * u - k * r;
		a[5] = k * m - b * p;
		a[6] = m * s - n * r;
		a[8] = b * n - c * m;
		return this
	};
	b.identity = function() {
		var a = this.mat;
		a[1] = a[2] = a[3] = a[5] = a[6] = a[7] = 0;
		a[0] = a[4] = a[8] = 1;
		return this
	};
	var c = new a.math.Matrix3;
	b.inverse = function(a) {
		if (0 === a) return this;
		c.assignFrom(this);
		a = 1 / a;
		this.adjugate();
		this.multiplyScalar(a);
		return this
	};
	b.isIdentity = function() {
		var a = this.mat;
		return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
	};
	b.transpose = function() {
		var a = this.mat,
			b = a[1],
			c = a[2],
			k = a[5],
			m = a[6],
			n = a[7];
		a[1] = a[3];
		a[2] = m;
		a[3] = b;
		a[5] = n;
		a[6] = c;
		a[7] = k;
		return this
	};
	b.determinant = function() {
		var a = this.mat,
			b = a[0] * a[4] * a[8] + a[1] * a[5] * a[6] + a[2] * a[3] * a[7];
		return b -= a[2] * a[4] * a[6] + a[0] * a[5] * a[7] + a[1] * a[3] * a[8]
	};
	b.multiply = function(a) {
		var b = this.mat,
			c = a.mat;
		a = b[0];
		var k = b[1],
			m = b[2],
			n = b[3],
			p = b[4],
			r = b[5],
			s = b[6],
			u = b[7],
			t = b[8],
			w = c[0],
			v = c[1],
			y = c[2],
			z = c[3],
			F = c[4],
			E = c[5],
			C = c[6],
			A = c[7],
			c = c[8];
		b[0] = a * w + n * v + s * y;
		b[1] = k * w + p * v + u * y;
		b[2] = m * w + r * v + t * y;
		b[3] = m * w + r * v + t * y;
		b[4] = k * z + p * F + u * E;
		b[5] = m * z + r * F + t * E;
		b[6] = a * C + n * A + s * c;
		b[7] = k * C + p * A + u * c;
		b[8] = m * C + r * A + t * c;
		return this
	};
	b.multiplyScalar = function(a) {
		var b = this.mat;
		b[0] *= a;
		b[1] *= a;
		b[2] *= a;
		b[3] *= a;
		b[4] *= a;
		b[5] *= a;
		b[6] *= a;
		b[7] *= a;
		b[8] *= a;
		return this
	};
	a.math.Matrix3.rotationAxisAngle = function(b, c) {
		var f = Math.cos(c),
			k = Math.sin(c),
			m = new a.math.Matrix3,
			n = m.mat;
		n[0] = f + b.x * b.x * (1 - f);
		n[1] = b.z * k + b.y * b.x * (1 - f);
		n[2] = -b.y * k + b.z * b.x * (1 - f);
		n[3] = -b.z * k + b.x * b.y * (1 - f);
		n[4] = f + b.y * b.y * (1 - f);
		n[5] = b.x * k + b.z * b.y * (1 - f);
		n[6] = b.y * k + b.x * b.z * (1 - f);
		n[7] = -b.x * k + b.y * b.z * (1 - f);
		n[8] = f + b.z * b.z * (1 - f);
		return m
	};
	b.assignFrom = function(b) {
		if (this === b) return a.log("cc.math.Matrix3.assign(): current matrix equals matIn"), this;
		var c = this.mat;
		b = b.mat;
		c[0] = b[0];
		c[1] = b[1];
		c[2] = b[2];
		c[3] = b[3];
		c[4] = b[4];
		c[5] = b[5];
		c[6] = b[6];
		c[7] = b[7];
		c[8] = b[8];
		return this
	};
	b.equals = function(b) {
		if (this === b) return !0;
		var c = a.math.EPSILON,
			f = this.mat;
		b = b.mat;
		for (var k = 0; 9 > k; ++k)
		if (!(f[k] + c > b[k] && f[k] - c < b[k])) return !1;
		return !0
	};
	a.math.Matrix3.createByRotationX = function(b) {
		var c = new a.math.Matrix3,
			f = c.mat;
		f[0] = 1;
		f[1] = 0;
		f[2] = 0;
		f[3] = 0;
		f[4] = Math.cos(b);
		f[5] = Math.sin(b);
		f[6] = 0;
		f[7] = -Math.sin(b);
		f[8] = Math.cos(b);
		return c
	};
	a.math.Matrix3.createByRotationY = function(b) {
		var c = new a.math.Matrix3,
			f = c.mat;
		f[0] = Math.cos(b);
		f[1] = 0;
		f[2] = -Math.sin(b);
		f[3] = 0;
		f[4] = 1;
		f[5] = 0;
		f[6] = Math.sin(b);
		f[7] = 0;
		f[8] = Math.cos(b);
		return c
	};
	a.math.Matrix3.createByRotationZ = function(b) {
		var c = new a.math.Matrix3,
			f = c.mat;
		f[0] = Math.cos(b);
		f[1] = -Math.sin(b);
		f[2] = 0;
		f[3] = Math.sin(b);
		f[4] = Math.cos(b);
		f[5] = 0;
		f[6] = 0;
		f[7] = 0;
		f[8] = 1;
		return c
	};
	a.math.Matrix3.createByRotation = function(b) {
		var c = new a.math.Matrix3,
			f = c.mat;
		f[0] = Math.cos(b);
		f[1] = Math.sin(b);
		f[2] = 0;
		f[3] = -Math.sin(b);
		f[4] = Math.cos(b);
		f[5] = 0;
		f[6] = 0;
		f[7] = 0;
		f[8] = 1;
		return c
	};
	a.math.Matrix3.createByScale = function(b, c) {
		var f = new a.math.Matrix3;
		f.identity();
		f.mat[0] = b;
		f.mat[4] = c;
		return f
	};
	a.math.Matrix3.createByTranslation = function(b, c) {
		var f = new a.math.Matrix3;
		f.identity();
		f.mat[6] = b;
		f.mat[7] = c;
		return f
	};
	a.math.Matrix3.createByQuaternion = function(b) {
		if (!b) return null;
		var c = new a.math.Matrix3,
			f = c.mat;
		f[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
		f[1] = 2 * (b.x * b.y - b.w * b.z);
		f[2] = 2 * (b.x * b.z + b.w * b.y);
		f[3] = 2 * (b.x * b.y + b.w * b.z);
		f[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
		f[5] = 2 * (b.y * b.z - b.w * b.x);
		f[6] = 2 * (b.x * b.z - b.w * b.y);
		f[7] = 2 * (b.y * b.z + b.w * b.x);
		f[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
		return c
	};
	b.rotationToAxisAngle = function() {
		return a.math.Quaternion.rotationMatrix(this).toAxisAndAngle()
	}
})(cc);
(function(a) {
	a.math.Matrix4 = function(a) {
		this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(16)
	};
	a.kmMat4 = a.math.Matrix4;
	var b = a.math.Matrix4.prototype;
	b.fill = function(a) {
		for (var b = this.mat, c = 0; 16 > c; c++) b[c] = a[c];
		return this
	};
	a.kmMat4Identity = function(a) {
		var b = a.mat;
		b[1] = b[2] = b[3] = b[4] = b[6] = b[7] = b[8] = b[9] = b[11] = b[12] = b[13] = b[14] = 0;
		b[0] = b[5] = b[10] = b[15] = 1;
		return a
	};
	b.identity = function() {
		var a = this.mat;
		a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0;
		a[0] = a[5] = a[10] = a[15] = 1;
		return this
	};
	b.get = function(a, b) {
		return this.mat[a + 4 * b]
	};
	b.set = function(a, b, c) {
		this.mat[a + 4 * b] = c
	};
	b.swap = function(a, b, c, d) {
		var n = this.mat,
			p = n[a + 4 * b];
		n[a + 4 * b] = n[c + 4 * d];
		n[c + 4 * d] = p
	};
	a.math.Matrix4._gaussj = function(a, b) {
		var c, d = 0,
			n = 0,
			p, r, s, u, t = [0, 0, 0, 0],
			w = [0, 0, 0, 0],
			v = [0, 0, 0, 0];
		for (c = 0; 4 > c; c++) {
			for (p = u = 0; 4 > p; p++)
			if (1 !== v[p]) for (r = 0; 4 > r; r++) 0 === v[r] && (s = Math.abs(a.get(p, r)), s >= u && (u = s, n = p, d = r));
			++v[d];
			if (n !== d) {
				for (p = 0; 4 > p; p++) a.swap(n, p, d, p);
				for (p = 0; 4 > p; p++) b.swap(n, p, d, p)
			}
			w[c] = n;
			t[c] = d;
			if (0 === a.get(d, d)) return !1;
			r = 1 / a.get(d, d);
			a.set(d, d, 1);
			for (p = 0; 4 > p; p++) a.set(d, p, a.get(d, p) * r);
			for (p = 0; 4 > p; p++) b.set(d, p, b.get(d, p) * r);
			for (r = 0; 4 > r; r++)
			if (r !== d) {
				s = a.get(r, d);
				a.set(r, d, 0);
				for (p = 0; 4 > p; p++) a.set(r, p, a.get(r, p) - a.get(d, p) * s);
				for (p = 0; 4 > p; p++) b.set(r, p, a.get(r, p) - b.get(d, p) * s)
			}
		}
		for (p = 3; 0 <= p; p--)
		if (w[p] !== t[p]) for (r = 0; 4 > r; r++) a.swap(r, w[p], r, t[p]);
		return !0
	};
	var c = (new a.math.Matrix4).identity();
	a.kmMat4Inverse = function(b, d) {
		var k = new a.math.Matrix4(d),
			m = new a.math.Matrix4(c);
		if (!1 === a.math.Matrix4._gaussj(k, m)) return null;
		b.assignFrom(k);
		return b
	};
	b.inverse = function() {
		var b = new a.math.Matrix4(this),
			d = new a.math.Matrix4(c);
		return !1 === a.math.Matrix4._gaussj(b, d) ? null : b
	};
	b.isIdentity = function() {
		var a = this.mat;
		return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] && 0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
	};
	b.transpose = function() {
		var a = this.mat,
			b = a[1],
			c = a[2],
			d = a[3],
			n = a[6],
			p = a[7],
			r = a[8],
			s = a[9],
			u = a[11],
			t = a[12],
			w = a[13],
			v = a[14];
		a[1] = a[4];
		a[2] = r;
		a[3] = t;
		a[4] = b;
		a[6] = s;
		a[7] = w;
		a[8] = c;
		a[9] = n;
		a[11] = v;
		a[12] = d;
		a[13] = p;
		a[14] = u;
		return this
	};
	a.kmMat4Multiply = function(a, b, c) {
		var d = a.mat,
			n = b.mat,
			p = c.mat;
		c = n[0];
		b = n[1];
		var r = n[2],
			s = n[3],
			u = n[4],
			t = n[5],
			w = n[6],
			v = n[7],
			y = n[8],
			z = n[9],
			F = n[10],
			E = n[11],
			C = n[12],
			A = n[13],
			x = n[14],
			n = n[15],
			B = p[0],
			G = p[1],
			D = p[2],
			J = p[3],
			H = p[4],
			L = p[5],
			N = p[6],
			M = p[7],
			P = p[8],
			I = p[9],
			K = p[10],
			O = p[11],
			Q = p[12],
			R = p[13],
			S = p[14],
			p = p[15];
		d[0] = B * c + G * u + D * y + J * C;
		d[1] = B * b + G * t + D * z + J * A;
		d[2] = B * r + G * w + D * F + J * x;
		d[3] = B * s + G * v + D * E + J * n;
		d[4] = H * c + L * u + N * y + M * C;
		d[5] = H * b + L * t + N * z + M * A;
		d[6] = H * r + L * w + N * F + M * x;
		d[7] = H * s + L * v + N * E + M * n;
		d[8] = P * c + I * u + K * y + O * C;
		d[9] = P * b + I * t + K * z + O * A;
		d[10] = P * r + I * w + K * F + O * x;
		d[11] = P * s + I * v + K * E + O * n;
		d[12] = Q * c + R * u + S * y + p * C;
		d[13] = Q * b + R * t + S * z + p * A;
		d[14] = Q * r + R * w + S * F + p * x;
		d[15] = Q * s + R * v + S * E + p * n;
		return a
	};
	b.multiply = function(a) {
		var b = this.mat,
			c = a.mat;
		a = b[0];
		var d = b[1],
			n = b[2],
			p = b[3],
			r = b[4],
			s = b[5],
			u = b[6],
			t = b[7],
			w = b[8],
			v = b[9],
			y = b[10],
			z = b[11],
			F = b[12],
			E = b[13],
			C = b[14],
			A = b[15],
			x = c[0],
			B = c[1],
			G = c[2],
			D = c[3],
			J = c[4],
			H = c[5],
			L = c[6],
			N = c[7],
			M = c[8],
			P = c[9],
			I = c[10],
			K = c[11],
			O = c[12],
			Q = c[13],
			R = c[14],
			c = c[15];
		b[0] = x * a + B * r + G * w + D * F;
		b[1] = x * d + B * s + G * v + D * E;
		b[2] = x * n + B * u + G * y + D * C;
		b[3] = x * p + B * t + G * z + D * A;
		b[4] = J * a + H * r + L * w + N * F;
		b[5] = J * d + H * s + L * v + N * E;
		b[6] = J * n + H * u + L * y + N * C;
		b[7] = J * p + H * t + L * z + N * A;
		b[8] = M * a + P * r + I * w + K * F;
		b[9] = M * d + P * s + I * v + K * E;
		b[10] = M * n + P * u + I * y + K * C;
		b[11] = M * p + P * t + I * z + K * A;
		b[12] = O * a + Q * r + R * w + c * F;
		b[13] = O * d + Q * s + R * v + c * E;
		b[14] = O * n + Q * u + R * y + c * C;
		b[15] = O * p + Q * t + R * z + c * A;
		return this
	};
	a.getMat4MultiplyValue = function(a, b) {
		var c = a.mat,
			d = b.mat,
			n = new Float32Array(16);
		n[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3];
		n[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3];
		n[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3];
		n[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3];
		n[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7];
		n[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7];
		n[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7];
		n[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7];
		n[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11];
		n[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11];
		n[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11];
		n[11] = c[3] * d[8] + c[7] * d[9] + c[11] * d[10] + c[15] * d[11];
		n[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15];
		n[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15];
		n[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15];
		n[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15];
		return n
	};
	a.kmMat4Assign = function(b, c) {
		if (b === c) return a.log("cc.kmMat4Assign(): pOut equals pIn"), b;
		var d = b.mat,
			m = c.mat;
		d[0] = m[0];
		d[1] = m[1];
		d[2] = m[2];
		d[3] = m[3];
		d[4] = m[4];
		d[5] = m[5];
		d[6] = m[6];
		d[7] = m[7];
		d[8] = m[8];
		d[9] = m[9];
		d[10] = m[10];
		d[11] = m[11];
		d[12] = m[12];
		d[13] = m[13];
		d[14] = m[14];
		d[15] = m[15];
		return b
	};
	b.assignFrom = function(b) {
		if (this === b) return a.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"), this;
		var c = this.mat;
		b = b.mat;
		c[0] = b[0];
		c[1] = b[1];
		c[2] = b[2];
		c[3] = b[3];
		c[4] = b[4];
		c[5] = b[5];
		c[6] = b[6];
		c[7] = b[7];
		c[8] = b[8];
		c[9] = b[9];
		c[10] = b[10];
		c[11] = b[11];
		c[12] = b[12];
		c[13] = b[13];
		c[14] = b[14];
		c[15] = b[15];
		return this
	};
	b.equals = function(b) {
		if (this === b) return a.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
		var c = this.mat;
		b = b.mat;
		for (var d = a.math.EPSILON, m = 0; 16 > m; m++)
		if (!(c[m] + d > b[m] && c[m] - d < b[m])) return !1;
		return !0
	};
	a.math.Matrix4.createByRotationX = function(b, c) {
		c = c || new a.math.Matrix4;
		var d = c.mat;
		d[0] = 1;
		d[3] = d[2] = d[1] = 0;
		d[4] = 0;
		d[5] = Math.cos(b);
		d[6] = Math.sin(b);
		d[7] = 0;
		d[8] = 0;
		d[9] = -Math.sin(b);
		d[10] = Math.cos(b);
		d[11] = 0;
		d[14] = d[13] = d[12] = 0;
		d[15] = 1;
		return c
	};
	a.math.Matrix4.createByRotationY = function(b, c) {
		c = c || new a.math.Matrix4;
		var d = c.mat;
		d[0] = Math.cos(b);
		d[1] = 0;
		d[2] = -Math.sin(b);
		d[3] = 0;
		d[7] = d[6] = d[4] = 0;
		d[5] = 1;
		d[8] = Math.sin(b);
		d[9] = 0;
		d[10] = Math.cos(b);
		d[11] = 0;
		d[14] = d[13] = d[12] = 0;
		d[15] = 1;
		return c
	};
	a.math.Matrix4.createByRotationZ = function(b, c) {
		c = c || new a.math.Matrix4;
		var d = c.mat;
		d[0] = Math.cos(b);
		d[1] = Math.sin(b);
		d[3] = d[2] = 0;
		d[4] = -Math.sin(b);
		d[5] = Math.cos(b);
		d[7] = d[6] = 0;
		d[11] = d[9] = d[8] = 0;
		d[10] = 1;
		d[14] = d[13] = d[12] = 0;
		d[15] = 1;
		return c
	};
	a.math.Matrix4.createByPitchYawRoll = function(b, c, d, m) {
		m = m || new a.math.Matrix4;
		var n = Math.cos(b);
		b = Math.sin(b);
		var p = Math.cos(c);
		c = Math.sin(c);
		var r = Math.cos(d);
		d = Math.sin(d);
		var s = b * c,
			u = n * c,
			t = m.mat;
		t[0] = p * r;
		t[4] = p * d;
		t[8] = -c;
		t[1] = s * r - n * d;
		t[5] = s * d + n * r;
		t[9] = b * p;
		t[2] = u * r + b * d;
		t[6] = u * d - b * r;
		t[10] = n * p;
		t[3] = t[7] = t[11] = 0;
		t[15] = 1;
		return m
	};
	a.math.Matrix4.createByQuaternion = function(b, c) {
		c = c || new a.math.Matrix4;
		var d = c.mat;
		d[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
		d[1] = 2 * (b.x * b.y + b.z * b.w);
		d[2] = 2 * (b.x * b.z - b.y * b.w);
		d[3] = 0;
		d[4] = 2 * (b.x * b.y - b.z * b.w);
		d[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
		d[6] = 2 * (b.z * b.y + b.x * b.w);
		d[7] = 0;
		d[8] = 2 * (b.x * b.z + b.y * b.w);
		d[9] = 2 * (b.y * b.z - b.x * b.w);
		d[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
		d[11] = 0;
		d[14] = d[13] = d[12] = 0;
		d[15] = 1;
		return c
	};
	a.math.Matrix4.createByRotationTranslation = function(b, c, d) {
		d = d || new a.math.Matrix4;
		var m = d.mat;
		b = b.mat;
		m[0] = b[0];
		m[1] = b[1];
		m[2] = b[2];
		m[3] = 0;
		m[4] = b[3];
		m[5] = b[4];
		m[6] = b[5];
		m[7] = 0;
		m[8] = b[6];
		m[9] = b[7];
		m[10] = b[8];
		m[11] = 0;
		m[12] = c.x;
		m[13] = c.y;
		m[14] = c.z;
		m[15] = 1;
		return d
	};
	a.math.Matrix4.createByScale = function(b, c, d, m) {
		m = m || new a.math.Matrix4;
		var n = m.mat;
		n[0] = b;
		n[5] = c;
		n[10] = d;
		n[15] = 1;
		n[1] = n[2] = n[3] = n[4] = n[6] = n[7] = n[8] = n[9] = n[11] = n[12] = n[13] = n[14] = 0;
		return m
	};
	a.kmMat4Translation = function(a, b, c, d) {
		a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
		a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
		a.mat[12] = b;
		a.mat[13] = c;
		a.mat[14] = d;
		return a
	};
	a.math.Matrix4.createByTranslation = function(b, c, d, m) {
		m = m || new a.math.Matrix4;
		m.identity();
		m.mat[12] = b;
		m.mat[13] = c;
		m.mat[14] = d;
		return m
	};
	b.getUpVec3 = function() {
		var b = this.mat;
		return (new a.math.Vec3(b[4], b[5], b[6])).normalize()
	};
	b.getRightVec3 = function() {
		var b = this.mat;
		return (new a.math.Vec3(b[0], b[1], b[2])).normalize()
	};
	b.getForwardVec3 = function() {
		var b = this.mat;
		return (new a.math.Vec3(b[8], b[9], b[10])).normalize()
	};
	a.kmMat4PerspectiveProjection = function(b, c, d, m, n) {
		var p = a.degreesToRadians(c / 2);
		c = n - m;
		var r = Math.sin(p);
		if (0 === c || 0 === r || 0 === d) return null;
		p = Math.cos(p) / r;
		b.identity();
		b.mat[0] = p / d;
		b.mat[5] = p;
		b.mat[10] = -(n + m) / c;
		b.mat[11] = -1;
		b.mat[14] = -2 * m * n / c;
		b.mat[15] = 0;
		return b
	};
	a.math.Matrix4.createPerspectiveProjection = function(b, c, d, m) {
		var n = a.degreesToRadians(b / 2);
		b = m - d;
		var p = Math.sin(n);
		if (0 === b || 0 === p || 0 === c) return null;
		var n = Math.cos(n) / p,
			p = new a.math.Matrix4,
			r = p.mat;
		p.identity();
		r[0] = n / c;
		r[5] = n;
		r[10] = -(m + d) / b;
		r[11] = -1;
		r[14] = -2 * d * m / b;
		r[15] = 0;
		return p
	};
	a.kmMat4OrthographicProjection = function(a, b, c, d, n, p, r) {
		a.identity();
		a.mat[0] = 2 / (c - b);
		a.mat[5] = 2 / (n - d);
		a.mat[10] = -2 / (r - p);
		a.mat[12] = -((c + b) / (c - b));
		a.mat[13] = -((n + d) / (n - d));
		a.mat[14] = -((r + p) / (r - p));
		return a
	};
	a.math.Matrix4.createOrthographicProjection = function(b, c, d, m, n, p) {
		var r = new a.math.Matrix4,
			s = r.mat;
		r.identity();
		s[0] = 2 / (c - b);
		s[5] = 2 / (m - d);
		s[10] = -2 / (p - n);
		s[12] = -((c + b) / (c - b));
		s[13] = -((m + d) / (m - d));
		s[14] = -((p + n) / (p - n));
		return r
	};
	a.kmMat4LookAt = function(b, c, d, m) {
		d = new a.math.Vec3(d);
		var n = new a.math.Vec3(m);
		d.subtract(c);
		d.normalize();
		n.normalize();
		m = new a.math.Vec3(d);
		m.cross(n);
		m.normalize();
		n = new a.math.Vec3(m);
		n.cross(d);
		m.normalize();
		b.identity();
		b.mat[0] = m.x;
		b.mat[4] = m.y;
		b.mat[8] = m.z;
		b.mat[1] = n.x;
		b.mat[5] = n.y;
		b.mat[9] = n.z;
		b.mat[2] = -d.x;
		b.mat[6] = -d.y;
		b.mat[10] = -d.z;
		c = a.math.Matrix4.createByTranslation(-c.x, -c.y, -c.z);
		b.multiply(c);
		return b
	};
	var d = new a.math.Matrix4;
	b.lookAt = function(b, c, k) {
		c = new a.math.Vec3(c);
		var m = new a.math.Vec3(k);
		k = this.mat;
		c.subtract(b);
		c.normalize();
		m.normalize();
		var n = new a.math.Vec3(c);
		n.cross(m);
		n.normalize();
		m = new a.math.Vec3(n);
		m.cross(c);
		n.normalize();
		this.identity();
		k[0] = n.x;
		k[4] = n.y;
		k[8] = n.z;
		k[1] = m.x;
		k[5] = m.y;
		k[9] = m.z;
		k[2] = -c.x;
		k[6] = -c.y;
		k[10] = -c.z;
		d = a.math.Matrix4.createByTranslation(-b.x, -b.y, -b.z, d);
		this.multiply(d);
		return this
	};
	a.kmMat4RotationAxisAngle = function(b, c, d) {
		var m = Math.cos(d);
		d = Math.sin(d);
		c = new a.math.Vec3(c);
		c.normalize();
		b.mat[0] = m + c.x * c.x * (1 - m);
		b.mat[1] = c.z * d + c.y * c.x * (1 - m);
		b.mat[2] = -c.y * d + c.z * c.x * (1 - m);
		b.mat[3] = 0;
		b.mat[4] = -c.z * d + c.x * c.y * (1 - m);
		b.mat[5] = m + c.y * c.y * (1 - m);
		b.mat[6] = c.x * d + c.z * c.y * (1 - m);
		b.mat[7] = 0;
		b.mat[8] = c.y * d + c.x * c.z * (1 - m);
		b.mat[9] = -c.x * d + c.y * c.z * (1 - m);
		b.mat[10] = m + c.z * c.z * (1 - m);
		b.mat[11] = 0;
		b.mat[12] = 0;
		b.mat[13] = 0;
		b.mat[14] = 0;
		b.mat[15] = 1;
		return b
	};
	a.math.Matrix4.createByAxisAndAngle = function(b, c, d) {
		d = d || new a.math.Matrix4;
		var m = this.mat,
			n = Math.cos(c);
		c = Math.sin(c);
		b = new a.math.Vec3(b);
		b.normalize();
		m[0] = n + b.x * b.x * (1 - n);
		m[1] = b.z * c + b.y * b.x * (1 - n);
		m[2] = -b.y * c + b.z * b.x * (1 - n);
		m[3] = 0;
		m[4] = -b.z * c + b.x * b.y * (1 - n);
		m[5] = n + b.y * b.y * (1 - n);
		m[6] = b.x * c + b.z * b.y * (1 - n);
		m[7] = 0;
		m[8] = b.y * c + b.x * b.z * (1 - n);
		m[9] = -b.x * c + b.y * b.z * (1 - n);
		m[10] = n + b.z * b.z * (1 - n);
		m[11] = 0;
		m[12] = m[13] = m[14] = 0;
		m[15] = 1;
		return d
	};
	b.extractRotation = function() {
		var b = new a.math.Matrix3,
			c = this.mat,
			d = b.mat;
		d[0] = c[0];
		d[1] = c[1];
		d[2] = c[2];
		d[3] = c[4];
		d[4] = c[5];
		d[5] = c[6];
		d[6] = c[8];
		d[7] = c[9];
		d[8] = c[10];
		return b
	};
	b.extractPlane = function(b) {
		var c = new a.math.Plane,
			d = this.mat;
		switch (b) {
		case a.math.Plane.RIGHT:
			c.a = d[3] - d[0];
			c.b = d[7] - d[4];
			c.c = d[11] - d[8];
			c.d = d[15] - d[12];
			break;
		case a.math.Plane.LEFT:
			c.a = d[3] + d[0];
			c.b = d[7] + d[4];
			c.c = d[11] + d[8];
			c.d = d[15] + d[12];
			break;
		case a.math.Plane.BOTTOM:
			c.a = d[3] + d[1];
			c.b = d[7] + d[5];
			c.c = d[11] + d[9];
			c.d = d[15] + d[13];
			break;
		case a.math.Plane.TOP:
			c.a = d[3] - d[1];
			c.b = d[7] - d[5];
			c.c = d[11] - d[9];
			c.d = d[15] - d[13];
			break;
		case a.math.Plane.FAR:
			c.a = d[3] - d[2];
			c.b = d[7] - d[6];
			c.c = d[11] - d[10];
			c.d = d[15] - d[14];
			break;
		case a.math.Plane.NEAR:
			c.a = d[3] + d[2];
			c.b = d[7] + d[6];
			c.c = d[11] + d[10];
			c.d = d[15] + d[14];
			break;
		default:
			a.log("cc.math.Matrix4.extractPlane: Invalid plane index")
		}
		b = Math.sqrt(c.a * c.a + c.b * c.b + c.c * c.c);
		c.a /= b;
		c.b /= b;
		c.c /= b;
		c.d /= b;
		return c
	};
	b.toAxisAndAngle = function() {
		var b = this.extractRotation();
		return a.math.Quaternion.rotationMatrix(b).toAxisAndAngle()
	}
})(cc);
(function(a) {
	a.math.Plane = function(a, b, e, f) {
		a && void 0 === b ? (this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d) : (this.a = a || 0, this.b = b || 0, this.c = e || 0, this.d = f || 0)
	};
	a.kmPlane = a.math.Plane;
	var b = a.math.Plane.prototype;
	a.math.Plane.LEFT = 0;
	a.math.Plane.RIGHT = 1;
	a.math.Plane.BOTTOM = 2;
	a.math.Plane.TOP = 3;

	a.math.Plane.NEAR = 4;
	a.math.Plane.FAR = 5;
	a.math.Plane.POINT_INFRONT_OF_PLANE = 0;
	a.math.Plane.POINT_BEHIND_PLANE = 1;
	a.math.Plane.POINT_ON_PLANE = 2;
	b.dot = function(a) {
		return this.a * a.x + this.b * a.y + this.c * a.z + this.d * a.w
	};
	b.dotCoord = function(a) {
		return this.a * a.x + this.b * a.y + this.c * a.z + this.d
	};
	b.dotNormal = function(a) {
		return this.a * a.x + this.b * a.y + this.c * a.z
	};
	a.math.Plane.fromPointNormal = function(b, d) {
		return new a.math.Plane(d.x, d.y, d.z, -d.dot(b))
	};
	a.math.Plane.fromPoints = function(b, d, e) {
		d = new a.math.Vec3(d);
		e = new a.math.Vec3(e);
		var f = new a.math.Plane;
		d.subtract(b);
		e.subtract(b);
		d.cross(e);
		d.normalize();
		f.a = d.x;
		f.b = d.y;
		f.c = d.z;
		f.d = d.scale(-1).dot(b);
		return f
	};
	b.normalize = function() {
		var b = new a.math.Vec3(this.a, this.b, this.c),
			d = 1 / b.length();
		b.normalize();
		this.a = b.x;
		this.b = b.y;
		this.c = b.z;
		this.d *= d;
		return this
	};
	b.classifyPoint = function(b) {
		b = this.a * b.x + this.b * b.y + this.c * b.z + this.d;
		return 0.0010 < b ? a.math.Plane.POINT_INFRONT_OF_PLANE : -0.0010 > b ? a.math.Plane.POINT_BEHIND_PLANE : a.math.Plane.POINT_ON_PLANE
	}
})(cc);
(function(a) {
	a.math.Quaternion = function(a, b, e, f) {
		a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = e || 0, this.w = f || 0)
	};
	a.kmQuaternion = a.math.Quaternion;
	var b = a.math.Quaternion.prototype;
	b.conjugate = function(a) {
		this.x = -a.x;
		this.y = -a.y;
		this.z = -a.z;
		this.w = a.w;
		return this
	};
	b.dot = function(a) {
		return this.w * a.w + this.x * a.x + this.y * a.y + this.z * a.z
	};
	b.exponential = function() {
		return this
	};
	b.identity = function() {
		this.z = this.y = this.x = 0;
		this.w = 1;
		return this
	};
	b.inverse = function() {
		var b = this.length();
		if (Math.abs(b) > a.math.EPSILON) return this.w = this.z = this.y = this.x = 0, this;
		this.conjugate(this).scale(1 / b);
		return this
	};
	b.isIdentity = function() {
		return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w
	};
	b.length = function() {
		return Math.sqrt(this.lengthSq())
	};
	b.lengthSq = function() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	};
	b.multiply = function(a) {
		var b = this.x,
			e = this.y,
			f = this.z,
			k = this.w;
		this.w = k * a.w - b * a.x - e * a.y - f * a.z;
		this.x = k * a.x + b * a.w + e * a.z - f * a.y;
		this.y = k * a.y + e * a.w + f * a.x - b * a.z;
		this.z = k * a.z + f * a.w + b * a.y - e * a.x;
		return this
	};
	b.normalize = function() {
		var b = this.length();
		if (Math.abs(b) <= a.math.EPSILON) throw Error("current quaternion is an invalid value");
		this.scale(1 / b);
		return this
	};
	b.rotationAxis = function(a, b) {
		var e = 0.5 * b,
			f = Math.sin(e);
		this.w = Math.cos(e);
		this.x = a.x * f;
		this.y = a.y * f;
		this.z = a.z * f;
		return this
	};
	a.math.Quaternion.rotationMatrix = function(b) {
		if (!b) return null;
		var d, e, f;
		d = [];
		e = b.mat;
		b = 0;
		d[0] = e[0];
		d[1] = e[3];
		d[2] = e[6];
		d[4] = e[1];
		d[5] = e[4];
		d[6] = e[7];
		d[8] = e[2];
		d[9] = e[5];
		d[10] = e[8];
		d[15] = 1;
		var k = d[0];
		b = k[0] + k[5] + k[10] + 1;
		b > a.math.EPSILON ? (b = 2 * Math.sqrt(b), d = (k[9] - k[6]) / b, e = (k[2] - k[8]) / b, f = (k[4] - k[1]) / b, b *= 0.25) : k[0] > k[5] && k[0] > k[10] ? (b = 2 * Math.sqrt(1 + k[0] - k[5] - k[10]), d = 0.25 * b, e = (k[4] + k[1]) / b, f = (k[2] + k[8]) / b, b = (k[9] - k[6]) / b) : k[5] > k[10] ? (b = 2 * Math.sqrt(1 + k[5] - k[0] - k[10]), d = (k[4] + k[1]) / b, e = 0.25 * b, f = (k[9] + k[6]) / b, b = (k[2] - k[8]) / b) : (b = 2 * Math.sqrt(1 + k[10] - k[0] - k[5]), d = (k[2] + k[8]) / b, e = (k[9] + k[6]) / b, f = 0.25 * b, b = (k[4] - k[1]) / b);
		return new a.math.Quaternion(d, e, f, b)
	};
	a.math.Quaternion.rotationYawPitchRoll = function(b, d, e) {
		var f, k, m, n, p;
		f = a.degreesToRadians(d) / 2;
		k = a.degreesToRadians(b) / 2;
		m = a.degreesToRadians(e) / 2;
		e = Math.cos(f);
		b = Math.cos(k);
		d = Math.cos(m);
		f = Math.sin(f);
		k = Math.sin(k);
		m = Math.sin(m);
		n = b * d;
		p = k * m;
		var r = new a.math.Quaternion;
		r.w = e * n + f * p;
		r.x = f * n - e * p;
		r.y = e * k * d + f * b * m;
		r.z = e * b * m - f * k * d;
		r.normalize();
		return r
	};
	b.slerp = function(b, d) {
		if (this.x === b.x && this.y === b.y && this.z === b.z && this.w === b.w) return this;
		var e = this.dot(b),
			f = Math.acos(e),
			k = Math.sqrt(1 - a.math.square(e)),
			e = Math.sin(d * f) / k,
			f = Math.sin((1 - d) * f) / k,
			k = new a.math.Quaternion(b);
		this.scale(f);
		k.scale(e);
		this.add(k);
		return this
	};
	b.toAxisAndAngle = function() {
		var b, d, e = new a.math.Vec3;
		b = Math.acos(this.w);
		d = Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z));
		d > -a.math.EPSILON && d < a.math.EPSILON || d < 2 * Math.PI + a.math.EPSILON && d > 2 * Math.PI - a.math.EPSILON ? (b = 0, e.x = 0, e.y = 0, e.z = 1) : (b *= 2, e.x = this.x / d, e.y = this.y / d, e.z = this.z / d, e.normalize());
		return {
			axis: e,
			angle: b
		}
	};
	b.scale = function(a) {
		this.x *= a;
		this.y *= a;
		this.z *= a;
		this.w *= a;
		return this
	};
	b.assignFrom = function(a) {
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		this.w = a.w;
		return this
	};
	b.add = function(a) {
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
		this.w += a.w;
		return this
	};
	a.math.Quaternion.rotationBetweenVec3 = function(b, d, e) {
		var f = new a.math.Vec3(b),
			k = new a.math.Vec3(d);
		f.normalize();
		k.normalize();
		var m = f.dot(k);
		d = new a.math.Quaternion;
		if (1 <= m) return d.identity(), d; - 0.999999 > m ? Math.abs(e.lengthSq()) < a.math.EPSILON ? d.rotationAxis(e, Math.PI) : (f = new a.math.Vec3(1, 0, 0), f.cross(b), Math.abs(f.lengthSq()) < a.math.EPSILON && (f.fill(0, 1, 0), f.cross(b)), f.normalize(), d.rotationAxis(f, Math.PI)) : (b = Math.sqrt(2 * (1 + m)), e = 1 / b, f.cross(k), d.x = f.x * e, d.y = f.y * e, d.z = f.z * e, d.w = 0.5 * b, d.normalize());
		return d
	};
	b.multiplyVec3 = function(b) {
		var d = this.x,
			e = this.y,
			f = this.z,
			k = new a.math.Vec3(b),
			m = new a.math.Vec3(d, e, f),
			d = new a.math.Vec3(d, e, f);
		m.cross(b);
		d.cross(m);
		m.scale(2 * q.w);
		d.scale(2);
		k.add(m);
		k.add(d);
		return k
	}
})(cc);
cc.math.AABB = function(a, b) {
	this.min = a || new cc.math.Vec3;
	this.max = b || new cc.math.Vec3
};
cc.math.AABB.prototype.containsPoint = function(a) {
	return a.x >= this.min.x && a.x <= this.max.x && a.y >= this.min.y && a.y <= this.max.y && a.z >= this.min.z && a.z <= this.max.z
};
cc.math.AABB.containsPoint = function(a, b) {
	return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z
};
cc.math.AABB.prototype.assignFrom = function(a) {
	this.min.assignFrom(a.min);
	this.max.assignFrom(a.max)
};
cc.math.AABB.assign = function(a, b) {
	a.min.assignFrom(b.min);
	a.max.assignFrom(b.max);
	return a
};
(function(a) {
	a.math.Matrix4Stack = function(a, b) {
		this.top = a;
		this.stack = b || []
	};
	a.km_mat4_stack = a.math.Matrix4Stack;
	var b = a.math.Matrix4Stack.prototype;
	b.initialize = function() {
		this.stack.length = 0;
		this.top = null
	};
	a.km_mat4_stack_push = function(b, d) {
		b.stack.push(b.top);
		b.top = new a.math.Matrix4(d)
	};
	a.km_mat4_stack_pop = function(a, b) {
		a.top = a.stack.pop()
	};
	a.km_mat4_stack_release = function(a) {
		a.stack = null;
		a.top = null
	};
	b.push = function(b) {
		b = b || this.top;
		this.stack.push(this.top);
		this.top = new a.math.Matrix4(b)
	};
	b.pop = function() {
		this.top = this.stack.pop()
	};
	b.release = function() {
		this._matrixPool = this.top = this.stack = null
	};
	b._getFromPool = function(b) {
		var d = this._matrixPool;
		if (0 === d.length) return new a.math.Matrix4(b);
		d = d.pop();
		d.assignFrom(b);
		return d
	};
	b._putInPool = function(a) {
		this._matrixPool.push(a)
	}
})(cc);
(function(a) {
	a.KM_GL_MODELVIEW = 5888;
	a.KM_GL_PROJECTION = 5889;
	a.KM_GL_TEXTURE = 5890;
	a.modelview_matrix_stack = new a.math.Matrix4Stack;
	a.projection_matrix_stack = new a.math.Matrix4Stack;
	a.texture_matrix_stack = new a.math.Matrix4Stack;
	a.current_stack = null;
	a.lazyInitialize = function() {
		var b = new a.math.Matrix4;
		a.modelview_matrix_stack.initialize();
		a.projection_matrix_stack.initialize();
		a.texture_matrix_stack.initialize();
		a.current_stack = a.modelview_matrix_stack;
		a.initialized = !0;
		b.identity();
		a.modelview_matrix_stack.push(b);
		a.projection_matrix_stack.push(b);
		a.texture_matrix_stack.push(b)
	};
	a.lazyInitialize();
	a.kmGLFreeAll = function() {
		a.modelview_matrix_stack.release();
		a.modelview_matrix_stack = null;
		a.projection_matrix_stack.release();
		a.projection_matrix_stack = null;
		a.texture_matrix_stack.release();
		a.texture_matrix_stack = null;
		a.initialized = !1;
		a.current_stack = null
	};
	a.kmGLPushMatrix = function() {
		a.current_stack.push(a.current_stack.top)
	};
	a.kmGLPushMatrixWitMat4 = function(b) {
		a.current_stack.stack.push(a.current_stack.top);
		b.assignFrom(a.current_stack.top);
		a.current_stack.top = b
	};
	a.kmGLPopMatrix = function() {
		a.current_stack.top = a.current_stack.stack.pop()
	};
	a.kmGLMatrixMode = function(b) {
		switch (b) {
		case a.KM_GL_MODELVIEW:
			a.current_stack = a.modelview_matrix_stack;
			break;
		case a.KM_GL_PROJECTION:
			a.current_stack = a.projection_matrix_stack;
			break;
		case a.KM_GL_TEXTURE:
			a.current_stack = a.texture_matrix_stack;
			break;
		default:
			throw Error("Invalid matrix mode specified");
		}
	};
	a.kmGLLoadIdentity = function() {
		a.current_stack.top.identity()
	};
	a.kmGLLoadMatrix = function(b) {
		a.current_stack.top.assignFrom(b)
	};
	a.kmGLMultMatrix = function(b) {
		a.current_stack.top.multiply(b)
	};
	var b = new a.math.Matrix4;
	a.kmGLTranslatef = function(c, e, f) {
		c = a.math.Matrix4.createByTranslation(c, e, f, b);
		a.current_stack.top.multiply(c)
	};
	var c = new a.math.Vec3;
	a.kmGLRotatef = function(d, e, f, k) {
		c.fill(e, f, k);
		d = a.math.Matrix4.createByAxisAndAngle(c, a.degreesToRadians(d), b);
		a.current_stack.top.multiply(d)
	};
	a.kmGLScalef = function(c, e, f) {
		c = a.math.Matrix4.createByScale(c, e, f, b);
		a.current_stack.top.multiply(c)
	};
	a.kmGLGetMatrix = function(b, c) {
		switch (b) {
		case a.KM_GL_MODELVIEW:
			c.assignFrom(a.modelview_matrix_stack.top);
			break;
		case a.KM_GL_PROJECTION:
			c.assignFrom(a.projection_matrix_stack.top);
			break;
		case a.KM_GL_TEXTURE:
			c.assignFrom(a.texture_matrix_stack.top);
			break;
		default:
			throw Error("Invalid matrix mode specified");
		}
	}
})(cc);
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
	TYPE_POSITION_TEXTURECOLOR: 0,
	TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
	TYPE_POSITION_COLOR: 2,
	TYPE_POSITION_TEXTURE: 3,
	TYPE_POSITION_TEXTURE_UCOLOR: 4,
	TYPE_POSITION_TEXTURE_A8COLOR: 5,
	TYPE_POSITION_UCOLOR: 6,
	TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
	TYPE_MAX: 8,
	_programs: {},
	_init: function() {
		this.loadDefaultShaders();
		return !0
	},
	_loadDefaultShader: function(a, b) {
		switch (b) {
		case this.TYPE_POSITION_TEXTURECOLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_COLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			break;
		case this.TYPE_POSITION_TEXTURE:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURE_UCOLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_TEXTURE_A8COLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			break;
		case this.TYPE_POSITION_UCOLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
			a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
			break;
		case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
			a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
			a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
			a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
			a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
			break;
		default:
			cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
			return
		}
		a.link();
		a.updateUniforms()
	},
	loadDefaultShaders: function() {
		var a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
		this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = a;
		this._programs.ShaderPositionTextureColor = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
		this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
		this._programs.ShaderPositionTextureColorAlphaTest = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
		this._programs[cc.SHADER_POSITION_COLOR] = a;
		this._programs.ShaderPositionColor = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
		this._programs[cc.SHADER_POSITION_TEXTURE] = a;
		this._programs.ShaderPositionTexture = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
		this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
		this._programs.ShaderPositionTextureUColor = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
		this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
		this._programs.ShaderPositionTextureA8Color = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
		this._programs[cc.SHADER_POSITION_UCOLOR] = a;
		this._programs.ShaderPositionUColor = a;
		a = new cc.GLProgram;
		this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
		this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
		this._programs.ShaderPositionLengthTextureColor = a
	},
	reloadDefaultShaders: function() {
		var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
		a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
		a = this.programForKey(cc.SHADER_POSITION_COLOR);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
		a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
		a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
		a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
		a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
		a.reset();
		this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
	},
	programForKey: function(a) {
		return this._programs[a]
	},
	getProgram: function(a) {
		return this._programs[a]
	},
	addProgram: function(a, b) {
		this._programs[b] = a
	}
};
cc.HashUniformEntry = function(a, b, c) {
	this.value = a;
	this.location = b;
	this.hh = c || {}
};
cc.GLProgram = cc.Class.extend({
	_glContext: null,
	_programObj: null,
	_vertShader: null,
	_fragShader: null,
	_uniforms: null,
	_hashForUniforms: null,
	_usesTime: !1,
	_updateUniformLocation: function(a, b, c) {
		if (null == a) return !1;
		c = !0;
		for (var d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
		d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d));
		return c
	},
	_description: function() {
		return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
	},
	_compileShader: function(a, b, c) {
		if (!c || !a) return !1;
		c = (cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n") + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" + c;
		this._glContext.shaderSource(a, c);
		this._glContext.compileShader(a);
		c = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
		c || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
		return !0 === c
	},
	ctor: function(a, b, c) {
		this._uniforms = [];
		this._hashForUniforms = [];
		this._glContext = c || cc._renderContext;
		a && b && this.init(a, b)
	},
	destroyProgram: function() {
		this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null;
		this._glContext.deleteProgram(this._programObj)
	},
	initWithVertexShaderByteArray: function(a, b) {
		var c = this._glContext;
		this._programObj = c.createProgram();
		this._fragShader = this._vertShader = null;
		a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
		b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader, c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
		this._vertShader && c.attachShader(this._programObj, this._vertShader);
		cc.checkGLErrorDebug();
		this._fragShader && c.attachShader(this._programObj, this._fragShader);
		this._hashForUniforms.length = 0;
		cc.checkGLErrorDebug();
		return !0
	},
	initWithString: function(a, b) {
		return this.initWithVertexShaderByteArray(a, b)
	},
	initWithVertexShaderFilename: function(a, b) {
		var c = cc.loader.getRes(a);
		if (!c) throw Error("Please load the resource firset : " + a);
		var d = cc.loader.getRes(b);
		if (!d) throw Error("Please load the resource firset : " + b);
		return this.initWithVertexShaderByteArray(c, d)
	},
	init: function(a, b) {
		return this.initWithVertexShaderFilename(a, b)
	},
	addAttribute: function(a, b) {
		this._glContext.bindAttribLocation(this._programObj, b, a)
	},
	link: function() {
		if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
		this._glContext.linkProgram(this._programObj);
		this._vertShader && this._glContext.deleteShader(this._vertShader);
		this._fragShader && this._glContext.deleteShader(this._fragShader);
		this._fragShader = this._vertShader = null;
		return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
	},
	use: function() {
		cc.glUseProgram(this._programObj)
	},
	updateUniforms: function() {
		this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
		this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
		this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
		this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
		this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
		this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
		this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
		this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
		this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
		this.use();
		this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
	},
	getUniformLocationForName: function(a) {
		if (!a) throw Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
		if (!this._programObj) throw Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
		return this._glContext.getUniformLocation(this._programObj, a)
	},
	getUniformMVPMatrix: function() {
		return this._uniforms[cc.UNIFORM_MVPMATRIX]
	},
	getUniformSampler: function() {
		return this._uniforms[cc.UNIFORM_SAMPLER]
	},
	setUniformLocationWith1i: function(a, b) {
		this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
	},
	setUniformLocationWith2i: function(a, b, c) {
		this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2i(a, b, c)
	},
	setUniformLocationWith3i: function(a, b, c, d) {
		this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3i(a, b, c, d)
	},
	setUniformLocationWith4i: function(a, b, c, d, e) {
		this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4i(a, b, c, d, e)
	},
	setUniformLocationWith2iv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform2iv(a, b)
	},
	setUniformLocationWith3iv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
	},
	setUniformLocationWith4iv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
	},
	setUniformLocationI32: function(a, b) {
		this.setUniformLocationWith1i(a, b)
	},
	setUniformLocationWith1f: function(a, b) {
		this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
	},
	setUniformLocationWith2f: function(a, b, c) {
		this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2f(a, b, c)
	},
	setUniformLocationWith3f: function(a, b, c, d) {
		this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3f(a, b, c, d)
	},
	setUniformLocationWith4f: function(a, b, c, d, e) {
		this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4f(a, b, c, d, e)
	},
	setUniformLocationWith2fv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
	},
	setUniformLocationWith3fv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform3fv(a, b)
	},
	setUniformLocationWith4fv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
	},
	setUniformLocationWithMatrix4fv: function(a, b, c) {
		this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
	},
	setUniformLocationF32: function() {
		if (!(2 > arguments.length)) switch (arguments.length) {
		case 2:
			this.setUniformLocationWith1f(arguments[0], arguments[1]);
			break;
		case 3:
			this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
			break;
		case 4:
			this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
			break;
		case 5:
			this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
		}
	},
	setUniformsForBuiltins: function() {
		var a = new cc.math.Matrix4,
			b = new cc.math.Matrix4,
			c = new cc.math.Matrix4;
		cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
		cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
		cc.kmMat4Multiply(c, a, b);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], b.mat, 1);
		this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
		this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
	},
	_setUniformsForBuiltinsForRenderer: function(a) {
		if (a && a._renderCmd) {
			var b = new cc.math.Matrix4,
				c = new cc.math.Matrix4;
			cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
			cc.kmMat4Multiply(c, b, a._renderCmd._stackMatrix);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], b.mat, 1);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], a._renderCmd._stackMatrix.mat, 1);
			this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
			this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
		}
	},
	setUniformForModelViewProjectionMatrix: function() {
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
	},
	setUniformForModelViewProjectionMatrixWithMat4: function(a) {
		cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
	},
	setUniformForModelViewAndProjectionMatrixWithMat4: function() {
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
	},
	_setUniformForMVPMatrixWithMat4: function(a) {
		if (!a) throw Error("modelView matrix is undefined.");
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, a.mat);
		this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
	},
	vertexShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	getVertexShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	getFragmentShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._vertShader)
	},
	fragmentShaderLog: function() {
		return this._glContext.getShaderInfoLog(this._fragShader)
	},
	programLog: function() {
		return this._glContext.getProgramInfoLog(this._programObj)
	},
	getProgramLog: function() {
		return this._glContext.getProgramInfoLog(this._programObj)
	},
	reset: function() {
		this._fragShader = this._vertShader = null;
		this._uniforms.length = 0;
		this._glContext.deleteProgram(this._programObj);
		this._programObj = null;
		for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
		this._hashForUniforms.length = 0
	},
	getProgram: function() {
		return this._programObj
	},
	retain: function() {},
	release: function() {}
});
cc.GLProgram.create = function(a, b) {
	return new cc.GLProgram(a, b)
};
cc.GLProgram._highpSupported = null;
cc.GLProgram._isHighpSupported = function() {
	if (null == cc.GLProgram._highpSupported) {
		var a = cc._renderContext,
			a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
		cc.GLProgram._highpSupported = 0 !== a.precision
	}
	return cc.GLProgram._highpSupported
};
cc.setProgram = function(a, b) {
	a.shaderProgram = b;
	var c = a.children;
	if (c) for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
	cc.kmGLFreeAll();
	cc._currentProjectionMatrix = -1;
	cc._vertexAttribPosition = !1;
	cc._vertexAttribColor = !1;
	cc._vertexAttribTexCoords = !1;
	if (cc.ENABLE_GL_STATE_CACHE) {
		cc._currentShaderProgram = -1;
		for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
		cc._blendingSource = -1;
		cc._blendingDest = -1;
		cc._GLServerState = 0
	}
};
cc.glUseProgram = function(a) {
	a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
	cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function(a) {
	cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
	gl.deleteProgram(a)
};
cc.glBlendFunc = function(a, b) {
	if (a !== cc._blendingSource || b !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function(a, b) {
	var c = cc._renderContext;
	a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function(a, b) {
	if (a !== cc._blendingSource || b !== cc._blendingDest) {
		cc._blendingSource = a;
		cc._blendingDest = b;
		var c = cc._renderContext;
		a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
	}
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
	var a = cc._renderContext;
	a.blendEquation(a.FUNC_ADD);
	cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
	cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(a) {
	var b = cc._renderContext,
		c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
	c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c);
	c = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
	c !== cc._vertexAttribColor && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = c);
	a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
	a !== cc._vertexAttribTexCoords && (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function(a) {
	cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function(a, b) {
	if (cc._currentBoundTexture[a] !== b) {
		cc._currentBoundTexture[a] = b;
		var c = cc._renderContext;
		c.activeTexture(c.TEXTURE0 + a);
		b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
	}
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
	var c = cc._renderContext;
	c.activeTexture(c.TEXTURE0 + a);
	b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(a) {
	cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function(a, b) {
	cc.ENABLE_GL_STATE_CACHE && b === cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
	cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function(a) {
	cc.TEXTURE_ATLAS_USE_VAO && (cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== a) && (cc._uVAO = a)
};
cc.glEnable = function(a) {};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(a) {
	a -= 1;
	a |= a >> 1;
	a |= a >> 2;
	a |= a >> 4;
	a |= a >> 8;
	return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
	sprite: null,
	clearFlags: 0,
	clearDepthVal: 0,
	autoDraw: !1,
	_texture: null,
	_pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
	clearStencilVal: 0,
	_clearColor: null,
	_className: "RenderTexture",
	ctor: function(a, b, c, d) {
		cc.Node.prototype.ctor.call(this);
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
		this._clearColor = new cc.Color(0, 0, 0, 255);
		void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0));
		this.setAnchorPoint(0, 0)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
	},
	cleanup: function() {
		cc.Node.prototype.onExit.call(this);
		this._renderCmd.cleanup()
	},
	getSprite: function() {
		return this.sprite
	},
	setSprite: function(a) {
		this.sprite = a
	},
	setVirtualViewport: function(a, b, c) {
		this._renderCmd.setVirtualViewport(a, b, c)
	},
	initWithWidthAndHeight: function(a, b, c, d) {
		return this._renderCmd.initWithWidthAndHeight(a, b, c, d)
	},
	begin: function() {
		cc.renderer._turnToCacheMode(this.__instanceId);
		this._renderCmd.begin()
	},
	beginWithClear: function(a, b, c, d, e, f) {
		var k = cc._renderContext;
		e = e || k.COLOR_BUFFER_BIT;
		f = f || k.COLOR_BUFFER_BIT | k.DEPTH_BUFFER_BIT;
		this._beginWithClear(a, b, c, d, e, f, k.COLOR_BUFFER_BIT | k.DEPTH_BUFFER_BIT | k.STENCIL_BUFFER_BIT)
	},
	_beginWithClear: function(a, b, c, d, e, f, k) {
		this.begin();
		this._renderCmd._beginWithClear(a, b, c, d, e, f, k)
	},
	end: function() {
		this._renderCmd.end()
	},
	clear: function(a, b, c, d) {
		this.beginWithClear(a, b, c, d);
		this.end()
	},
	clearRect: function(a, b, c, d) {
		this._renderCmd.clearRect(a, b, c, d)
	},
	clearDepth: function(a) {
		this._renderCmd.clearDepth(a)
	},
	clearStencil: function(a) {
		this._renderCmd.clearStencil(a)
	},
	getClearFlags: function() {
		return this.clearFlags
	},
	setClearFlags: function(a) {
		this.clearFlags = a
	},
	getClearColor: function() {
		return this._clearColor
	},
	setClearColor: function(a) {
		var b = this._clearColor;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		b.a = a.a;
		this._renderCmd.updateClearColor(a)
	},
	getClearDepth: function() {
		return this.clearDepthVal
	},
	setClearDepth: function(a) {
		this.clearDepthVal = a
	},
	getClearStencil: function() {
		return this.clearStencilVal
	},
	setClearStencil: function(a) {
		this.clearStencilVal = a
	},
	isAutoDraw: function() {
		return this.autoDraw
	},
	setAutoDraw: function(a) {
		this.autoDraw = a
	},
	saveToFile: function(a, b) {
		cc.log("saveToFile isn't supported on Cocos2d-Html5")
	},
	newCCImage: function(a) {
		cc.log("saveToFile isn't supported on cocos2d-html5");
		return null
	},
	listenToBackground: function(a) {},
	listenToForeground: function(a) {}
});
_p = cc.RenderTexture.prototype;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(a, b, c, d) {
	return new cc.RenderTexture(a, b, c, d)
};
(function() {
	cc.RenderTexture.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._clearColorStr = "rgba(255,255,255,1)";
		this._cacheCanvas = cc.newElement("canvas");
		this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"))
	};
	var a = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.RenderTexture.CanvasRenderCmd;
	a.cleanup = function() {
		this._cacheCanvas = this._cacheContext = null
	};
	a.clearStencil = function(a) {};
	a.setVirtualViewport = function(a, c, d) {};
	a.updateClearColor = function(a) {
		this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
	};
	a.initWithWidthAndHeight = function(a, c, d, e) {
		d = this._node;
		e = this._cacheCanvas;
		var f = cc.contentScaleFactor();
		e.width = 0 | a * f;
		e.height = 0 | c * f;
		a = new cc.Texture2D;
		a.initWithElement(e);
		a.handleLoadedTexture();
		a = d.sprite = new cc.Sprite(a);
		a.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
		d.autoDraw = !1;
		d.addChild(a);
		return !0
	};
	a.begin = function() {};
	a._beginWithClear = function(a, c, d, e, f, k, m) {
		a = a || 0;
		c = c || 0;
		d = d || 0;
		e = isNaN(e) ? 255 : e;
		f = this._cacheContext.getContext();
		k = this._cacheCanvas;
		f.setTransform(1, 0, 0, 1, 0, 0);
		this._cacheContext.setFillStyle("rgba(" + (0 | a) + "," + (0 | c) + "," + (0 | d) + "," + e / 255 + ")");
		f.clearRect(0, 0, k.width, k.height);
		f.fillRect(0, 0, k.width, k.height)
	};
	a.end = function() {
		var a = this._node,
			c = cc.contentScaleFactor();
		cc.renderer._renderingToCacheCanvas(this._cacheContext, a.__instanceId, c, c)
	};
	a.clearRect = function(a, c, d, e) {
		this._cacheContext.clearRect(a, c, d, -e)
	};
	a.clearDepth = function(a) {
		cc.log("clearDepth isn't supported on Cocos2d-Html5")
	};
	a.visit = function(a) {
		var c = this._node;
		this._syncStatus(a);
		c.sprite.visit(this);
		this._dirtyFlag = 0
	}
})();
(function() {
	cc.RenderTexture.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._depthRenderBuffer = this._textureCopy = this._oldFBO = this._fBO = null;
		this._rtTextureRect = new cc.Rect;
		this._fullRect = new cc.Rect;
		this._fullViewport = new cc.Rect
	};
	var a = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.RenderTexture.WebGLRenderCmd;
	a.setVirtualViewport = function(a, c, d) {
		this._rtTextureRect.x = a.x;
		this._rtTextureRect.y = a.y;
		this._fullRect = c;
		this._fullViewport = d
	};
	a.rendering = function(a) {
		var c = a || cc._renderContext;
		a = this._node;
		if (a.autoDraw) {
			a.begin();
			var d = a.clearFlags;
			if (d) {
				var e = [0, 0, 0, 0],
					f = 0,
					k = 0;
				d & c.COLOR_BUFFER_BIT && (e = c.getParameter(c.COLOR_CLEAR_VALUE), c.clearColor(a._clearColor.r / 255, a._clearColor.g / 255, a._clearColor.b / 255, a._clearColor.a / 255));
				d & c.DEPTH_BUFFER_BIT && (f = c.getParameter(c.DEPTH_CLEAR_VALUE), c.clearDepth(a.clearDepthVal));
				d & c.STENCIL_BUFFER_BIT && (k = c.getParameter(c.STENCIL_CLEAR_VALUE), c.clearStencil(a.clearStencilVal));
				c.clear(d);
				d & c.COLOR_BUFFER_BIT && c.clearColor(e[0], e[1], e[2], e[3]);
				d & c.DEPTH_BUFFER_BIT && c.clearDepth(f);
				d & c.STENCIL_BUFFER_BIT && c.clearStencil(k)
			}
			a.sortAllChildren();
			c = a._children;
			for (d = 0; d < c.length; d++) e = c[d], e !== a.sprite && e._renderCmd.visit(a.sprite._renderCmd);
			a.end()
		}
	};
	a.clearStencil = function(a) {
		var c = cc._renderContext,
			d = c.getParameter(c.STENCIL_CLEAR_VALUE);
		c.clearStencil(a);
		c.clear(c.STENCIL_BUFFER_BIT);
		c.clearStencil(d)
	};
	a.cleanup = function() {
		this._textureCopy = null;
		var a = cc._renderContext;
		a.deleteFramebuffer(this._fBO);
		this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer)
	};
	a.updateClearColor = function(a) {};
	a.initWithWidthAndHeight = function(a, c, d, e) {
		var f = this._node;
		d === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
		var k = cc._renderContext,
			m = cc.contentScaleFactor();
		this._fullRect = new cc.Rect(0, 0, a, c);
		this._fullViewport = new cc.Rect(0, 0, a, c);
		a = 0 | a * m;
		c = 0 | c * m;
		this._oldFBO = k.getParameter(k.FRAMEBUFFER_BINDING);
		var n;
		cc.configuration.supportsNPOT() ? (m = a, n = c) : (m = cc.NextPOT(a), n = cc.NextPOT(c));
		for (var p = new Uint8Array(4 * m * n), r = 0; r < 4 * m * n; r++) p[r] = 0;
		this._pixelFormat = d;
		r = f._texture = new cc.Texture2D;
		if (!f._texture) return !1;
		r.initWithData(p, f._pixelFormat, m, n, cc.size(a, c));
		d = k.getParameter(k.RENDERBUFFER_BINDING);
		if (cc.configuration.checkForGLExtension("GL_QCOM")) {
			this._textureCopy = new cc.Texture2D;
			if (!this._textureCopy) return !1;
			this._textureCopy.initWithData(p, f._pixelFormat, m, n, cc.size(a, c))
		}
		this._fBO = k.createFramebuffer();
		k.bindFramebuffer(k.FRAMEBUFFER, this._fBO);
		k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, r._webTextureObj, 0);
		0 !== e && (this._depthRenderBuffer = k.createRenderbuffer(), k.bindRenderbuffer(k.RENDERBUFFER, this._depthRenderBuffer), k.renderbufferStorage(k.RENDERBUFFER, e, m, n), e === k.DEPTH_STENCIL ? k.framebufferRenderbuffer(k.FRAMEBUFFER, k.DEPTH_STENCIL_ATTACHMENT, k.RENDERBUFFER, this._depthRenderBuffer) : e === k.STENCIL_INDEX || e === k.STENCIL_INDEX8 ? k.framebufferRenderbuffer(k.FRAMEBUFFER, k.STENCIL_ATTACHMENT, k.RENDERBUFFER, this._depthRenderBuffer) : e === k.DEPTH_COMPONENT16 && k.framebufferRenderbuffer(k.FRAMEBUFFER, k.DEPTH_ATTACHMENT, k.RENDERBUFFER, this._depthRenderBuffer));
		k.checkFramebufferStatus(k.FRAMEBUFFER) !== k.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
		r.setAliasTexParameters();
		a = f.sprite = new cc.Sprite(r);
		a.scaleY = -1;
		a.setBlendFunc(k.ONE, k.ONE_MINUS_SRC_ALPHA);
		k.bindRenderbuffer(k.RENDERBUFFER, d);
		k.bindFramebuffer(k.FRAMEBUFFER, this._oldFBO);
		f.autoDraw = !1;
		f.addChild(a);
		return !0
	};
	a.begin = function() {
		var a = this._node;
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPushMatrix();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPushMatrix();
		var c = cc._renderContext,
			d = cc.director;
		d.setProjection(d.getProjection());
		var e = a._texture.getContentSizeInPixels(),
			f = cc.director.getWinSizeInPixels(),
			d = f.width / e.width,
			e = f.height / e.height,
			d = cc.math.Matrix4.createOrthographicProjection(-1 / d, 1 / d, -1 / e, 1 / e, -1, 1);
		cc.kmGLMultMatrix(d);
		d = new cc.Rect(0, 0, 0, 0);
		d.width = this._fullViewport.width;
		d.height = this._fullViewport.height;
		e = d.height / this._fullRect.height;
		d.x = (this._fullRect.x - this._rtTextureRect.x) * (d.width / this._fullRect.width);
		d.y = (this._fullRect.y - this._rtTextureRect.y) * e;
		c.viewport(d.x, d.y, d.width, d.height);
		this._oldFBO = c.getParameter(c.FRAMEBUFFER_BINDING);
		c.bindFramebuffer(c.FRAMEBUFFER, this._fBO);
		cc.configuration.checkForGLExtension("GL_QCOM") && (c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, this._textureCopy._webTextureObj, 0), c.clear(c.COLOR_BUFFER_BIT | c.DEPTH_BUFFER_BIT), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, a._texture._webTextureObj, 0))
	};
	a._beginWithClear = function(a, c, d, e, f, k, m) {
		a /= 255;
		c /= 255;
		d /= 255;
		e /= 255;
		var n = cc._renderContext,
			p = [0, 0, 0, 0],
			r = 0,
			s = 0;
		m & n.COLOR_BUFFER_BIT && (p = n.getParameter(n.COLOR_CLEAR_VALUE), n.clearColor(a, c, d, e));
		m & n.DEPTH_BUFFER_BIT && (r = n.getParameter(n.DEPTH_CLEAR_VALUE), n.clearDepth(f));
		m & n.STENCIL_BUFFER_BIT && (s = n.getParameter(n.STENCIL_CLEAR_VALUE), n.clearStencil(k));
		n.clear(m);
		m & n.COLOR_BUFFER_BIT && n.clearColor(p[0], p[1], p[2], p[3]);
		m & n.DEPTH_BUFFER_BIT && n.clearDepth(r);
		m & n.STENCIL_BUFFER_BIT && n.clearStencil(s)
	};
	a.end = function() {
		cc.renderer._renderingToBuffer(this._node.__instanceId);
		var a = cc._renderContext,
			c = cc.director;
		a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
		c.setViewport();
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLPopMatrix();
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLPopMatrix()
	};
	a.clearRect = function(a, c, d, e) {};
	a.clearDepth = function(a) {
		var c = this._node;
		c.begin();
		var d = cc._renderContext,
			e = d.getParameter(d.DEPTH_CLEAR_VALUE);
		d.clearDepth(a);
		d.clear(d.DEPTH_BUFFER_BIT);
		d.clearDepth(e);
		c.end()
	};
	a.visit = function(a) {
		var c = this._node;
		c._visible && (cc.kmGLPushMatrix(), this._syncStatus(a), cc.renderer.pushRenderCommand(this), c.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix())
	}
})();
cc.LabelAtlas = cc.AtlasNode.extend({
	_string: null,
	_mapStartChar: null,
	_textureLoaded: !1,
	_className: "LabelAtlas",
	ctor: function(a, b, c, d, e) {
		cc.AtlasNode.prototype.ctor.call(this);
		this._renderCmd.setCascade();
		b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, c, d, e)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, b) {
		this.addEventListener("load", a, b)
	},
	initWithString: function(a, b, c, d, e) {
		var f = a + "",
			k, m;
		if (void 0 === c) {
			c = cc.loader.getRes(b);
			if (1 !== parseInt(c.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
			b = cc.path.changeBasename(b, c.textureFilename);
			d = cc.contentScaleFactor();
			k = parseInt(c.itemWidth, 10) / d;
			m = parseInt(c.itemHeight, 10) / d;
			c = String.fromCharCode(parseInt(c.firstChar, 10))
		} else k = c || 0, m = d || 0, c = e || " ";
		var n = null,
			n = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
		this._textureLoaded = b = n.isLoaded();
		b || (this._string = f, n.addEventListener("load", function(a) {
			this.initWithTexture(n, k, m, f.length);
			this.string = this._string;
			this.setColor(this._renderCmd._displayedColor);
			this.dispatchEvent("load")
		}, this));
		return this.initWithTexture(n, k, m, f.length) ? (this._mapStartChar = c, this.string = f, !0) : !1
	},
	setColor: function(a) {
		cc.AtlasNode.prototype.setColor.call(this, a);
		this._renderCmd.updateAtlasValues()
	},
	getString: function() {
		return this._string
	},
	addChild: function(a, b, c) {
		this._renderCmd._addChild(a);
		cc.Node.prototype.addChild.call(this, a, b, c)
	},
	updateAtlasValues: function() {
		this._renderCmd.updateAtlasValues()
	},
	setString: function(a) {
		a = String(a);
		var b = a.length;
		this._string = a;
		this.setContentSize(b * this._itemWidth, this._itemHeight);
		this._renderCmd.setString(a);
		this._renderCmd.updateAtlasValues();
		this.quadsToDraw = b
	}
});
(function() {
	var a = cc.LabelAtlas.prototype;
	cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
	cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
	cc.defineGetterSetter(a, "string", a.getString, a.setString)
})();
cc.LabelAtlas.create = function(a, b, c, d, e) {
	return new cc.LabelAtlas(a, b, c, d, e)
};
(function() {
	cc.LabelAtlas.CanvasRenderCmd = function(a) {
		cc.AtlasNode.CanvasRenderCmd.call(this, a);
		this._needDraw = !1
	};
	var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
	a.constructor = cc.LabelAtlas.CanvasRenderCmd;
	a.setCascade = function() {
		var a = this._node;
		a._cascadeOpacityEnabled = !0;
		a._cascadeColorEnabled = !1
	};
	a.updateAtlasValues = function() {
		for (var a = this._node, c = a._string || "", d = c.length, e = this._texture, f = a._itemWidth, k = a._itemHeight, m = 0, n = -1; m < d; m++) {
			var p = c.charCodeAt(m) - a._mapStartChar.charCodeAt(0),
				r = parseInt(p % a._itemsPerRow, 10),
				p = parseInt(p / a._itemsPerRow, 10);
			if (!(0 > r || 0 > p)) if (r = cc.rect(r * f, p * k, f, k), p = e._contentSize, !(0 > r.x || 0 > r.y || r.x + r.width > p.width || r.y + r.height > p.height)) {
				n++;
				var p = c.charCodeAt(m),
					s = a.getChildByTag(m);
				s ? 32 === p ? (s.init(), s.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (s.initWithTexture(e, r), s.visible = !0) : (s = new cc.Sprite, 32 === p ? (s.init(), s.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : s.initWithTexture(e, r), cc.Node.prototype.addChild.call(a, s, 0, m));
				s.setPosition(n * f + f / 2, k / 2)
			}
		}
		this.updateContentSize(m, n + 1)
	};
	a.updateContentSize = function(a, c) {
		var d = this._node,
			e = d._contentSize;
		a !== c && (a * d._itemWidth === e.width && d._itemHeight === e.height) && d.setContentSize(c * d._itemWidth, d._itemHeight)
	};
	a.setString = function(a) {
		a = this._node;
		if (a._children) {
			a = a._children;
			for (var c = a.length, d = 0; d < c; d++) {
				var e = a[d];
				e && !e._lateChild && (e.visible = !1)
			}
		}
	};
	a._addChild = function() {
		child._lateChild = !0
	}
})();
(function() {
	cc.LabelAtlas.WebGLRenderCmd = function(a) {
		cc.AtlasNode.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
	a.constructor = cc.LabelAtlas.WebGLRenderCmd;
	a.setCascade = function() {
		var a = this._node;
		a._cascadeOpacityEnabled = !0;
		a._cascadeColorEnabled = !0
	};
	a.rendering = function(a) {
		cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a);
		cc.LABELATLAS_DEBUG_DRAW && (a = this._node.getContentSize(), a = [cc.p(0, 0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
	};
	a.updateAtlasValues = function() {
		var a = this._node,
			c = a._string,
			d = c.length,
			e = this._textureAtlas,
			f = e.texture,
			k = f.pixelsWidth,
			f = f.pixelsHeight,
			m = a._itemWidth,
			n = a._itemHeight;
		a._ignoreContentScaleFactor || (m = a._itemWidth * cc.contentScaleFactor(), n = a._itemHeight * cc.contentScaleFactor());
		d > e.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
		for (var p = e.quads, r = this._displayedColor, r = {
			r: r.r,
			g: r.g,
			b: r.b,
			a: a._displayedOpacity
		}, s = a._itemWidth, u = a._itemHeight, t = 0, w = -1; t < d; t++) {
			var v = c.charCodeAt(t) - a._mapStartChar.charCodeAt(0),
				y = v % a._itemsPerRow,
				z = 0 | v / a._itemsPerRow;
			if (!(0 > y || 0 > z)) if (!(y * s + s > k || z * u + u > f)) {
				w++;
				var F;
				cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (y = (2 * y * m + 1) / (2 * k), v = y + (2 * m - 2) / (2 * k), z = (2 * z * n + 1) / (2 * f), F = z + (2 * n - 2) / (2 * f)) : (y = y * m / k, v = y + m / k, z = z * n / f, F = z + n / f);
				var E = p[t],
					C = E.tl,
					A = E.tr,
					x = E.bl,
					E = E.br;
				C.texCoords.u = y;
				C.texCoords.v = z;
				A.texCoords.u = v;
				A.texCoords.v = z;
				x.texCoords.u = y;
				x.texCoords.v = F;
				E.texCoords.u = v;
				E.texCoords.v = F;
				x.vertices.x = w * s;
				x.vertices.y = 0;
				x.vertices.z = 0;
				E.vertices.x = w * s + s;
				E.vertices.y = 0;
				E.vertices.z = 0;
				C.vertices.x = w * s;
				C.vertices.y = a._itemHeight;
				C.vertices.z = 0;
				A.vertices.x = w * s + s;
				A.vertices.y = a._itemHeight;
				A.vertices.z = 0;
				C.colors = r;
				A.colors = r;
				x.colors = r;
				E.colors = r
			}
		}
		this.updateContentSize(t, w + 1);
		0 < d && (e.dirty = !0, a = e.totalQuads, d > a && e.increaseTotalQuadsWith(d - a))
	};
	a.updateContentSize = function(a, c) {
		var d = this._node,
			e = d._contentSize;
		a !== c && (a * d._itemWidth === e.width && d._itemHeight === e.height) && d.setContentSize(c * d._itemWidth, d._itemHeight)
	};
	a.setString = function(a) {
		a = a.length;
		a > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(a)
	};
	a._addChild = function() {}
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
	_opacityModifyRGB: !1,
	_string: "",
	_config: null,
	_fntFile: "",
	_initialString: "",
	_alignment: cc.TEXT_ALIGNMENT_CENTER,
	_width: -1,
	_lineBreakWithoutSpaces: !1,
	_imageOffset: null,
	_reusedChar: null,
	_textureLoaded: !1,
	_className: "LabelBMFont",
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
	},
	_setString: function(a, b) {
		b ? this._initialString = a : this._string = a;
		var c = this._children;
		if (c) for (var d = 0; d < c.length; d++) {
			var e = c[d];
			e && e.setVisible(!1)
		}
		this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
	},
	ctor: function(a, b, c, d, e) {
		cc.SpriteBatchNode.prototype.ctor.call(this);
		this._imageOffset = cc.p(0, 0);
		this._reusedChar = [];
		this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
		this.initWithString(a, b, c, d, e)
	},
	textureLoaded: function() {
		return this._textureLoaded
	},
	addLoadedEventListener: function(a, b) {
		this.addEventListener("load", a, b)
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setOpacityModifyRGB: function(a) {
		this._opacityModifyRGB = a;
		if (a = this._children) for (var b = 0; b < a.length; b++) {
			var c = a[b];
			c && (c.opacityModifyRGB = this._opacityModifyRGB)
		}
	},
	_changeTextureColor: function() {
		this._renderCmd._changeTextureColor()
	},
	init: function() {
		return this.initWithString(null, null, null, null, null)
	},
	initWithString: function(a, b, c, d, e) {
		a = a || "";
		this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
		if (b) {
			var f = cc.loader.getRes(b);
			if (!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
			this._config = f;
			this._fntFile = b;
			b = cc.textureCache.addImage(f.atlasName);
			(this._textureLoaded = f = b.isLoaded()) || b.addEventListener("load", function(a) {
				this._textureLoaded = !0;
				this.initWithTexture(a, this._initialString.length);
				this.setString(this._initialString, !0);
				this.dispatchEvent("load")
			}, this)
		} else b = new cc.Texture2D, f = new Image, b.initWithElement(f), this._textureLoaded = !1;
		return this.initWithTexture(b, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width = null == c ? -1 : c, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), this._renderCmd._initBatchTexture(), this.setString(a, !0), !0) : !1
	},
	createFontChars: function() {
		var a = this._renderCmd._texture || this.textureAtlas.texture,
			b = 0,
			c = cc.size(0, 0),
			d = 0,
			e = 1,
			f = this._string,
			k = f ? f.length : 0;
		if (0 !== k) {
			var m, n = this._config,
				p = n.kerningDict,
				r = n.commonHeight,
				s = n.fontDefDictionary;
			for (m = 0; m < k - 1; m++) 10 === f.charCodeAt(m) && e++;
			var u = r * e,
				e = -(r - r * e),
				t = -1;
			for (m = 0; m < k; m++)
			if (r = f.charCodeAt(m), 0 !== r) if (10 === r) b = 0, e -= n.commonHeight;
			else {
				var t = p[t << 16 | r & 65535] || 0,
					w = s[r];
				w || (cc.log("cocos2d: LabelBMFont: character not found " + f[m]), w = {
					rect: {
						x: 0,
						y: 0,
						width: 0,
						height: 0
					},
					xOffset: 0,
					yOffset: 0,
					xAdvance: 0
				});
				var v = cc.rect(w.rect.x, w.rect.y, w.rect.width, w.rect.height),
					v = cc.rectPixelsToPoints(v);
				v.x += this._imageOffset.x;
				v.y += this._imageOffset.y;
				var y = this.getChildByTag(m);
				y ? this._renderCmd._updateCharTexture(y, v, r) : (y = new cc.Sprite, y.initWithTexture(a, v, !1), y._newTextureWhenChangeColor = !0, this.addChild(y, 0, m));
				y.opacityModifyRGB = this._opacityModifyRGB;
				this._renderCmd._updateCharColorAndOpacity(y);
				v = cc.p(b + w.xOffset + 0.5 * w.rect.width + t, e + (n.commonHeight - w.yOffset) - 0.5 * v.height * cc.contentScaleFactor());
				y.setPosition(cc.pointPixelsToPoints(v));
				b += w.xAdvance + t;
				t = r;
				d < b && (d = b)
			}
			c.width = w && w.xAdvance < w.rect.width ? d - w.xAdvance + w.rect.width : d;
			c.height = u;
			this.setContentSize(cc.sizePixelsToPoints(c))
		}
	},
	updateString: function(a) {
		var b = this._children;
		if (b) for (var c = 0, d = b.length; c < d; c++) {
			var e = b[c];
			e && (e.visible = !1)
		}
		this._config && this.createFontChars();
		a || this.updateLabel()
	},
	getString: function() {
		return this._initialString
	},
	setString: function(a, b) {
		a = String(a);
		null == b && (b = !0);
		if (null == a || !cc.isString(a)) a += "";
		this._initialString = a;
		this._setString(a, b)
	},
	_setStringForSetter: function(a) {
		this.setString(a, !1)
	},
	setCString: function(a) {
		this.setString(a, !0)
	},
	_getCharsWidth: function(a, b) {
		if (0 >= b) return 0;
		var c = this.getChildByTag(a),
			d = this.getChildByTag(a + b);
		return this._getLetterPosXLeft(d) - this._getLetterPosXLeft(c)
	},
	_checkWarp: function(a, b, c, d) {
		for (var e = a[b], f = 0, k = 0; k < b; k++) f += a[k].length;
		var f = f + b - d,
			m = this._getCharsWidth(f, a[b].length - 1);
		if (m > c && 1 < e.length) {
			d = e.length * (c / m) | 0;
			for (var k = e.substr(d), n = m - this._getCharsWidth(f + d, k.length - 1), p, r = 0, s = 0; n > c && 100 > s++;) d *= c / n, d |= 0, k = e.substr(d), n = m - this._getCharsWidth(f + d, k.length - 1);
			for (s = 0; n < c && 100 > s++;) k && (r = (p = cc.LabelTTF._wordRex.exec(k)) ? p[0].length : 1, p = k), this._lineBreakWithoutSpaces && (r = 0), d += r, k = e.substr(d), n = m - this._getCharsWidth(f + d, k.length - 1);
			d -= r;
			0 === d && (d = 1, p = p.substr(1));
			c = e.substr(0, d);
			if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(p || k)) r = (f = cc.LabelTTF._lastWordRex.exec(c)) ? f[0].length : 0, this._lineBreakWithoutSpaces && (r = 0), d -= r, p = e.substr(d), c = e.substr(0, d);
			if (cc.LabelTTF._firsrEnglish.test(p) && (f = cc.LabelTTF._lastEnglish.exec(c)) && c !== f[0]) r = f[0].length, this._lineBreakWithoutSpaces && (r = 0), d -= r, p = e.substr(d), c = e.substr(0, d);
			a[b] = p || k;
			a.splice(b, 0, c)
		}
	},
	updateLabel: function() {
		this.string = this._initialString;
		var a, b, c;
		if (0 < this._width) {
			var d = this.string.split("\n"),
				e = "",
				f = 0,
				k = 0;
			for (a = 0; a < d.length; a++) k = d.length, this._checkWarp(d, a, this._width * this._scaleX, f), k < d.length && f++, 0 < a && (e += "\n"), e += d[a];
			e += String.fromCharCode(0);
			this._setString(e, !1)
		}
		if (this._alignment !== cc.TEXT_ALIGNMENT_LEFT) {
			d = a = 0;
			e = this._string.length;
			f = [];
			for (k = 0; k < e; k++)
			if (10 === this._string[k].charCodeAt(0) || 0 === this._string[k].charCodeAt(0)) {
				b = 0;
				var m = f.length;
				if (0 === m) d++;
				else if (c = a + m - 1 + d, !(0 > c)) {
					var n = this.getChildByTag(c);
					if (null != n) {
						b = n.getPositionX() + n._getWidth() / 2;
						n = 0;
						switch (this._alignment) {
						case cc.TEXT_ALIGNMENT_CENTER:
							n = this.width / 2 - b / 2;
							break;
						case cc.TEXT_ALIGNMENT_RIGHT:
							n = this.width - b
						}
						if (0 !== n) for (b = 0; b < m; b++) c = a + b + d, 0 > c || (c = this.getChildByTag(c)) && (c.x += n);
						a += m;
						d++;
						f.length = 0
					}
				}
			} else f.push(this._string[a])
		}
	},
	setAlignment: function(a) {
		this._alignment = a;
		this.updateLabel()
	},
	_getAlignment: function() {
		return this._alignment
	},
	setBoundingWidth: function(a) {
		this._width = a;
		this.updateLabel()
	},
	_getBoundingWidth: function() {
		return this._width
	},
	setLineBreakWithoutSpace: function(a) {
		this._lineBreakWithoutSpaces = a;
		this.updateLabel()
	},
	setScale: function(a, b) {
		cc.Node.prototype.setScale.call(this, a, b);
		this.updateLabel()
	},
	setScaleX: function(a) {
		cc.Node.prototype.setScaleX.call(this, a);
		this.updateLabel()
	},
	setScaleY: function(a) {
		cc.Node.prototype.setScaleY.call(this, a);
		this.updateLabel()
	},
	setFntFile: function(a) {
		if (null != a && a !== this._fntFile) {
			var b = cc.loader.getRes(a);
			b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded = b = a.isLoaded(), this.texture = a, this._renderCmd._updateFntFileTexture(), b ? this.createFontChars() : a.addEventListener("load", function(a) {
				this._textureLoaded = !0;
				this.texture = a;
				this.createFontChars();
				this._changeTextureColor();
				this.updateLabel();
				this.dispatchEvent("load")
			}, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
		}
	},
	getFntFile: function() {
		return this._fntFile
	},
	setTexture: function(a) {
		this._renderCmd.setTexture(a)
	},
	setAnchorPoint: function(a, b) {
		cc.Node.prototype.setAnchorPoint.call(this, a, b);
		this.updateLabel()
	},
	_setAnchorX: function(a) {
		cc.Node.prototype._setAnchorX.call(this, a);
		this.updateLabel()
	},
	_setAnchorY: function(a) {
		cc.Node.prototype._setAnchorY.call(this, a);
		this.updateLabel()
	},
	_atlasNameFromFntFile: function(a) {},
	_kerningAmountForFirst: function(a, b) {
		var c = 0;
		if (this._configuration.kerningDictionary) {
			var d = this._configuration.kerningDictionary[(a << 16 | b & 65535).toString()];
			d && (c = d.amount)
		}
		return c
	},
	_getLetterPosXLeft: function(a) {
		return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
	},
	_getLetterPosXRight: function(a) {
		return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
	},
	_isspace_unicode: function(a) {
		a = a.charCodeAt(0);
		return 9 <= a && 13 >= a || 32 === a || 133 === a || 160 === a || 5760 === a || 8192 <= a && 8202 >= a || 8232 === a || 8233 === a || 8239 === a || 8287 === a || 12288 === a
	},
	_utf8_trim_ws: function(a) {
		var b = a.length;
		if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
			for (var c = b - 1; 0 <= c; --c)
			if (this._isspace_unicode(a[c])) b = c;
			else break;
			this._utf8_trim_from(a, b)
		}
	},
	_utf8_trim_from: function(a, b) {
		var c = a.length;
		b >= c || 0 > b || a.splice(b, c)
	}
});
(function() {
	var a = cc.LabelBMFont.prototype;
	cc.EventHelper.prototype.apply(a);
	cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter);
	cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth);
	cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
})();
cc.LabelBMFont.create = function(a, b, c, d, e) {
	return new cc.LabelBMFont(a, b, c, d, e)
};
cc._fntLoader = {
	INFO_EXP: /info [^\n]*(\n|$)/gi,
	COMMON_EXP: /common [^\n]*(\n|$)/gi,
	PAGE_EXP: /page [^\n]*(\n|$)/gi,
	CHAR_EXP: /char [^\n]*(\n|$)/gi,
	KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
	ITEM_EXP: /\w+=[^ \r\n]+/gi,
	INT_EXP: /^[\-]?\d+$/,
	_parseStrToObj: function(a) {
		a = a.match(this.ITEM_EXP);
		var b = {};
		if (a) for (var c = 0, d = a.length; c < d; c++) {
			var e = a[c],
				f = e.indexOf("="),
				k = e.substring(0, f),
				e = e.substring(f + 1);
			e.match(this.INT_EXP) ? e = parseInt(e) : '"' === e[0] && (e = e.substring(1, e.length - 1));
			b[k] = e
		}
		return b
	},
	parseFnt: function(a, b) {
		var c = {},
			d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
		parseInt(d[0]);
		parseInt(d[1]);
		parseInt(d[2]);
		parseInt(d[3]);
		d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
		c.commonHeight = d.lineHeight;
		if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
			var e = cc.configuration.getMaxTextureSize();
			(d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
		}
		1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
		d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
		0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
		c.atlasName = cc.path.changeBasename(b, d.file);
		for (var f = a.match(this.CHAR_EXP), k = c.fontDefDictionary = {}, d = 0, e = f.length; d < e; d++) {
			var m = this._parseStrToObj(f[d]);
			k[m.id] = {
				rect: {
					x: m.x,
					y: m.y,
					width: m.width,
					height: m.height
				},
				xOffset: m.xoffset,
				yOffset: m.yoffset,
				xAdvance: m.xadvance
			}
		}
		f = c.kerningDict = {};
		if (k = a.match(this.KERNING_EXP)) {
			d = 0;
			for (e = k.length; d < e; d++) m = this._parseStrToObj(k[d]), f[m.first << 16 | m.second & 65535] = m.amount
		}
		return c
	},
	load: function(a, b, c, d) {
		var e = this;
		cc.loader.loadTxt(a, function(a, c) {
			if (a) return d(a);
			d(null, e.parseFnt(c, b))
		})
	}
};
cc.loader.register(["fnt"], cc._fntLoader);
(function() {
	cc.LabelBMFont.CanvasRenderCmd = function(a) {
		cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
	a.constructor = cc.LabelBMFont.CanvasRenderCmd;
	a.rendering = function() {
		void 0
	};
	a._updateCharTexture = function(a, c, d) {
		32 === d ? a.setTextureRect(c, !1, cc.size(0, 0)) : (a.setTextureRect(c, !1), a.visible = !0)
	};
	a._updateCharColorAndOpacity = function(a) {
		a._displayedColor = this._displayedColor;
		a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
		a._displayedOpacity = this._displayedOpacity;
		a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	};
	a._updateFntFileTexture = function() {
		var a = this._node;
		a._originalTexture = a.texture
	};
	a.setTexture = function(a) {
		for (var c = this._node._children, d = this._displayedColor, e = 0; e < c.length; e++) {
			var f = c[e],
				k = f._renderCmd,
				m = k._displayedColor;
			this._texture !== k._texture && (m.r !== d.r || m.g !== d.g || m.b !== d.b) || (f.texture = a)
		}
		this._texture = a
	};
	a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function() {
		var a = this._node,
			c = a.getTexture();
		if (c && 0 < c.getContentSize().width) {
			var d = this._originalTexture.getHtmlElementObj();
			if (d) {
				var e = c.getHtmlElementObj(),
					f = cc.rect(0, 0, d.width, d.height);
				e instanceof HTMLCanvasElement && !a._rectRotated ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._displayedColor, f, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(d, this._displayedColor, f), c = new cc.Texture2D, c.initWithElement(e), c.handleLoadedTexture());
				a.setTexture(c)
			}
		}
	} : function() {
		var a = this._node,
			c, d = a.getTexture();
		if (d && 0 < d.getContentSize().width && (c = d.getHtmlElementObj())) {
			var e = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
			e && (c instanceof HTMLCanvasElement && !this._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImage(c, e, this._displayedColor, null, c), this.setTexture(d)) : (c = cc.Sprite.CanvasRenderCmd._generateTintImage(c, e, this._displayedColor), d = new cc.Texture2D, d.initWithElement(c), d.handleLoadedTexture(), a.setTexture(d)))
		}
	};
	a._updateChildrenDisplayedOpacity = function(a) {
		cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
	};
	a._updateChildrenDisplayedColor = function(a) {
		cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
	};
	a._initBatchTexture = function() {}
})();
(function() {
	cc.LabelBMFont.WebGLRenderCmd = function(a) {
		cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
	a.constructor = cc.LabelBMFont.WebGLRenderCmd;
	a._updateCharTexture = function(a, c, d) {
		a.setTextureRect(c, !1);
		a.visible = !0
	};
	a._updateFntFileTexture = function() {};
	a._changeTextureColor = function() {};
	a._updateChildrenDisplayedOpacity = function(a) {
		a.updateDisplayedOpacity(this._displayedOpacity)
	};
	a._updateChildrenDisplayedColor = function(a) {
		a.updateDisplayedColor(this._displayedColor)
	};
	a._initBatchTexture = function() {
		var a = this._node,
			c = a.textureAtlas.texture;
		a._opacityModifyRGB = c.hasPremultipliedAlpha();
		var d = a._reusedChar = new cc.Sprite;
		d.initWithTexture(c, cc.rect(0, 0, 0, 0), !1);
		d.batchNode = a
	};
	a.rendering = function(a) {
		cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
		a = this._node;
		if (cc.LABELBMFONT_DEBUG_DRAW) {
			a = a.getContentSize();
			var c = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
			a = [cc.p(c.x, c.y), cc.p(c.x + a.width, c.y), cc.p(c.x + a.width, c.y + a.height), cc.p(c.x, c.y + a.height)];
			cc._drawingUtil.setDrawColor(0, 255, 0, 255);
			cc._drawingUtil.drawPoly(a, 4, !0)
		}
	};
	a._updateCharColorAndOpacity = function() {}
})();
cc.MotionStreak = cc.Node.extend({
	texture: null,
	fastMode: !1,
	startingPositionInitialized: !1,
	_blendFunc: null,
	_stroke: 0,
	_fadeDelta: 0,
	_minSeg: 0,
	_maxPoints: 0,
	_nuPoints: 0,
	_previousNuPoints: 0,
	_pointVertexes: null,
	_pointState: null,
	_vertices: null,
	_colorPointer: null,
	_texCoords: null,
	_verticesBuffer: null,
	_colorPointerBuffer: null,
	_texCoordsBuffer: null,
	_className: "MotionStreak",
	ctor: function(a, b, c, d, e) {
		cc.Node.prototype.ctor.call(this);
		this._positionR = cc.p(0, 0);
		this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		this.startingPositionInitialized = this.fastMode = !1;
		this.texture = null;
		this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
		this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null;
		void 0 !== e && this.initWithFade(a, b, c, d, e)
	},
	getTexture: function() {
		return this.texture
	},
	setTexture: function(a) {
		this.texture !== a && (this.texture = a)
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a, b) {
		void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
	},
	getOpacity: function() {
		cc.log("cc.MotionStreak.getOpacity has not been supported.");
		return 0
	},
	setOpacity: function(a) {
		cc.log("cc.MotionStreak.setOpacity has not been supported.")
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	isFastMode: function() {
		return this.fastMode
	},
	setFastMode: function(a) {
		this.fastMode = a
	},
	isStartingPositionInitialized: function() {
		return this.startingPositionInitialized
	},
	setStartingPositionInitialized: function(a) {
		this.startingPositionInitialized = a
	},
	getStroke: function() {
		return this._stroke
	},
	setStroke: function(a) {
		this._stroke = a
	},
	initWithFade: function(a, b, c, d, e) {
		if (!e) throw Error("cc.MotionStreak.initWithFade(): Invalid filename or texture");
		cc.isString(e) && (e = cc.textureCache.addImage(e));
		cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
		this.anchorY = this.anchorX = 0;
		this.ignoreAnchor = !0;
		this.startingPositionInitialized = !1;
		this.fastMode = !0;
		this._minSeg = -1 === b ? c / 5 : b;
		this._minSeg *= this._minSeg;
		this._stroke = c;
		this._fadeDelta = 1 / a;
		this._maxPoints = a = (0 | 60 * a) + 2;
		this._nuPoints = 0;
		this._pointState = new Float32Array(a);
		this._pointVertexes = new Float32Array(2 * a);
		this._vertices = new Float32Array(4 * a);
		this._texCoords = new Float32Array(4 * a);
		this._colorPointer = new Uint8Array(8 * a);
		this._verticesBuffer = gl.createBuffer();
		this._texCoordsBuffer = gl.createBuffer();
		this._colorPointerBuffer = gl.createBuffer();
		this._blendFunc.src = gl.SRC_ALPHA;
		this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
		this.texture = e;
		this.color = d;
		this.scheduleUpdate();
		gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
		return !0
	},
	tintWithColor: function(a) {
		this.color = a;
		for (var b = this._colorPointer, c = 0, d = 2 * this._nuPoints; c < d; c++) b[4 * c] = a.r, b[4 * c + 1] = a.g, b[4 * c + 2] = a.b
	},
	reset: function() {
		this._nuPoints = 0
	},
	setPosition: function(a, b) {
		this.startingPositionInitialized = !0;
		void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = b)
	},
	getPositionX: function() {
		return this._positionR.x
	},
	setPositionX: function(a) {
		this._positionR.x = a;
		this.startingPositionInitialized || (this.startingPositionInitialized = !0)
	},
	getPositionY: function() {
		return this._positionR.y
	},
	setPositionY: function(a) {
		this._positionR.y = a;
		this.startingPositionInitialized || (this.startingPositionInitialized = !0)
	},
	update: function(a) {
		if (this.startingPositionInitialized) {
			this._renderCmd._updateDisplayColor();
			a *= this._fadeDelta;
			var b, c, d, e, f = 0,
				k = this._nuPoints,
				m = this._pointState,
				n = this._pointVertexes,
				p = this._vertices,
				r = this._colorPointer;
			for (d = 0; d < k; d++) m[d] -= a, 0 >= m[d] ? f++ : (b = d - f, 0 < f ? (m[b] = m[d], n[2 * b] = n[2 * d], n[2 * b + 1] = n[2 * d + 1], e = 2 * d, c = 2 * b, p[2 * c] = p[2 * e], p[2 * c + 1] = p[2 * e + 1], p[2 * (c + 1)] = p[2 * (e + 1)], p[2 * (c + 1) + 1] = p[2 * (e + 1) + 1], e *= 4, c *= 4, r[c + 0] = r[e + 0], r[c + 1] = r[e + 1], r[c + 2] = r[e + 2], r[c + 4] = r[e + 4], r[c + 5] = r[e + 5], r[c + 6] = r[e + 6]) : c = 8 * b, b = 255 * m[b], r[c + 3] = b, r[c + 7] = b);
			k -= f;
			d = !0;
			if (k >= this._maxPoints) d = !1;
			else if (0 < k && (a = cc.pDistanceSQ(cc.p(n[2 * (k - 1)], n[2 * (k - 1) + 1]), this._positionR) < this._minSeg, c = 1 === k ? !1 : cc.pDistanceSQ(cc.p(n[2 * (k - 2)], n[2 * (k - 2) + 1]), this._positionR) < 2 * this._minSeg, a || c)) d = !1;
			d && (n[2 * k] = this._positionR.x, n[2 * k + 1] = this._positionR.y, m[k] = 1, m = 8 * k, d = this.getDisplayedColor(), r[m] = d.r, r[m + 1] = d.g, r[m + 2] = d.b, r[m + 4] = d.r, r[m + 5] = d.g, r[m + 6] = d.b, r[m + 3] = 255, r[m + 7] = 255, 0 < k && this.fastMode && (1 < k ? cc.vertexLineToPolygon(n, this._stroke, this._vertices, k, 1) : cc.vertexLineToPolygon(n, this._stroke, this._vertices, 0, 2)), k++);
			this.fastMode || cc.vertexLineToPolygon(n, this._stroke, this._vertices, 0, k);
			if (k && this._previousNuPoints !== k) {
				n = 1 / k;
				r = this._texCoords;
				for (d = 0; d < k; d++) r[4 * d] = 0, r[4 * d + 1] = n * d, r[2 * (2 * d + 1)] = 1, r[2 * (2 * d + 1) + 1] = n * d;
				this._previousNuPoints = k
			}
			this._nuPoints = k
		}
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
	}
});
cc.MotionStreak.create = function(a, b, c, d, e) {
	return new cc.MotionStreak(a, b, c, d, e)
};
cc.MotionStreak.WebGLRenderCmd = function(a) {
	cc.Node.WebGLRenderCmd.call(this, a);
	this._needDraw = !0;
	this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
};
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd;
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(a) {
	var b = this._node;
	!(1 >= b._nuPoints) && (b.texture && b.texture.isLoaded()) && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(b.texture), a.bindBuffer(a.ARRAY_BUFFER, b._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, b._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, b._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, b._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * b._nuPoints), cc.g_NumberOfDraws++)
};
cc.NodeGrid = cc.Node.extend({
	grid: null,
	_target: null,
	_gridRect: null,
	ctor: function(a) {
		cc.Node.prototype.ctor.call(this);
		void 0 == a && (a = cc.rect());
		this._gridRect = a;
		cc.GridAction.prototype._gridNodeTarget = this
	},
	getGrid: function() {
		return this.grid
	},
	setGrid: function(a) {
		this.grid = a
	},
	setGridRect: function(a) {
		this._gridRect = a
	},
	getGridRect: function() {
		return this._gridRect
	},
	setTarget: function(a) {
		this._target = a
	},
	_transformForWebGL: function() {
		var a = this._transform4x4,
			b = cc.current_stack.top,
			c = this.getNodeToParentTransform(),
			d = a.mat;
		d[0] = c.a;
		d[4] = c.c;
		d[12] = c.tx;
		d[1] = c.b;
		d[5] = c.d;
		d[13] = c.ty;
		d[14] = this._vertexZ;
		b.multiply(a);
		if (null !== this._camera && (!this.grid || !this.grid.isActive())) b = this._renderCmd._anchorPointInPoints, a = b.x, b = b.y, 0 !== a || 0 !== b ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, b |= 0), cc.kmGLTranslatef(a, b, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -b, 0)) : this._camera.locate()
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
	}
});
_p = cc.NodeGrid.prototype;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function() {
	return new cc.NodeGrid
};
(function() {
	cc.NodeGrid.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !1;
		this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw);
		this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw)
	};
	var a = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.NodeGrid.WebGLRenderCmd;
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) {
			a = a || this.getParentRenderCmd();
			c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._syncStatus(a);
			d.top = this._stackMatrix;
			cc.renderer.pushRenderCommand(this._gridBeginCommand);
			c._target && c._target.visit();
			if ((a = c._children) && 0 < a.length) {
				var e = a.length;
				c.sortAllChildren();
				for (c = 0; c < e; c++) {
					var f = a[c];
					f && f.visit()
				}
			}
			cc.renderer.pushRenderCommand(this._gridEndCommand);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.onGridBeginDraw = function() {
		var a = this._node.grid;
		a && a._active && a.beforeDraw()
	};
	a.onGridEndDraw = function() {
		var a = this._node.grid;
		a && a._active && a.afterDraw(this._node)
	}
})();
cc.v2fzero = function() {
	return {
		x: 0,
		y: 0
	}
};
cc.v2f = function(a, b) {
	return {
		x: a,
		y: b
	}
};
cc.v2fadd = function(a, b) {
	return cc.v2f(a.x + b.x, a.y + b.y)
};
cc.v2fsub = function(a, b) {
	return cc.v2f(a.x - b.x, a.y - b.y)
};
cc.v2fmult = function(a, b) {
	return cc.v2f(a.x * b, a.y * b)
};
cc.v2fperp = function(a) {
	return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function(a) {
	return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function(a, b) {
	return a.x * b.x + a.y * b.y
};
cc.v2fforangle = function(a) {
	return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function(a) {
	a = cc.pNormalize(cc.p(a.x, a.y));
	return cc.v2f(a.x, a.y)
};
cc.__v2f = function(a) {
	return cc.v2f(a.x, a.y)
};
cc.__t = function(a) {
	return {
		u: a.x,
		v: a.y
	}
};
cc.DrawNodeCanvas = cc.Node.extend({
	_buffer: null,
	_blendFunc: null,
	_lineWidth: 1,
	_drawColor: null,
	_className: "DrawNodeCanvas",
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		var a = this._renderCmd;
		a._buffer = this._buffer = [];
		a._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
		a._blendFunc = this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		this.init()
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a, b) {
		void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
	},
	setLineWidth: function(a) {
		this._lineWidth = a
	},
	getLineWidth: function() {
		return this._lineWidth
	},
	setDrawColor: function(a) {
		var b = this._drawColor;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		b.a = null == a.a ? 255 : a.a
	},
	getDrawColor: function() {
		return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
	},
	drawRect: function(a, b, c, d, e) {
		d = null == d ? this._lineWidth : d;
		e = e || this.getDrawColor();
		null == e.a && (e.a = 255);
		a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
		b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		b.verts = a;
		b.lineWidth = d;
		b.lineColor = e;
		b.isClosePolygon = !0;
		b.isStroke = !0;
		b.lineCap = "butt";
		if (b.fillColor = c) null == c.a && (c.a = 255), b.isFill = !0;
		this._buffer.push(b)
	},
	drawCircle: function(a, b, c, d, e, f, k) {
		f = f || this._lineWidth;
		k = k || this.getDrawColor();
		null == k.a && (k.a = 255);
		for (var m = 2 * Math.PI / d, n = [], p = 0; p <= d; p++) {
			var r = p * m,
				s = b * Math.cos(r + c) + a.x,
				r = b * Math.sin(r + c) + a.y;
			n.push(cc.p(s, r))
		}
		e && n.push(cc.p(a.x, a.y));
		a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		a.verts = n;
		a.lineWidth = f;
		a.lineColor = k;
		a.isClosePolygon = !0;
		a.isStroke = !0;
		this._buffer.push(a)
	},
	drawQuadBezier: function(a, b, c, d, e, f) {
		e = e || this._lineWidth;
		f = f || this.getDrawColor();
		null == f.a && (f.a = 255);
		for (var k = [], m = 0, n = 0; n < d; n++) {
			var p = Math.pow(1 - m, 2) * a.x + 2 * (1 - m) * m * b.x + m * m * c.x,
				r = Math.pow(1 - m, 2) * a.y + 2 * (1 - m) * m * b.y + m * m * c.y;
			k.push(cc.p(p, r));
			m += 1 / d
		}
		k.push(cc.p(c.x, c.y));
		a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		a.verts = k;
		a.lineWidth = e;
		a.lineColor = f;
		a.isStroke = !0;
		a.lineCap = "round";
		this._buffer.push(a)
	},
	drawCubicBezier: function(a, b, c, d, e, f, k) {
		f = f || this._lineWidth;
		k = k || this.getDrawColor();
		null == k.a && (k.a = 255);
		for (var m = [], n = 0, p = 0; p < e; p++) {
			var r = Math.pow(1 - n, 3) * a.x + 3 * Math.pow(1 - n, 2) * n * b.x + 3 * (1 - n) * n * n * c.x + n * n * n * d.x,
				s = Math.pow(1 - n, 3) * a.y + 3 * Math.pow(1 - n, 2) * n * b.y + 3 * (1 - n) * n * n * c.y + n * n * n * d.y;
			m.push(cc.p(r, s));
			n += 1 / e
		}
		m.push(cc.p(d.x, d.y));
		a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		a.verts = m;
		a.lineWidth = f;
		a.lineColor = k;
		a.isStroke = !0;
		a.lineCap = "round";
		this._buffer.push(a)
	},
	drawCatmullRom: function(a, b, c, d) {
		this.drawCardinalSpline(a, 0.5, b, c, d)
	},
	drawCardinalSpline: function(a, b, c, d, e) {
		d = d || this._lineWidth;
		e = e || this.getDrawColor();
		null == e.a && (e.a = 255);
		for (var f = [], k, m, n = 1 / a.length, p = 0; p < c + 1; p++) m = p / c, 1 === m ? (k = a.length - 1, m = 1) : (k = 0 | m / n, m = (m - n * k) / n), k = cc.cardinalSplineAt(cc.getControlPointAt(a, k - 1), cc.getControlPointAt(a, k - 0), cc.getControlPointAt(a, k + 1), cc.getControlPointAt(a, k + 2), b, m), f.push(k);
		a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		a.verts = f;
		a.lineWidth = d;
		a.lineColor = e;
		a.isStroke = !0;
		a.lineCap = "round";
		this._buffer.push(a)
	},
	drawDot: function(a, b, c) {
		c = c || this.getDrawColor();
		null == c.a && (c.a = 255);
		var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
		d.verts = [a];
		d.lineWidth = b;
		d.fillColor = c;
		this._buffer.push(d)
	},
	drawDots: function(a, b, c) {
		if (a && 0 != a.length) {
			c = c || this.getDrawColor();
			null == c.a && (c.a = 255);
			for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
		}
	},
	drawSegment: function(a, b, c, d) {
		c = c || this._lineWidth;
		d = d || this.getDrawColor();
		null == d.a && (d.a = 255);
		var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		e.verts = [a, b];
		e.lineWidth = 2 * c;
		e.lineColor = d;
		e.isStroke = !0;
		e.lineCap = "round";
		this._buffer.push(e)
	},
	drawPoly_: function(a, b, c, d) {
		c = null == c ? this._lineWidth : c;
		d = d || this.getDrawColor();
		null == d.a && (d.a = 255);
		var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
		e.verts = a;
		e.fillColor = b;
		e.lineWidth = c;
		e.lineColor = d;
		e.isClosePolygon = !0;
		e.isStroke = !0;
		e.lineCap = "round";
		b && (e.isFill = !0);
		this._buffer.push(e)
	},
	drawPoly: function(a, b, c, d) {
		for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
		return this.drawPoly_(e, b, c, d)
	},
	clear: function() {
		this._buffer.length = 0
	},
	_createRenderCmd: function() {
		return new cc.DrawNode.CanvasRenderCmd(this)
	}
});
cc.DrawNodeWebGL = cc.Node.extend({
	_bufferCapacity: 0,
	_buffer: null,
	_trianglesArrayBuffer: null,
	_trianglesWebBuffer: null,
	_trianglesReader: null,
	_lineWidth: 1,
	_drawColor: null,
	_blendFunc: null,
	_dirty: !1,
	_className: "DrawNodeWebGL",
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a, b) {
		void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
	},
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._buffer = [];
		this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		this._drawColor = cc.color(255, 255, 255, 255);
		this.init()
	},
	init: function() {
		return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
	},
	setLineWidth: function(a) {
		this._lineWidth = a
	},
	getLineWidth: function() {
		return this._lineWidth
	},
	setDrawColor: function(a) {
		var b = this._drawColor;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		b.a = a.a
	},
	getDrawColor: function() {
		return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
	},
	drawRect: function(a, b, c, d, e) {
		d = null == d ? this._lineWidth : d;
		e = e || this.getDrawColor();
		null == e.a && (e.a = 255);
		a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
		null == c ? this._drawSegments(a, d, e, !0) : this.drawPoly(a, c, d, e)
	},
	drawCircle: function(a, b, c, d, e, f, k) {
		f = f || this._lineWidth;
		k = k || this.getDrawColor();
		null == k.a && (k.a = 255);
		var m = 2 * Math.PI / d,
			n = [],
			p;
		for (p = 0; p <= d; p++) {
			var r = p * m,
				s = b * Math.cos(r + c) + a.x,
				r = b * Math.sin(r + c) + a.y;
			n.push(cc.p(s, r))
		}
		e && n.push(cc.p(a.x, a.y));
		f *= 0.5;
		p = 0;
		for (a = n.length; p < a - 1; p++) this.drawSegment(n[p], n[p + 1], f, k)
	},
	drawQuadBezier: function(a, b, c, d, e, f) {
		e = e || this._lineWidth;
		f = f || this.getDrawColor();
		null == f.a && (f.a = 255);
		for (var k = [], m = 0, n = 0; n < d; n++) {
			var p = Math.pow(1 - m, 2) * a.x + 2 * (1 - m) * m * b.x + m * m * c.x,
				r = Math.pow(1 - m, 2) * a.y + 2 * (1 - m) * m * b.y + m * m * c.y;
			k.push(cc.p(p, r));
			m += 1 / d
		}
		k.push(cc.p(c.x, c.y));
		this._drawSegments(k, e, f, !1)
	},
	drawCubicBezier: function(a, b, c, d, e, f, k) {
		f = f || this._lineWidth;
		k = k || this.getDrawColor();
		null == k.a && (k.a = 255);
		for (var m = [], n = 0, p = 0; p < e; p++) {
			var r = Math.pow(1 - n, 3) * a.x + 3 * Math.pow(1 - n, 2) * n * b.x + 3 * (1 - n) * n * n * c.x + n * n * n * d.x,
				s = Math.pow(1 - n, 3) * a.y + 3 * Math.pow(1 - n, 2) * n * b.y + 3 * (1 - n) * n * n * c.y + n * n * n * d.y;
			m.push(cc.p(r, s));
			n += 1 / e
		}
		m.push(cc.p(d.x, d.y));
		this._drawSegments(m, f, k, !1)
	},
	drawCatmullRom: function(a, b, c, d) {
		this.drawCardinalSpline(a, 0.5, b, c, d)
	},
	drawCardinalSpline: function(a, b, c, d, e) {
		d = d || this._lineWidth;
		e = e || this.getDrawColor();
		null == e.a && (e.a = 255);
		for (var f = [], k, m, n = 1 / a.length, p = 0; p < c + 1; p++) m = p / c, 1 === m ? (k = a.length - 1, m = 1) : (k = 0 | m / n, m = (m - n * k) / n), k = cc.cardinalSplineAt(cc.getControlPointAt(a, k - 1), cc.getControlPointAt(a, k - 0), cc.getControlPointAt(a, k + 1), cc.getControlPointAt(a, k + 2), b, m), f.push(k);
		d *= 0.5;
		a = 0;
		for (b = f.length; a < b - 1; a++) this.drawSegment(f[a], f[a + 1], d, e)
	},
	_render: function() {
		var a = cc._renderContext;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
		a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
		this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
		var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
		a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
		cc.incrementGLDraws(1)
	},
	_ensureCapacity: function(a) {
		var b = this._buffer;
		if (b.length + a > this._bufferCapacity) {
			var c = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
			this._bufferCapacity += Math.max(this._bufferCapacity, a);
			if (null == b || 0 === b.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(c * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
			else {
				a = [];
				for (var d = new ArrayBuffer(c * this._bufferCapacity), e = 0; e < b.length; e++) a[e] = new cc.V2F_C4B_T2F_Triangle(b[e].a, b[e].b, b[e].c, d, e * c);
				this._trianglesReader = new Uint8Array(d);
				this._trianglesArrayBuffer = d;
				this._buffer = a
			}
		}
	},
	drawDot: function(a, b, c) {
		c = c || this.getDrawColor();
		null == c.a && (c.a = 255);
		var d = {
			r: 0 | c.r,
			g: 0 | c.g,
			b: 0 | c.b,
			a: 0 | c.a
		};
		c = {
			vertices: {
				x: a.x - b,
				y: a.y - b
			},
			colors: d,
			texCoords: {
				u: -1,
				v: -1
			}
		};
		var e = {
			vertices: {
				x: a.x - b,
				y: a.y + b
			},
			colors: d,
			texCoords: {
				u: -1,
				v: 1
			}
		},
			f = {
				vertices: {
					x: a.x + b,
					y: a.y + b
				},
				colors: d,
				texCoords: {
					u: 1,
					v: 1
				}
			};
		a = {
			vertices: {
				x: a.x + b,
				y: a.y - b
			},
			colors: d,
			texCoords: {
				u: 1,
				v: -1
			}
		};
		this._ensureCapacity(6);
		this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, e, f, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
		this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, f, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
		this._dirty = !0
	},
	drawDots: function(a, b, c) {
		if (a && 0 !== a.length) {
			c = c || this.getDrawColor();
			null == c.a && (c.a = 255);
			for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
		}
	},
	drawSegment: function(a, b, c, d) {
		d = d || this.getDrawColor();
		null == d.a && (d.a = 255);
		c = c || 0.5 * this._lineWidth;
		this._ensureCapacity(18);
		d = {
			r: 0 | d.r,
			g: 0 | d.g,
			b: 0 | d.b,
			a: 0 | d.a
		};
		var e = cc.__v2f(a),
			f = cc.__v2f(b);
		b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(f, e)));
		a = cc.v2fperp(b);
		var k = cc.v2fmult(b, c),
			m = cc.v2fmult(a, c);
		c = cc.v2fsub(f, cc.v2fadd(k, m));
		var n = cc.v2fadd(f, cc.v2fsub(k, m)),
			p = cc.v2fsub(f, k),
			f = cc.v2fadd(f, k),
			r = cc.v2fsub(e, k),
			s = cc.v2fadd(e, k),
			u = cc.v2fsub(e, cc.v2fsub(k, m)),
			e = cc.v2fadd(e, cc.v2fadd(k, m)),
			k = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
			m = this._trianglesArrayBuffer,
			t = this._buffer;
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: c,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
		}, {
			vertices: n,
			colors: d,
			texCoords: cc.__t(cc.v2fsub(b, a))
		}, {
			vertices: p,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, m, t.length * k));
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: f,
			colors: d,
			texCoords: cc.__t(b)
		}, {
			vertices: n,
			colors: d,
			texCoords: cc.__t(cc.v2fsub(b, a))
		}, {
			vertices: p,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, m, t.length * k));
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: f,
			colors: d,
			texCoords: cc.__t(b)
		}, {
			vertices: r,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, {
			vertices: p,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, m, t.length * k));
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: f,
			colors: d,
			texCoords: cc.__t(b)
		}, {
			vertices: r,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, {
			vertices: s,
			colors: d,
			texCoords: cc.__t(b)
		}, m, t.length * k));
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: u,
			colors: d,
			texCoords: cc.__t(cc.v2fsub(a, b))
		}, {
			vertices: r,
			colors: d,
			texCoords: cc.__t(cc.v2fneg(b))
		}, {
			vertices: s,
			colors: d,
			texCoords: cc.__t(b)
		}, m, t.length * k));
		t.push(new cc.V2F_C4B_T2F_Triangle({
			vertices: u,
			colors: d,
			texCoords: cc.__t(cc.v2fsub(a, b))
		}, {
			vertices: e,
			colors: d,
			texCoords: cc.__t(cc.v2fadd(b, a))
		}, {
			vertices: s,
			colors: d,
			texCoords: cc.__t(b)
		}, m, t.length * k));
		this._dirty = !0
	},
	drawPoly: function(a, b, c, d) {
		if (null == b) this._drawSegments(a, c, d, !0);
		else {
			null == b.a && (b.a = 255);
			null == d.a && (d.a = 255);
			c = null == c ? this._lineWidth : c;
			c *= 0.5;
			b = {
				r: 0 | b.r,
				g: 0 | b.g,
				b: 0 | b.b,
				a: 0 | b.a
			};
			d = {
				r: 0 | d.r,
				g: 0 | d.g,
				b: 0 | d.b,
				a: 0 | d.a
			};
			var e = [],
				f, k, m, n, p = a.length;
			for (f = 0; f < p; f++) {
				k = cc.__v2f(a[(f - 1 + p) % p]);
				m = cc.__v2f(a[f]);
				n = cc.__v2f(a[(f + 1) % p]);
				var r = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(m, k)));
				m = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(n, m)));
				r = cc.v2fmult(cc.v2fadd(r, m), 1 / (cc.v2fdot(r, m) + 1));
				e[f] = {
					offset: r,
					n: m
				}
			}
			r = 0 < c;
			this._ensureCapacity(3 * (3 * p - 2));
			var s = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
				u = this._trianglesArrayBuffer,
				t = this._buffer,
				w = !1 == r ? 0.5 : 0;
			for (f = 0; f < p - 2; f++) k = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(e[0].offset, w)), m = cc.v2fsub(cc.__v2f(a[f + 1]), cc.v2fmult(e[f + 1].offset, w)), n = cc.v2fsub(cc.__v2f(a[f + 2]), cc.v2fmult(e[f + 2].offset, w)), t.push(new cc.V2F_C4B_T2F_Triangle({
				vertices: k,
				colors: b,
				texCoords: cc.__t(cc.v2fzero())
			}, {
				vertices: m,
				colors: b,
				texCoords: cc.__t(cc.v2fzero())
			}, {
				vertices: n,
				colors: b,
				texCoords: cc.__t(cc.v2fzero())
			}, u, t.length * s));
			for (f = 0; f < p; f++) {
				w = (f + 1) % p;
				k = cc.__v2f(a[f]);
				m = cc.__v2f(a[w]);
				n = e[f].n;
				var v = e[f].offset,
					y = e[w].offset,
					w = r ? cc.v2fsub(k, cc.v2fmult(v, c)) : cc.v2fsub(k, cc.v2fmult(v, 0.5)),
					z = r ? cc.v2fsub(m, cc.v2fmult(y, c)) : cc.v2fsub(m, cc.v2fmult(y, 0.5));
				k = r ? cc.v2fadd(k, cc.v2fmult(v, c)) : cc.v2fadd(k, cc.v2fmult(v, 0.5));
				m = r ? cc.v2fadd(m, cc.v2fmult(y, c)) : cc.v2fadd(m, cc.v2fmult(y, 0.5));
				r ? (t.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: w,
					colors: d,
					texCoords: cc.__t(cc.v2fneg(n))
				}, {
					vertices: z,
					colors: d,
					texCoords: cc.__t(cc.v2fneg(n))
				}, {
					vertices: m,
					colors: d,
					texCoords: cc.__t(n)
				}, u, t.length * s)), t.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: w,
					colors: d,
					texCoords: cc.__t(cc.v2fneg(n))
				}, {
					vertices: k,
					colors: d,
					texCoords: cc.__t(n)
				}, {
					vertices: m,
					colors: d,
					texCoords: cc.__t(n)
				}, u, t.length * s))) : (t.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: w,
					colors: b,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: z,
					colors: b,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: m,
					colors: b,
					texCoords: cc.__t(n)
				}, u, t.length * s)), t.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: w,
					colors: b,
					texCoords: cc.__t(cc.v2fzero())
				}, {
					vertices: k,
					colors: b,
					texCoords: cc.__t(n)
				}, {
					vertices: m,
					colors: b,
					texCoords: cc.__t(n)
				}, u, t.length * s)))
			}
			this._dirty = !0
		}
	},
	_drawSegments: function(a, b, c, d) {
		b = null == b ? this._lineWidth : b;
		c = c || this._drawColor;
		null == c.a && (c.a = 255);
		b *= 0.5;
		if (!(0 >= b)) {
			c = {
				r: 0 | c.r,
				g: 0 | c.g,
				b: 0 | c.b,
				a: 0 | c.a
			};
			var e = [],
				f, k, m, n, p = a.length;
			for (f = 0; f < p; f++) {
				k = cc.__v2f(a[(f - 1 + p) % p]);
				m = cc.__v2f(a[f]);
				n = cc.__v2f(a[(f + 1) % p]);
				var r = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(m, k)));
				m = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(n, m)));
				n = cc.v2fmult(cc.v2fadd(r, m), 1 / (cc.v2fdot(r, m) + 1));
				e[f] = {
					offset: n,
					n: m
				}
			}
			this._ensureCapacity(3 * (3 * p - 2));
			n = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
			var r = this._trianglesArrayBuffer,
				s = this._buffer;
			d = d ? p : p - 1;
			for (f = 0; f < d; f++) {
				var u = (f + 1) % p;
				k = cc.__v2f(a[f]);
				m = cc.__v2f(a[u]);
				var t = e[f].n,
					w = e[f].offset,
					v = e[u].offset,
					u = cc.v2fsub(k, cc.v2fmult(w, b)),
					y = cc.v2fsub(m, cc.v2fmult(v, b));
				k = cc.v2fadd(k, cc.v2fmult(w, b));
				m = cc.v2fadd(m, cc.v2fmult(v, b));
				s.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: u,
					colors: c,
					texCoords: cc.__t(cc.v2fneg(t))
				}, {
					vertices: y,
					colors: c,
					texCoords: cc.__t(cc.v2fneg(t))
				}, {
					vertices: m,
					colors: c,
					texCoords: cc.__t(t)
				}, r, s.length * n));
				s.push(new cc.V2F_C4B_T2F_Triangle({
					vertices: u,
					colors: c,
					texCoords: cc.__t(cc.v2fneg(t))
				}, {
					vertices: k,
					colors: c,
					texCoords: cc.__t(t)
				}, {
					vertices: m,
					colors: c,
					texCoords: cc.__t(t)
				}, r, s.length * n))
			}
			this._dirty = !0
		}
	},
	clear: function() {
		this._buffer.length = 0;
		this._dirty = !0
	},
	_createRenderCmd: function() {
		return new cc.DrawNode.WebGLRenderCmd(this)
	}
});
cc.DrawNode = cc._renderType === cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function() {
	return new cc.DrawNode
};
cc._DrawNodeElement = function(a, b, c, d, e, f, k, m, n) {
	this.type = a;
	this.verts = b || null;
	this.fillColor = c || null;
	this.lineWidth = d || 0;
	this.lineColor = e || null;
	this.lineCap = f || "butt";
	this.isClosePolygon = k || !1;
	this.isFill = m || !1;
	this.isStroke = n || !1
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
(function() {
	cc.DrawNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._blendFunc = this._drawColor = this._buffer = null
	};
	cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd;
	cc.DrawNode.CanvasRenderCmd.prototype.rendering = function(a, b, c) {
		a = a || cc._renderContext;
		a.getContext();
		var d = this._node._displayedOpacity / 255;
		if (0 !== d) {
			a.setTransform(this._worldTransform, b, c);
			a.setGlobalAlpha(d);
			this._blendFunc && (this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE) && a.setCompositeOperation("lighter");
			for (var d = this._buffer, e = 0, f = d.length; e < f; e++) {
				var k = d[e];
				switch (k.type) {
				case cc.DrawNode.TYPE_DOT:
					this._drawDot(a, k, b, c);
					break;
				case cc.DrawNode.TYPE_SEGMENT:
					this._drawSegment(a, k, b, c);
					break;
				case cc.DrawNode.TYPE_POLY:
					this._drawPoly(a, k, b, c)
				}
			}
		}
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawDot = function(a, b, c, d) {
		var e = b.fillColor,
			f = b.verts[0];
		b = b.lineWidth;
		var k = a.getContext();
		a.setFillStyle("rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
		k.beginPath();
		k.arc(f.x * c, -f.y * d, b * c, 0, 2 * Math.PI, !1);
		k.closePath();
		k.fill()
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawSegment = function(a, b, c, d) {
		var e = b.lineColor,
			f = b.verts[0],
			k = b.verts[1],
			m = b.lineWidth;
		b = b.lineCap;
		var n = a.getContext();
		a.setStrokeStyle("rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
		n.lineWidth = m * c;
		n.beginPath();
		n.lineCap = b;
		n.moveTo(f.x * c, -f.y * d);
		n.lineTo(k.x * c, -k.y * d);
		n.stroke()
	};
	cc.DrawNode.CanvasRenderCmd.prototype._drawPoly = function(a, b, c, d) {
		var e = b.verts,
			f = b.lineCap;
		if (null != e) {
			var k = b.fillColor,
				m = b.lineWidth,
				n = b.lineColor,
				p = b.isClosePolygon,
				r = b.isFill;
			b = b.isStroke;
			var s = a.getContext(),
				u = e[0];
			s.lineCap = f;
			k && a.setFillStyle("rgba(" + (0 | k.r) + "," + (0 | k.g) + "," + (0 | k.b) + "," + k.a / 255 + ")");
			m && (s.lineWidth = m * c);
			n && a.setStrokeStyle("rgba(" + (0 | n.r) + "," + (0 | n.g) + "," + (0 | n.b) + "," + n.a / 255 + ")");
			s.beginPath();
			s.moveTo(u.x * c, -u.y * d);
			a = 1;
			for (f = e.length; a < f; a++) s.lineTo(e[a].x * c, -e[a].y * d);
			p && s.closePath();
			r && s.fill();
			b && s.stroke()
		}
	}
})();
(function() {
	cc.DrawNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
	cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(a) {
		a = this._node;
		cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
		a._render()
	}
})();
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
	alphaThreshold: 0,
	inverted: !1,
	_stencil: null,
	_className: "ClippingNode",
	ctor: function(a) {
		a = a || null;
		cc.Node.prototype.ctor.call(this);
		this._stencil = a;
		this.alphaThreshold = 1;
		this.inverted = !1;
		this._renderCmd.initStencilBits()
	},
	init: function(a) {
		this._stencil = a;
		this.alphaThreshold = 1;
		this.inverted = !1;
		this._renderCmd.initStencilBits();
		return !0
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this._stencil.onEnter()
	},
	onEnterTransitionDidFinish: function() {
		cc.Node.prototype.onEnterTransitionDidFinish.call(this);
		this._stencil.onEnterTransitionDidFinish()
	},
	onExitTransitionDidStart: function() {
		this._stencil.onExitTransitionDidStart();
		cc.Node.prototype.onExitTransitionDidStart.call(this)
	},
	onExit: function() {
		this._stencil.onExit();
		cc.Node.prototype.onExit.call(this)
	},
	getAlphaThreshold: function() {
		return this.alphaThreshold
	},
	setAlphaThreshold: function(a) {
		this.alphaThreshold = a
	},
	isInverted: function() {
		return this.inverted
	},
	setInverted: function(a) {
		this.inverted = a
	},
	getStencil: function() {
		return this._stencil
	},
	setStencil: function(a) {
		this._stencil !== a && this._renderCmd.setStencil(a)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
	}
});
_p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode.create = function(a) {
	return new cc.ClippingNode(a)
};
(function() {
	cc.ClippingNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._clipElemType = this._godhelpme = this._needDraw = !1;
		this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback);
		this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback);
		this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback)
	};
	var a = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ClippingNode.CanvasRenderCmd;
	a.initStencilBits = function() {};
	a.setStencil = function(a) {
		if (null != a) if (this._node._stencil = a, a instanceof cc.DrawNode) {
			if (a._buffer) for (var c = 0; c < a._buffer.length; c++) a._buffer[c].isFill = !1, a._buffer[c].isStroke = !1;
			a._renderCmd.rendering = function(c, e, f) {
				e = e || cc.view.getScaleX();
				f = f || cc.view.getScaleY();
				c = (c || cc._renderContext).getContext();
				var k = this._transform;
				c.transform(k.a, k.b, k.c, k.d, k.tx * e, -k.ty * f);
				for (k = 0; k < a._buffer.length; k++) {
					var m = a._buffer[k].verts,
						n = m[0];
					c.moveTo(n.x * e, -n.y * f);
					for (n = m.length - 1; 0 < n; n--) c.lineTo(m[n].x * e, -m[n].y * f)
				}
			}
		} else a._parent = this._node
	};
	a._saveCmdCallback = function(a, c, d) {
		var e = a || cc._renderContext;
		a = e.getContext();
		this._clipElemType ? (c = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), d = a.canvas, c.width = d.width, c.height = d.height, c.getContext("2d").drawImage(d, 0, 0)) : (e.save(), a.beginPath(), e.setTransform(this._worldTransform, c, d), this._node.inverted && (a.rect(0, 0, a.canvas.width, -a.canvas.height), a.clip()))
	};
	a._setStencilCompositionOperation = function(a) {
		if (a) {
			var c = this._node;
			a._renderCmd && a._renderCmd._blendFuncStr && (a._renderCmd._blendFuncStr = c.inverted ? "destination-out" : "destination-in");
			if (a._children) {
				a = a._children;
				for (var c = 0, d = a.length; c < d; c++) this._setStencilCompositionOperation(a[c])
			}
		}
	};
	a._clipCmdCallback = function(a) {
		var c = this._node;
		a = (a || cc._renderContext).getContext();
		this._clipElemType ? this._setStencilCompositionOperation(c._stencil) : a.clip()
	};
	a._restoreCmdCallback = function(a) {
		var c = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
		a = a || cc._renderContext;
		var d = a.getContext();
		this._clipElemType ? (d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.globalCompositeOperation = "destination-over", d.drawImage(c, 0, 0), d.restore(), this._dirtyFlag = 0) : a.restore()
	};
	a.transform = function(a, c) {
		cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, c);
		var d = this._node;
		d._stencil && d._stencil._renderCmd && d._stencil._renderCmd.transform(this, c)
	};
	a._cangodhelpme = function(a) {
		if (!0 === a || !1 === a) cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = a;
		return cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
	};
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) {
			if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
			this._clipElemType = !(!this._cangodhelpme() && c._stencil instanceof cc.DrawNode);
			if (!c._stencil || !c._stencil.visible) this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, a);
			else {
				this._syncStatus(a);
				cc.renderer.pushRenderCommand(this._rendererSaveCmd);
				this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, a) : c._stencil.visit(this);
				cc.renderer.pushRenderCommand(this._rendererClipCmd);
				if (this._clipElemType) c._stencil.visit(this);
				else {
					a = c._children;
					this._cangodhelpme(!0);
					var d = a.length;
					if (0 < d) {
						c.sortAllChildren();
						for (c = 0; c < d; c++) a[c]._renderCmd.visit(this)
					}
					this._cangodhelpme(!1)
				}
				cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
				this._dirtyFlag = 0
			}
		}
	};
	cc.ClippingNode.CanvasRenderCmd._sharedCache = null;
	cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
		return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"))
	}
})();
(function() {
	cc.ClippingNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !1;
		this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
		this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
		this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
		this._mask_layer_le = this._currentDepthWriteMask = this._currentStencilEnabled = this._currentStencilWriteMask = this._currentStencilPassDepthPass = this._currentStencilPassDepthFail = this._currentStencilFail = this._currentStencilValueMask = this._currentStencilRef = this._currentStencilFunc = null
	};
	var a = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.ClippingNode.WebGLRenderCmd;
	cc.ClippingNode.WebGLRenderCmd._init_once = null;
	cc.ClippingNode.WebGLRenderCmd._visit_once = null;
	cc.ClippingNode.WebGLRenderCmd._layer = -1;
	a.initStencilBits = function() {
		cc.ClippingNode.WebGLRenderCmd._init_once = !0;
		cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1)
	};
	a.transform = function(a, c) {
		var d = this._node;
		cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, c);
		d._stencil && d._stencil._renderCmd.transform(this, c)
	};
	a.visit = function(a) {
		var c = this._node;
		if (c._visible) if (c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1), 1 > cc.stencilBits) cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
		else if (!c._stencil || !c._stencil.visible) c.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
		else if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits) cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."), cc.ClippingNode.WebGLRenderCmd._visit_once = !1), cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
		else {
			cc.renderer.pushRenderCommand(this._beforeVisitCmd);
			var d = cc.current_stack;
			d.stack.push(d.top);
			this._syncStatus(a);
			d.top = this._stackMatrix;
			c._stencil._renderCmd.visit(this);
			cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
			if ((a = c._children) && 0 < a.length) {
				var e = a.length;
				c.sortAllChildren();
				for (c = 0; c < e; c++) a[c]._renderCmd.visit(this)
			}
			cc.renderer.pushRenderCommand(this._afterVisitCmd);
			this._dirtyFlag = 0;
			d.top = d.stack.pop()
		}
	};
	a.setStencil = function(a) {
		var c = this._node;
		c._stencil && (c._stencil._parent = null);
		c._stencil = a;
		c._stencil && (c._stencil._parent = c)
	};
	a._drawFullScreenQuadClearStencil = function() {
		var a = cc.projection_matrix_stack;
		a.push();
		a.top.identity();
		var c = cc.modelview_matrix_stack;
		c.push();
		c.top.identity();
		cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
		a.pop();
		c.pop()
	};
	a._onBeforeVisit = function(a) {
		var c = a || cc._renderContext;
		a = this._node;
		cc.ClippingNode.WebGLRenderCmd._layer++;
		var d = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
		this._mask_layer_le = d | d - 1;
		this._currentStencilEnabled = c.isEnabled(c.STENCIL_TEST);
		this._currentStencilWriteMask = c.getParameter(c.STENCIL_WRITEMASK);
		this._currentStencilFunc = c.getParameter(c.STENCIL_FUNC);
		this._currentStencilRef = c.getParameter(c.STENCIL_REF);
		this._currentStencilValueMask = c.getParameter(c.STENCIL_VALUE_MASK);
		this._currentStencilFail = c.getParameter(c.STENCIL_FAIL);
		this._currentStencilPassDepthFail = c.getParameter(c.STENCIL_PASS_DEPTH_FAIL);
		this._currentStencilPassDepthPass = c.getParameter(c.STENCIL_PASS_DEPTH_PASS);
		c.enable(c.STENCIL_TEST);
		c.stencilMask(d);
		this._currentDepthWriteMask = c.getParameter(c.DEPTH_WRITEMASK);
		c.depthMask(!1);
		c.stencilFunc(c.NEVER, d, d);
		c.stencilOp(!a.inverted ? c.ZERO : c.REPLACE, c.KEEP, c.KEEP);
		this._drawFullScreenQuadClearStencil();
		c.stencilFunc(c.NEVER, d, d);
		c.stencilOp(!a.inverted ? c.REPLACE : c.ZERO, c.KEEP, c.KEEP);
		1 > a.alphaThreshold && (d = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), c = c.getUniformLocation(d.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), cc.glUseProgram(d.getProgram()), d.setUniformLocationWith1f(c, a.alphaThreshold), cc.setProgram(a._stencil, d))
	};
	a._onAfterDrawStencil = function(a) {
		a = a || cc._renderContext;
		a.depthMask(this._currentDepthWriteMask);
		a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
		a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
	};
	a._onAfterVisit = function(a) {
		a = a || cc._renderContext;
		a.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask);
		a.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
		a.stencilMask(this._currentStencilWriteMask);
		this._currentStencilEnabled || a.disable(a.STENCIL_TEST);
		cc.ClippingNode.WebGLRenderCmd._layer--
	}
})();
cc.GridBase = cc.Class.extend({
	_active: !1,
	_reuseGrid: 0,
	_gridSize: null,
	_gridRect: null,
	_texture: null,
	_step: null,
	_grabber: null,
	_isTextureFlipped: !1,
	_shaderProgram: null,
	_directorProjection: 0,
	_dirty: !1,
	ctor: function(a, b, c, d) {
		cc._checkWebGLRenderMode();
		this._active = !1;
		this._reuseGrid = 0;
		this._gridSize = null;
		this._gridRect = new cc.rect;
		this._texture = null;
		this._step = cc.p(0, 0);
		this._grabber = null;
		this._isTextureFlipped = !1;
		this._shaderProgram = null;
		this._directorProjection = 0;
		this._dirty = !1;
		void 0 !== a && this.initWithSize(a, b, c, d)
	},
	isActive: function() {
		return this._active
	},
	setActive: function(a) {
		this._active = a;
		if (!a) {
			a = cc.director;
			var b = a.getProjection();
			a.setProjection(b)
		}
	},
	getReuseGrid: function() {
		return this._reuseGrid
	},
	setReuseGrid: function(a) {
		this._reuseGrid = a
	},
	getGridSize: function() {
		return cc.size(this._gridSize.width, this._gridSize.height)
	},
	setGridSize: function(a) {
		this._gridSize.width = parseInt(a.width);
		this._gridSize.height = parseInt(a.height)
	},
	setGridRect: function(a) {
		this._gridRect = a
	},
	getGridRect: function() {
		return this._gridRect
	},
	getStep: function() {
		return cc.p(this._step.x, this._step.y)
	},
	setStep: function(a) {
		this._step.x = a.x;
		this._step.y = a.y
	},
	isTextureFlipped: function() {
		return this._isTextureFlipped
	},
	setTextureFlipped: function(a) {
		this._isTextureFlipped !== a && (this._isTextureFlipped = a, this.calculateVertexPoints())
	},
	initWithSize: function(a, b, c, d) {
		if (!b) {
			var e = cc.director.getWinSizeInPixels(),
				f = cc.NextPOT(e.width),
				k = cc.NextPOT(e.height),
				m = new Uint8Array(4 * f * k);
			if (!m) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
			b = new cc.Texture2D;
			b.initWithData(m, cc.Texture2D.PIXEL_FORMAT_RGBA8888, f, k, e);
			if (!b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
		}
		this._active = !1;
		this._reuseGrid = 0;
		this._gridSize = a;
		this._texture = b;
		this._isTextureFlipped = c || !1;
		if (void 0 === d || cc._rectEqualToZero(d)) b = this._texture.getContentSize(), d = new cc.rect(0, 0, b.width, b.height);
		this._gridRect = d;
		this._step.x = this._gridRect.width / a.width;
		this._step.y = this._gridRect.height / a.height;
		this._grabber = new cc.Grabber;
		if (!this._grabber) return !1;
		this._grabber.grab(this._texture);
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
		this.calculateVertexPoints();
		return !0
	},
	beforeDraw: function() {
		this._directorProjection = cc.director.getProjection();
		this._grabber.beforeRender(this._texture)
	},
	afterDraw: function(a) {
		this._grabber.afterRender(this._texture);
		if (a && a.getCamera().isDirty()) {
			var b = a.getAnchorPointInPoints(),
				c = a._renderCmd._stackMatrix,
				d = cc.math.Matrix4.createByTranslation(b.x, b.y, 0);
			c.multiply(d);
			a._camera._locateForRenderer(c);
			d = cc.math.Matrix4.createByTranslation(-b.x, -b.y, 0, d);
			c.multiply(d)
		}
		cc.glBindTexture2D(this._texture);
		this.beforeBlit();
		this.blit(a);
		this.afterBlit()
	},
	beforeBlit: function() {},
	afterBlit: function() {},
	blit: function() {
		cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
	},
	reuse: function() {
		cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
	},
	calculateVertexPoints: function() {
		cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
	},
	set2DProjection: function() {
		var a = cc.director.getWinSizeInPixels();
		cc._renderContext.viewport(0, 0, a.width, a.height);
		cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
		cc.kmGLLoadIdentity();
		a = cc.math.Matrix4.createOrthographicProjection(0, a.width, 0, a.height, -1, 1);
		cc.kmGLMultMatrix(a);
		cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
		cc.kmGLLoadIdentity();
		cc.setProjectionMatrixDirty()
	}
});
cc.GridBase.create = function(a, b, c, d) {
	return new cc.GridBase(a, b, c, d)
};
cc.Grid3D = cc.GridBase.extend({
	_texCoordinates: null,
	_vertices: null,
	_originalVertices: null,
	_indices: null,
	_texCoordinateBuffer: null,
	_verticesBuffer: null,
	_indicesBuffer: null,
	_needDepthTestForBlit: !1,
	_oldDepthTestValue: !1,
	_oldDepthWriteValue: !1,
	ctor: function(a, b, c, d) {
		cc.GridBase.prototype.ctor.call(this);
		this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
		void 0 !== a && this.initWithSize(a, b, c, d)
	},
	vertex: function(a) {
		return this.getVertex(a)
	},
	getVertex: function(a) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
		a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
		var b = this._vertices;
		return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
	},
	originalVertex: function(a) {
		return this.getOriginalVertex(a)
	},
	getOriginalVertex: function(a) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
		a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
		var b = this._originalVertices;
		return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
	},
	setVertex: function(a, b) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
		var c = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
			d = this._vertices;
		d[c] = b.x;
		d[c + 1] = b.y;
		d[c + 2] = b.z;
		this._dirty = !0
	},
	beforeBlit: function() {
		if (this._needDepthTestForBlit) {
			var a = cc._renderContext;
			this._oldDepthTestValue = a.isEnabled(a.DEPTH_TEST);
			this._oldDepthWriteValue = a.getParameter(a.DEPTH_WRITEMASK);
			a.enable(a.DEPTH_TEST);
			a.depthMask(!0)
		}
	},
	afterBlit: function() {
		if (this._needDepthTestForBlit) {
			var a = cc._renderContext;
			this._oldDepthTestValue ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST);
			a.depthMask(this._oldDepthWriteValue)
		}
	},
	blit: function(a) {
		var b = this._gridSize.width * this._gridSize.height;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
		a = cc._renderContext;
		var c = this._dirty;
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
		c && a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
		c && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		c && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
		a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
		c && (this._dirty = !1);
		cc.incrementGLDraws(1)
	},
	reuse: function() {
		if (0 < this._reuseGrid) {
			for (var a = this._originalVertices, b = this._vertices, c = 0, d = this._vertices.length; c < d; c++) a[c] = b[c];
			--this._reuseGrid
		}
	},
	calculateVertexPoints: function() {
		var a = cc._renderContext,
			b = this._texture.pixelsWidth,
			c = this._texture.pixelsHeight,
			d = this._texture.getContentSizeInPixels().height,
			e = this._gridSize,
			f = (e.width + 1) * (e.height + 1);
		this._vertices = new Float32Array(3 * f);
		this._texCoordinates = new Float32Array(2 * f);
		this._indices = new Uint16Array(6 * e.width * e.height);
		this._verticesBuffer && a.deleteBuffer(this._verticesBuffer);
		this._verticesBuffer = a.createBuffer();
		this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer);
		this._texCoordinateBuffer = a.createBuffer();
		this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
		this._indicesBuffer = a.createBuffer();
		for (var k, m, n = this._indices, p = this._texCoordinates, r = this._isTextureFlipped, s = this._vertices, f = 0; f < e.width; ++f)
		for (k = 0; k < e.height; ++k) {
			var u = k * e.width + f;
			m = f * this._step.x + this._gridRect.x;
			var t = m + this._step.x,
				w = k * this._step.y + this._gridRect.y,
				v = w + this._step.y,
				y = f * (e.height + 1) + k,
				z = (f + 1) * (e.height + 1) + k,
				F = (f + 1) * (e.height + 1) + (k + 1),
				E = f * (e.height + 1) + (k + 1);
			n[6 * u] = y;
			n[6 * u + 1] = z;
			n[6 * u + 2] = E;
			n[6 * u + 3] = z;
			n[6 * u + 4] = F;
			n[6 * u + 5] = E;
			var u = [3 * y, 3 * z, 3 * F, 3 * E],
				C = [{
					x: m,
					y: w,
					z: 0
				}, {
					x: t,
					y: w,
					z: 0
				}, {
					x: t,
					y: v,
					z: 0
				}, {
					x: m,
					y: v,
					z: 0
				}],
				y = [2 * y, 2 * z, 2 * F, 2 * E],
				t = [cc.p(m, w), cc.p(t, w), cc.p(t, v), cc.p(m, v)];
			for (m = 0; 4 > m; ++m) s[u[m]] = C[m].x, s[u[m] + 1] = C[m].y, s[u[m] + 2] = C[m].z, p[y[m]] = t[m].x / b, p[y[m] + 1] = r ? (d - t[m].y) / c : t[m].y / c
		}
		this._originalVertices = new Float32Array(this._vertices);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
		a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
		this._dirty = !0
	},
	setNeedDepthTestForBlit: function(a) {
		this._needDepthTestForBlit = a
	},
	getNeedDepthTestForBlit: function() {
		return this._needDepthTestForBlit
	}
});
cc.Grid3D.create = function(a, b, c) {
	return new cc.Grid3D(a, b, c)
};
cc.TiledGrid3D = cc.GridBase.extend({
	_texCoordinates: null,
	_vertices: null,
	_originalVertices: null,
	_indices: null,
	_texCoordinateBuffer: null,
	_verticesBuffer: null,
	_indicesBuffer: null,
	ctor: function(a, b, c, d) {
		cc.GridBase.prototype.ctor.call(this);
		this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
		void 0 !== a && this.initWithSize(a, b, c, d)
	},
	tile: function(a) {
		return this.getTile(a)
	},
	getTile: function(a) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
		a = 12 * (this._gridSize.height * a.x + a.y);
		var b = this._vertices;
		return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
	},
	getOriginalTile: function(a) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
		a = 12 * (this._gridSize.height * a.x + a.y);
		var b = this._originalVertices;
		return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
	},
	originalTile: function(a) {
		return this.getOriginalTile(a)
	},
	setTile: function(a, b) {
		(a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
		var c = 12 * (this._gridSize.height * a.x + a.y),
			d = this._vertices;
		d[c] = b.bl.x;
		d[c + 1] = b.bl.y;
		d[c + 2] = b.bl.z;
		d[c + 3] = b.br.x;
		d[c + 4] = b.br.y;
		d[c + 5] = b.br.z;
		d[c + 6] = b.tl.x;
		d[c + 7] = b.tl.y;
		d[c + 8] = b.tl.z;
		d[c + 9] = b.tr.x;
		d[c + 10] = b.tr.y;
		d[c + 11] = b.tr.z;
		this._dirty = !0
	},
	blit: function(a) {
		var b = this._gridSize.width * this._gridSize.height;
		this._shaderProgram.use();
		this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
		a = cc._renderContext;
		var c = this._dirty;
		cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
		a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
		c && a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 0, this._vertices);
		a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
		c && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
		a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, this._texCoordinates);
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		c && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
		a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
		c && (this._dirty = !1);
		cc.incrementGLDraws(1)
	},
	reuse: function() {
		if (0 < this._reuseGrid) {
			for (var a = this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
			--this._reuseGrid
		}
	},
	calculateVertexPoints: function() {
		var a = this._texture.pixelsWidth,
			b = this._texture.pixelsHeight,
			c = this._texture.getContentSizeInPixels().height,
			d = this._gridSize,
			e = d.width * d.height;
		this._vertices = new Float32Array(12 * e);
		this._texCoordinates = new Float32Array(8 * e);
		this._indices = new Uint16Array(6 * e);
		var f = cc._renderContext;
		this._verticesBuffer && f.deleteBuffer(this._verticesBuffer);
		this._verticesBuffer = f.createBuffer();
		this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer);
		this._texCoordinateBuffer = f.createBuffer();
		this._indicesBuffer && f.deleteBuffer(this._indicesBuffer);
		this._indicesBuffer = f.createBuffer();
		var k, m, n = 0,
			p = this._step,
			r = this._vertices,
			s = this._texCoordinates,
			u = this._isTextureFlipped;
		for (k = 0; k < d.width; k++)
		for (m = 0; m < d.height; m++) {
			var t = k * p.x,
				w = t + p.x,
				v = m * p.y,
				y = v + p.y;
			r[12 * n] = t;
			r[12 * n + 1] = v;
			r[12 * n + 2] = 0;
			r[12 * n + 3] = w;
			r[12 * n + 4] = v;
			r[12 * n + 5] = 0;
			r[12 * n + 6] = t;
			r[12 * n + 7] = y;
			r[12 * n + 8] = 0;
			r[12 * n + 9] = w;
			r[12 * n + 10] = y;
			r[12 * n + 11] = 0;
			var z = v,
				F = y;
			u && (z = c - v, F = c - y);
			s[8 * n] = t / a;
			s[8 * n + 1] = z / b;
			s[8 * n + 2] = w / a;
			s[8 * n + 3] = z / b;
			s[8 * n + 4] = t / a;
			s[8 * n + 5] = F / b;
			s[8 * n + 6] = w / a;
			s[8 * n + 7] = F / b;
			n++
		}
		a = this._indices;
		for (k = 0; k < e; k++) a[6 * k + 0] = 4 * k + 0, a[6 * k + 1] = 4 * k + 1, a[6 * k + 2] = 4 * k + 2, a[6 * k + 3] = 4 * k + 1, a[6 * k + 4] = 4 * k + 2, a[6 * k + 5] = 4 * k + 3;
		this._originalVertices = new Float32Array(this._vertices);
		f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer);
		f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW);
		f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer);
		f.bufferData(f.ARRAY_BUFFER, this._texCoordinates, f.DYNAMIC_DRAW);
		f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
		f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW);
		this._dirty = !0
	}
});
cc.TiledGrid3D.create = function(a, b, c) {
	return new cc.TiledGrid3D(a, b, c)
};
cc.Grabber = cc.Class.extend({
	_FBO: null,
	_oldFBO: null,
	_oldClearColor: null,
	_gl: null,
	ctor: function() {
		cc._checkWebGLRenderMode();
		this._gl = cc._renderContext;
		this._oldClearColor = [0, 0, 0, 0];
		this._oldFBO = null;
		this._FBO = this._gl.createFramebuffer()
	},
	grab: function(a) {
		var b = this._gl;
		this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING);
		b.bindFramebuffer(b.FRAMEBUFFER, this._FBO);
		b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
		b.checkFramebufferStatus(b.FRAMEBUFFER) !== b.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer");
		b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
	},
	beforeRender: function(a) {
		a = this._gl;
		this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
		a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
		this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
		a.clearColor(0, 0, 0, 0);
		a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
	},
	afterRender: function(a) {
		a = this._gl;
		a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
		a.colorMask(!0, !0, !0, !0)
	},
	destroy: function() {
		this._gl.deleteFramebuffer(this._FBO)
	}
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
	originalTarget: null,
	target: null,
	tag: cc.ACTION_TAG_INVALID,
	ctor: function() {
		this.target = this.originalTarget = null;
		this.tag = cc.ACTION_TAG_INVALID
	},
	copy: function() {
		cc.log("copy is deprecated. Please use clone instead.");
		return this.clone()
	},
	clone: function() {
		var a = new cc.Action;
		a.originalTarget = null;
		a.target = null;
		a.tag = this.tag;
		return a
	},
	isDone: function() {
		return !0
	},
	startWithTarget: function(a) {
		this.target = this.originalTarget = a
	},
	stop: function() {
		this.target = null
	},
	step: function(a) {
		cc.log("[Action step]. override me")
	},
	update: function(a) {
		cc.log("[Action update]. override me")
	},
	getTarget: function() {
		return this.target
	},
	setTarget: function(a) {
		this.target = a
	},
	getOriginalTarget: function() {
		return this.originalTarget
	},
	setOriginalTarget: function(a) {
		this.originalTarget = a
	},
	getTag: function() {
		return this.tag
	},
	setTag: function(a) {
		this.tag = a
	},
	retain: function() {},
	release: function() {}
});
cc.action = function() {
	return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
	_duration: 0,
	ctor: function() {
		cc.Action.prototype.ctor.call(this);
		this._duration = 0
	},
	getDuration: function() {
		return this._duration * (this._timesForRepeat || 1)
	},
	setDuration: function(a) {
		this._duration = a
	},
	reverse: function() {
		cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
		return null
	},
	clone: function() {
		return new cc.FiniteTimeAction
	}
});
cc.Speed = cc.Action.extend({
	_speed: 0,
	_innerAction: null,
	ctor: function(a, b) {
		cc.Action.prototype.ctor.call(this);
		this._speed = 0;
		this._innerAction = null;
		a && this.initWithAction(a, b)
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(a) {
		this._speed = a
	},
	initWithAction: function(a, b) {
		if (!a) throw Error("cc.Speed.initWithAction(): action must be non nil");
		this._innerAction = a;
		this._speed = b;
		return !0
	},
	clone: function() {
		var a = new cc.Speed;
		a.initWithAction(this._innerAction.clone(), this._speed);
		return a
	},
	startWithTarget: function(a) {
		cc.Action.prototype.startWithTarget.call(this, a);
		this._innerAction.startWithTarget(a)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	step: function(a) {
		this._innerAction.step(a * this._speed)
	},
	isDone: function() {
		return this._innerAction.isDone()
	},
	reverse: function() {
		return new cc.Speed(this._innerAction.reverse(), this._speed)
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.speed = function(a, b) {
	return new cc.Speed(a, b)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
	_followedNode: null,
	_boundarySet: !1,
	_boundaryFullyCovered: !1,
	_halfScreenSize: null,
	_fullScreenSize: null,
	_worldRect: null,
	leftBoundary: 0,
	rightBoundary: 0,
	topBoundary: 0,
	bottomBoundary: 0,
	ctor: function(a, b) {
		cc.Action.prototype.ctor.call(this);
		this._followedNode = null;
		this._boundaryFullyCovered = this._boundarySet = !1;
		this._fullScreenSize = this._halfScreenSize = null;
		this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
		this._worldRect = cc.rect(0, 0, 0, 0);
		a && (b ? this.initWithTarget(a, b) : this.initWithTarget(a))
	},
	clone: function() {
		var a = new cc.Follow,
			b = this._worldRect,
			b = new cc.Rect(b.x, b.y, b.width, b.height);
		a.initWithTarget(this._followedNode, b);
		return a
	},
	isBoundarySet: function() {
		return this._boundarySet
	},
	setBoudarySet: function(a) {
		this._boundarySet = a
	},
	initWithTarget: function(a, b) {
		if (!a) throw Error("cc.Follow.initWithAction(): followedNode must be non nil");
		b = b || cc.rect(0, 0, 0, 0);
		this._followedNode = a;
		this._worldRect = b;
		this._boundarySet = !cc._rectEqualToZero(b);
		this._boundaryFullyCovered = !1;
		var c = cc.director.getWinSize();
		this._fullScreenSize = cc.p(c.width, c.height);
		this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
		this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0));
		return !0
	},
	step: function(a) {
		a = this._followedNode.x;
		var b = this._followedNode.y;
		a = this._halfScreenSize.x - a;
		b = this._halfScreenSize.y - b;
		this.target._renderCmd._dirtyFlag = 0;
		this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a, b)
	},
	isDone: function() {
		return !this._followedNode.running
	},
	stop: function() {
		this.target = null;
		cc.Action.prototype.stop.call(this)
	}
});
cc.follow = function(a, b) {
	return new cc.Follow(a, b)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
	_elapsed: 0,
	_firstTick: !1,
	_easeList: null,
	_timesForRepeat: 1,
	_repeatForever: !1,
	_repeatMethod: !1,
	_speed: 1,
	_speedMethod: !1,
	ctor: function(a) {
		this._timesForRepeat = this._speed = 1;
		this._repeatForever = !1;
		this.MAX_VALUE = 2;
		this._speedMethod = this._repeatMethod = !1;
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && this.initWithDuration(a)
	},
	getElapsed: function() {
		return this._elapsed
	},
	initWithDuration: function(a) {
		this._duration = 0 === a ? cc.FLT_EPSILON : a;
		this._elapsed = 0;
		return this._firstTick = !0
	},
	isDone: function() {
		return this._elapsed >= this._duration
	},
	_cloneDecoration: function(a) {
		a._repeatForever = this._repeatForever;
		a._speed = this._speed;
		a._timesForRepeat = this._timesForRepeat;
		a._easeList = this._easeList;
		a._speedMethod = this._speedMethod;
		a._repeatMethod = this._repeatMethod
	},
	_reverseEaseList: function(a) {
		if (this._easeList) {
			a._easeList = [];
			for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
		}
	},
	clone: function() {
		var a = new cc.ActionInterval(this._duration);
		this._cloneDecoration(a);
		return a
	},
	easing: function(a) {
		this._easeList ? this._easeList.length = 0 : this._easeList = [];
		for (var b = 0; b < arguments.length; b++) this._easeList.push(arguments[b]);
		return this
	},
	_computeEaseTime: function(a) {
		var b = this._easeList;
		if (!b || 0 === b.length) return a;
		for (var c = 0, d = b.length; c < d; c++) a = b[c].easing(a);
		return a
	},
	step: function(a) {
		this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
		a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
		a = 1 > a ? a : 1;
		this.update(0 < a ? a : 0);
		this._repeatMethod && (1 < this._timesForRepeat && this.isDone()) && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
	},
	startWithTarget: function(a) {
		cc.Action.prototype.startWithTarget.call(this, a);
		this._elapsed = 0;
		this._firstTick = !0
	},
	reverse: function() {
		cc.log("cc.IntervalAction: reverse not implemented.");
		return null
	},
	setAmplitudeRate: function(a) {
		cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
	},
	getAmplitudeRate: function() {
		cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
		return 0
	},
	speed: function(a) {
		if (0 >= a) return cc.log("The speed parameter error"), this;
		this._speedMethod = !0;
		this._speed *= a;
		return this
	},
	getSpeed: function() {
		return this._speed
	},
	setSpeed: function(a) {
		this._speed = a;
		return this
	},
	repeat: function(a) {
		a = Math.round(a);
		if (isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
		this._repeatMethod = !0;
		this._timesForRepeat *= a;
		return this
	},
	repeatForever: function() {
		this._repeatMethod = !0;
		this._timesForRepeat = this.MAX_VALUE;
		this._repeatForever = !0;
		return this
	}
});
cc.actionInterval = function(a) {
	return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
	_actions: null,
	_split: null,
	_last: 0,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._actions = [];
		var b = a instanceof Array ? a : arguments,
			c = b.length - 1;
		0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
		if (0 <= c) {
			for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Sequence._actionOneTwo(d, b[e]));
			this.initWithTwoActions(d, b[c])
		}
	},
	initWithTwoActions: function(a, b) {
		if (!a || !b) throw Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
		this.initWithDuration(a._duration + b._duration);
		this._actions[0] = a;
		this._actions[1] = b;
		return !0
	},
	clone: function() {
		var a = new cc.Sequence;
		this._cloneDecoration(a);
		a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._split = this._actions[0]._duration / this._duration;
		this._last = -1
	},
	stop: function() {
		-1 !== this._last && this._actions[this._last].stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		var b = 0,
			c = this._split,
			d = this._actions,
			e = this._last;
		a = this._computeEaseTime(a);
		a < c ? (a = 0 !== c ? a / c : 1, 0 === b && 1 === e && (d[1].update(0), d[1].stop())) : (b = 1, a = 1 === c ? 1 : (a - c) / (1 - c), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()), e || (d[0].update(1), d[0].stop()));
		d = d[b];
		e === b && d.isDone() || (e !== b && d.startWithTarget(this.target), a *= d._timesForRepeat, d.update(1 < a ? a % 1 : a), this._last = b)
	},
	reverse: function() {
		var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.sequence = function(a) {
	var b = a instanceof Array ? a : arguments;
	0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for (var c, d, e, f; b && 0 < b.length;) {
		d = Array.prototype.shift.call(b);
		f = d._timesForRepeat || 1;
		d._repeatMethod = !1;
		d._timesForRepeat = 1;
		e = 0;
		c || (c = d, e = 1);
		for (e; e < f; e++) c = cc.Sequence._actionOneTwo(c, d)
	}
	return c
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, b) {
	var c = new cc.Sequence;
	c.initWithTwoActions(a, b);
	return c
};
cc.Repeat = cc.ActionInterval.extend({
	_times: 0,
	_total: 0,
	_nextDt: 0,
	_actionInstant: !1,
	_innerAction: null,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithAction(a, b)
	},
	initWithAction: function(a, b) {
		return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
	},
	clone: function() {
		var a = new cc.Repeat;
		this._cloneDecoration(a);
		a.initWithAction(this._innerAction.clone(), this._times);
		return a
	},
	startWithTarget: function(a) {
		this._total = 0;
		this._nextDt = this._innerAction._duration / this._duration;
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._innerAction.startWithTarget(a)
	},
	stop: function() {
		this._innerAction.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var b = this._innerAction,
			c = this._duration,
			d = this._times,
			e = this._nextDt;
		if (a >= e) {
			for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target), this._nextDt = e += b._duration / c;
			1 <= a && this._total < d && this._total++;
			this._actionInstant || (this._total === d ? (b.update(1), b.stop()) : b.update(a - (e - b._duration / c)))
		} else b.update(a * d % 1)
	},
	isDone: function() {
		return this._total === this._times
	},
	reverse: function() {
		var a = new cc.Repeat(this._innerAction.reverse(), this._times);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeat = function(a, b) {
	return new cc.Repeat(a, b)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
	_innerAction: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._innerAction = null;
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if (!a) throw Error("cc.RepeatForever.initWithAction(): action must be non null");
		this._innerAction = a;
		return !0
	},
	clone: function() {
		var a = new cc.RepeatForever;
		this._cloneDecoration(a);
		a.initWithAction(this._innerAction.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._innerAction.startWithTarget(a)
	},
	step: function(a) {
		var b = this._innerAction;
		b.step(a);
		b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
	},
	isDone: function() {
		return !1
	},
	reverse: function() {
		var a = new cc.RepeatForever(this._innerAction.reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	setInnerAction: function(a) {
		this._innerAction !== a && (this._innerAction = a)
	},
	getInnerAction: function() {
		return this._innerAction
	}
});
cc.repeatForever = function(a) {
	return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
	_one: null,
	_two: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._two = this._one = null;
		var b = a instanceof Array ? a : arguments,
			c = b.length - 1;
		0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
		if (0 <= c) {
			for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
			this.initWithTwoActions(d, b[c])
		}
	},
	initWithTwoActions: function(a, b) {
		if (!a || !b) throw Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
		var c = !1,
			d = a._duration,
			e = b._duration;
		this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(d - e)) : d < e && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), c = !0);
		return c
	},
	clone: function() {
		var a = new cc.Spawn;
		this._cloneDecoration(a);
		a.initWithTwoActions(this._one.clone(), this._two.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._one.startWithTarget(a);
		this._two.startWithTarget(a)
	},
	stop: function() {
		this._one.stop();
		this._two.stop();
		cc.Action.prototype.stop.call(this)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._one && this._one.update(a);
		this._two && this._two.update(a)
	},
	reverse: function() {
		var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.spawn = function(a) {
	var b = a instanceof Array ? a : arguments;
	0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = cc.Spawn._actionOneTwo(c, b[d]));
	return c
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, b) {
	var c = new cc.Spawn;
	c.initWithTwoActions(a, b);
	return c
};
cc.RotateTo = cc.ActionInterval.extend({
	_dstAngleX: 0,
	_startAngleX: 0,
	_diffAngleX: 0,
	_dstAngleY: 0,
	_startAngleY: 0,
	_diffAngleY: 0,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
	},
	clone: function() {
		var a = new cc.RotateTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var b = a.rotationX % 360,
			c = this._dstAngleX - b;
		180 < c && (c -= 360); - 180 > c && (c += 360);
		this._startAngleX = b;
		this._diffAngleX = c;
		this._startAngleY = a.rotationY % 360;
		a = this._dstAngleY - this._startAngleY;
		180 < a && (a -= 360); - 180 > a && (a += 360);
		this._diffAngleY = a
	},
	reverse: function() {
		cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
	}
});
cc.rotateTo = function(a, b, c) {
	return new cc.RotateTo(a, b, c)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
	_angleX: 0,
	_startAngleX: 0,
	_angleY: 0,
	_startAngleY: 0,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
	},
	clone: function() {
		var a = new cc.RotateBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._angleX, this._angleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._startAngleX = a.rotationX;
		this._startAngleY = a.rotationY
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
	},
	reverse: function() {
		var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.rotateBy = function(a, b, c) {
	return new cc.RotateBy(a, b, c)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
	_positionDelta: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._positionDelta = cc.p(0, 0);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (c = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = c, !0) : !1
	},
	clone: function() {
		var a = new cc.MoveBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._positionDelta);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var b = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = b;
		this._previousPosition.y = a;
		this._startPosition.x = b;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if (this.target) {
			var b = this._positionDelta.x * a;
			a *= this._positionDelta.y;
			var c = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var d = this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				c.x = c.x + d - f.x;
				c.y = c.y + e - f.y;
				b += c.x;
				a += c.y;
				f.x = b;
				f.y = a;
				this.target.setPosition(b, a)
			} else this.target.setPosition(c.x + b, c.y + a)
		}
	},
	reverse: function() {
		var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.moveBy = function(a, b, c) {
	return new cc.MoveBy(a, b, c)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
	_endPosition: null,
	ctor: function(a, b, c) {
		cc.MoveBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.MoveBy.prototype.initWithDuration.call(this, a, b, c) ? (void 0 !== b.x && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
	},
	clone: function() {
		var a = new cc.MoveTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endPosition);
		return a
	},
	startWithTarget: function(a) {
		cc.MoveBy.prototype.startWithTarget.call(this, a);
		this._positionDelta.x = this._endPosition.x - a.getPositionX();
		this._positionDelta.y = this._endPosition.y - a.getPositionY()
	}
});
cc.moveTo = function(a, b, c) {
	return new cc.MoveTo(a, b, c)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
	_skewX: 0,
	_skewY: 0,
	_startSkewX: 0,
	_startSkewY: 0,
	_endSkewX: 0,
	_endSkewY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		var d = !1;
		cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0);
		return d
	},
	clone: function() {
		var a = new cc.SkewTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._startSkewX = a.skewX % 180;
		this._deltaX = this._endSkewX - this._startSkewX;
		180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
		this._startSkewY = a.skewY % 360;
		this._deltaY = this._endSkewY - this._startSkewY;
		180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target.skewX = this._startSkewX + this._deltaX * a;
		this.target.skewY = this._startSkewY + this._deltaY * a
	}
});
cc.skewTo = function(a, b, c) {
	return new cc.SkewTo(a, b, c)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
	ctor: function(a, b, c) {
		cc.SkewTo.prototype.ctor.call(this);
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		var d = !1;
		cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0);
		return d
	},
	clone: function() {
		var a = new cc.SkewBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._skewX, this._skewY);
		return a
	},
	startWithTarget: function(a) {
		cc.SkewTo.prototype.startWithTarget.call(this, a);
		this._deltaX = this._skewX;
		this._deltaY = this._skewY;
		this._endSkewX = this._startSkewX + this._deltaX;
		this._endSkewY = this._startSkewY + this._deltaY
	},
	reverse: function() {
		var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.skewBy = function(a, b, c) {
	return new cc.SkewBy(a, b, c)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
	_startPosition: null,
	_delta: null,
	_height: 0,
	_jumps: 0,
	_previousPosition: null,
	ctor: function(a, b, c, d, e) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		this._delta = cc.p(0, 0);
		void 0 !== d && this.initWithDuration(a, b, c, d, e)
	},
	initWithDuration: function(a, b, c, d, e) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = c, c = b.y, b = b.x), this._delta.x = b, this._delta.y = c, this._height = d, this._jumps = e, !0) : !1
	},
	clone: function() {
		var a = new cc.JumpBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var b = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = b;
		this._previousPosition.y = a;
		this._startPosition.x = b;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if (this.target) {
			var b = a * this._jumps % 1,
				b = 4 * this._height * b * (1 - b),
				b = b + this._delta.y * a;
			a *= this._delta.x;
			var c = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var d = this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				c.x = c.x + d - f.x;
				c.y = c.y + e - f.y;
				a += c.x;
				b += c.y;
				f.x = a;
				f.y = b;
				this.target.setPosition(a, b)
			} else this.target.setPosition(c.x + a, c.y + b)
		}
	},
	reverse: function() {
		var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.jumpBy = function(a, b, c, d, e) {
	return new cc.JumpBy(a, b, c, d, e)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
	_endPosition: null,
	ctor: function(a, b, c, d, e) {
		cc.JumpBy.prototype.ctor.call(this);
		this._endPosition = cc.p(0, 0);
		void 0 !== d && this.initWithDuration(a, b, c, d, e)
	},
	initWithDuration: function(a, b, c, d, e) {
		return cc.JumpBy.prototype.initWithDuration.call(this, a, b, c, d, e) ? (void 0 === e && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
	},
	startWithTarget: function(a) {
		cc.JumpBy.prototype.startWithTarget.call(this, a);
		this._delta.x = this._endPosition.x - this._startPosition.x;
		this._delta.y = this._endPosition.y - this._startPosition.y
	},
	clone: function() {
		var a = new cc.JumpTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
		return a
	}
});
cc.jumpTo = function(a, b, c, d, e) {
	return new cc.JumpTo(a, b, c, d, e)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, b, c, d, e) {
	return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({
	_config: null,
	_startPosition: null,
	_previousPosition: null,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._config = [];
		this._startPosition = cc.p(0, 0);
		this._previousPosition = cc.p(0, 0);
		b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
	},
	clone: function() {
		var a = new cc.BezierBy;
		this._cloneDecoration(a);
		for (var b = [], c = 0; c < this._config.length; c++) {
			var d = this._config[c];
			b.push(cc.p(d.x, d.y))
		}
		a.initWithDuration(this._duration, b);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		var b = a.getPositionX();
		a = a.getPositionY();
		this._previousPosition.x = b;
		this._previousPosition.y = a;
		this._startPosition.x = b;
		this._startPosition.y = a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if (this.target) {
			var b = this._config,
				c = b[0].y,
				d = b[1].y,
				e = b[2].y,
				b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
			a = cc.bezierAt(0, c, d, e, a);
			c = this._startPosition;
			if (cc.ENABLE_STACKABLE_ACTIONS) {
				var d = this.target.getPositionX(),
					e = this.target.getPositionY(),
					f = this._previousPosition;
				c.x = c.x + d - f.x;
				c.y = c.y + e - f.y;
				b += c.x;
				a += c.y;
				f.x = b;
				f.y = a;
				this.target.setPosition(b, a)
			} else this.target.setPosition(c.x + b, c.y + a)
		}
	},
	reverse: function() {
		var a = this._config,
			a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
			a = new cc.BezierBy(this._duration, a);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.bezierBy = function(a, b) {
	return new cc.BezierBy(a, b)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
	_toConfig: null,
	ctor: function(a, b) {
		cc.BezierBy.prototype.ctor.call(this);
		this._toConfig = [];
		b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
	},
	clone: function() {
		var a = new cc.BezierTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toConfig);
		return a
	},
	startWithTarget: function(a) {
		cc.BezierBy.prototype.startWithTarget.call(this, a);
		a = this._startPosition;
		var b = this._toConfig,
			c = this._config;
		c[0] = cc.pSub(b[0], a);
		c[1] = cc.pSub(b[1], a);
		c[2] = cc.pSub(b[2], a)
	}
});
cc.bezierTo = function(a, b) {
	return new cc.BezierTo(a, b)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
	_scaleX: 1,
	_scaleY: 1,
	_startScaleX: 1,
	_startScaleY: 1,
	_endScaleX: 0,
	_endScaleY: 0,
	_deltaX: 0,
	_deltaY: 0,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
	},
	clone: function() {
		var a = new cc.ScaleTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._startScaleX = a.scaleX;
		this._startScaleY = a.scaleY;
		this._deltaX = this._endScaleX - this._startScaleX;
		this._deltaY = this._endScaleY - this._startScaleY
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
	}
});
cc.scaleTo = function(a, b, c) {
	return new cc.ScaleTo(a, b, c)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
	startWithTarget: function(a) {
		cc.ScaleTo.prototype.startWithTarget.call(this, a);
		this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
		this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
	},
	reverse: function() {
		var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.ScaleBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
		return a
	}
});
cc.scaleBy = function(a, b, c) {
	return new cc.ScaleBy(a, b, c)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
	_times: 0,
	_originalState: !1,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
	},
	clone: function() {
		var a = new cc.Blink;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._times);
		return a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		if (this.target && !this.isDone()) {
			var b = 1 / this._times;
			this.target.visible = a % b > b / 2
		}
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._originalState = a.visible
	},
	stop: function() {
		this.target.visible = this._originalState;
		cc.ActionInterval.prototype.stop.call(this)
	},
	reverse: function() {
		var a = new cc.Blink(this._duration, this._times);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.blink = function(a, b) {
	return new cc.Blink(a, b)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
	_toOpacity: 0,
	_fromOpacity: 0,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
	},
	clone: function() {
		var a = new cc.FadeTo;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var b = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
		this.target.opacity = b + (this._toOpacity - b) * a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._fromOpacity = a.opacity
	}
});
cc.fadeTo = function(a, b) {
	return new cc.FadeTo(a, b)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
	_reverseAction: null,
	ctor: function(a) {
		cc.FadeTo.prototype.ctor.call(this);
		null == a && (a = 0);
		this.initWithDuration(a, 255)
	},
	reverse: function() {
		var a = new cc.FadeOut;
		a.initWithDuration(this._duration, 0);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.FadeIn;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	},
	startWithTarget: function(a) {
		this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
		cc.FadeTo.prototype.startWithTarget.call(this, a)
	}
});
cc.fadeIn = function(a) {
	return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
	ctor: function(a) {
		cc.FadeTo.prototype.ctor.call(this);
		null == a && (a = 0);
		this.initWithDuration(a, 0)
	},
	reverse: function() {
		var a = new cc.FadeIn;
		a._reverseAction = this;
		a.initWithDuration(this._duration, 255);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.FadeOut;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._toOpacity);
		return a
	}
});
cc.fadeOut = function(a) {
	return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
	_to: null,
	_from: null,
	ctor: function(a, b, c, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._to = cc.color(0, 0, 0);
		this._from = cc.color(0, 0, 0);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
	},
	clone: function() {
		var a = new cc.TintTo;
		this._cloneDecoration(a);
		var b = this._to;
		a.initWithDuration(this._duration, b.r, b.g, b.b);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._from = this.target.color
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var b = this._from,
			c = this._to;
		b && this.target.setColor(cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
	}
});
cc.tintTo = function(a, b, c, d) {
	return new cc.TintTo(a, b, c, d)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
	_deltaR: 0,
	_deltaG: 0,
	_deltaB: 0,
	_fromR: 0,
	_fromG: 0,
	_fromB: 0,
	ctor: function(a, b, c, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
	},
	clone: function() {
		var a = new cc.TintBy;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		a = a.color;
		this._fromR = a.r;
		this._fromG = a.g;
		this._fromB = a.b
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
	},
	reverse: function() {
		var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	}
});
cc.tintBy = function(a, b, c, d) {
	return new cc.TintBy(a, b, c, d)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
	update: function(a) {},
	reverse: function() {
		var a = new cc.DelayTime(this._duration);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	clone: function() {
		var a = new cc.DelayTime;
		this._cloneDecoration(a);
		a.initWithDuration(this._duration);
		return a
	}
});
cc.delayTime = function(a) {
	return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
	_other: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._other = null;
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if (!a) throw Error("cc.ReverseTime.initWithAction(): action must be non null");
		if (a === this._other) throw Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
		return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
	},
	clone: function() {
		var a = new cc.ReverseTime;
		this._cloneDecoration(a);
		a.initWithAction(this._other.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._other.startWithTarget(a)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._other && this._other.update(1 - a)
	},
	reverse: function() {
		return this._other.clone()
	},
	stop: function() {
		this._other.stop();
		cc.Action.prototype.stop.call(this)
	}
});
cc.reverseTime = function(a) {
	return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
	_animation: null,
	_nextFrame: 0,
	_origFrame: null,
	_executedLoops: 0,
	_splitTimes: null,
	_currFrameIndex: 0,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._splitTimes = [];
		a && this.initWithAnimation(a)
	},
	getAnimation: function() {
		return this._animation
	},
	setAnimation: function(a) {
		this._animation = a
	},
	getCurrentFrameIndex: function() {
		return this._currFrameIndex
	},
	initWithAnimation: function(a) {
		if (!a) throw Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
		var b = a.getDuration();
		if (this.initWithDuration(b * a.getLoops())) {
			this._nextFrame = 0;
			this.setAnimation(a);
			this._origFrame = null;
			this._executedLoops = 0;
			var c = this._splitTimes,
				d = c.length = 0,
				e = b / a.getTotalDelayUnits();
			a = a.getFrames();
			cc.arrayVerifyType(a, cc.AnimationFrame);
			for (var f = 0; f < a.length; f++) {
				var k = d * e / b,
					d = d + a[f].getDelayUnits();
				c.push(k)
			}
			return !0
		}
		return !1
	},
	clone: function() {
		var a = new cc.Animate;
		this._cloneDecoration(a);
		a.initWithAnimation(this._animation.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame());
		this._executedLoops = this._nextFrame = 0
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
		for (var b = this._animation.getFrames(), c = b.length, d = this._splitTimes, e = this._nextFrame; e < c; e++)
		if (d[e] <= a) _currFrameIndex = e, this.target.setSpriteFrame(b[_currFrameIndex].getSpriteFrame()), this._nextFrame = e + 1;
		else break
	},
	reverse: function() {
		var a = this._animation,
			b = a.getFrames(),
			c = [];
		cc.arrayVerifyType(b, cc.AnimationFrame);
		if (0 < b.length) for (var d = b.length - 1; 0 <= d; d--) {
			var e = b[d];
			if (!e) break;
			c.push(e.clone())
		}
		b = new cc.Animation(c, a.getDelayPerUnit(), a.getLoops());
		b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
		a = new cc.Animate(b);
		this._cloneDecoration(a);
		this._reverseEaseList(a);
		return a
	},
	stop: function() {
		this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
		cc.Action.prototype.stop.call(this)
	}
});
cc.animate = function(a) {
	return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
	_action: null,
	_forcedTarget: null,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		b && this.initWithTarget(a, b)
	},
	initWithTarget: function(a, b) {
		return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
	},
	clone: function() {
		var a = new cc.TargetedAction;
		this._cloneDecoration(a);
		a.initWithTarget(this._forcedTarget, this._action.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._action.startWithTarget(this._forcedTarget)
	},
	stop: function() {
		this._action.stop()
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		this._action.update(a)
	},
	getForcedTarget: function() {
		return this._forcedTarget
	},
	setForcedTarget: function(a) {
		this._forcedTarget !== a && (this._forcedTarget = a)
	}
});
cc.targetedAction = function(a, b) {
	return new cc.TargetedAction(a, b)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
	isDone: function() {
		return !0
	},
	step: function(a) {
		this.update(1)
	},
	update: function(a) {},
	reverse: function() {
		return this.clone()
	},
	clone: function() {
		return new cc.ActionInstant
	}
});
cc.Show = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !0
	},
	reverse: function() {
		return new cc.Hide
	},
	clone: function() {
		return new cc.Show
	}
});
cc.show = function() {
	return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !1
	},
	reverse: function() {
		return new cc.Show
	},
	clone: function() {
		return new cc.Hide
	}
});
cc.hide = function() {
	return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
	update: function(a) {
		this.target.visible = !this.target.visible
	},
	reverse: function() {
		return new cc.ToggleVisibility
	},
	clone: function() {
		return new cc.ToggleVisibility
	}
});
cc.toggleVisibility = function() {
	return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
	_isNeedCleanUp: !0,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && this.init(a)
	},
	update: function(a) {
		this.target.removeFromParent(this._isNeedCleanUp)
	},
	init: function(a) {
		this._isNeedCleanUp = a;
		return !0
	},
	reverse: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	},
	clone: function() {
		return new cc.RemoveSelf(this._isNeedCleanUp)
	}
});
cc.removeSelf = function(a) {
	return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
	_flippedX: !1,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedX = !1;
		void 0 !== a && this.initWithFlipX(a)
	},
	initWithFlipX: function(a) {
		this._flippedX = a;
		return !0
	},
	update: function(a) {
		this.target.flippedX = this._flippedX
	},
	reverse: function() {
		return new cc.FlipX(!this._flippedX)
	},
	clone: function() {
		var a = new cc.FlipX;
		a.initWithFlipX(this._flippedX);
		return a
	}
});
cc.flipX = function(a) {
	return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
	_flippedY: !1,
	ctor: function(a) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._flippedY = !1;
		void 0 !== a && this.initWithFlipY(a)
	},
	initWithFlipY: function(a) {
		this._flippedY = a;
		return !0
	},
	update: function(a) {
		this.target.flippedY = this._flippedY
	},
	reverse: function() {
		return new cc.FlipY(!this._flippedY)
	},
	clone: function() {
		var a = new cc.FlipY;
		a.initWithFlipY(this._flippedY);
		return a
	}
});
cc.flipY = function(a) {
	return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
	_x: 0,
	_y: 0,
	ctor: function(a, b) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		this._y = this._x = 0;
		void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
	},
	initWithPosition: function(a, b) {
		this._x = a;
		this._y = b;
		return !0
	},
	update: function(a) {
		this.target.setPosition(this._x, this._y)
	},
	clone: function() {
		var a = new cc.Place;
		a.initWithPosition(this._x, this._y);
		return a
	}
});
cc.place = function(a, b) {
	return new cc.Place(a, b)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
	_selectorTarget: null,
	_callFunc: null,
	_function: null,
	_data: null,
	ctor: function(a, b, c) {
		cc.FiniteTimeAction.prototype.ctor.call(this);
		void 0 !== a && (void 0 === b ? this.initWithFunction(a) : this.initWithFunction(a, b, c))
	},
	initWithFunction: function(a, b, c) {
		b ? (this._data = c, this._callFunc = a, this._selectorTarget = b) : a && (this._function = a);
		return !0
	},
	execute: function() {
		null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
	},
	update: function(a) {
		this.execute()
	},
	getTargetCallback: function() {
		return this._selectorTarget
	},
	setTargetCallback: function(a) {
		a !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
	},
	clone: function() {
		var a = new cc.CallFunc;
		this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
		return a
	}
});
cc.callFunc = function(a, b, c) {
	return new cc.CallFunc(a, b, c)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
	_centerXOrig: 0,
	_centerYOrig: 0,
	_centerZOrig: 0,
	_eyeXOrig: 0,
	_eyeYOrig: 0,
	_eyeZOrig: 0,
	_upXOrig: 0,
	_upYOrig: 0,
	_upZOrig: 0,
	ctor: function() {
		cc.ActionInterval.prototype.ctor.call(this);
		this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		a = a.getCamera();
		var b = a.getCenter();
		this._centerXOrig = b.x;
		this._centerYOrig = b.y;
		this._centerZOrig = b.z;
		b = a.getEye();
		this._eyeXOrig = b.x;
		this._eyeYOrig = b.y;
		this._eyeZOrig = b.z;
		a = a.getUp();
		this._upXOrig = a.x;
		this._upYOrig = a.y;
		this._upZOrig = a.z
	},
	clone: function() {
		return new cc.ActionCamera
	},
	reverse: function() {
		return new cc.ReverseTime(this)
	}
});
cc.OrbitCamera = cc.ActionCamera.extend({
	_radius: 0,
	_deltaRadius: 0,
	_angleZ: 0,
	_deltaAngleZ: 0,
	_angleX: 0,
	_deltaAngleX: 0,
	_radZ: 0,
	_radDeltaZ: 0,
	_radX: 0,
	_radDeltaX: 0,
	ctor: function(a, b, c, d, e, f, k) {
		cc.ActionCamera.prototype.ctor.call(this);
		void 0 !== k && this.initWithDuration(a, b, c, d, e, f, k)
	},
	initWithDuration: function(a, b, c, d, e, f, k) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = c, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = k, this._radDeltaZ = cc.degreesToRadians(e), this._radDeltaX = cc.degreesToRadians(k), !0) : !1
	},
	sphericalRadius: function() {
		var a, b;
		b = this.target.getCamera();
		var c = b.getEye();
		a = b.getCenter();
		b = c.x - a.x;
		var d = c.y - a.y;
		a = c.z - a.z;
		var c = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
			e = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2));
		0 === e && (e = cc.FLT_EPSILON);
		0 === c && (c = cc.FLT_EPSILON);
		a = Math.acos(a / c);
		b = 0 > b ? Math.PI - Math.asin(d / e) : Math.asin(d / e);
		return {
			newRadius: c / cc.Camera.getZEye(),
			zenith: a,
			azimuth: b
		}
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		a = this.sphericalRadius();
		isNaN(this._radius) && (this._radius = a.newRadius);
		isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
		isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
		this._radZ = cc.degreesToRadians(this._angleZ);
		this._radX = cc.degreesToRadians(this._angleX)
	},
	clone: function() {
		var a = new cc.OrbitCamera;
		a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
		return a
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
			c = this._radZ + this._radDeltaZ * a,
			d = this._radX + this._radDeltaX * a;
		a = Math.sin(c) * Math.cos(d) * b + this._centerXOrig;
		d = Math.sin(c) * Math.sin(d) * b + this._centerYOrig;
		b = Math.cos(c) * b + this._centerZOrig;
		this.target.getCamera().setEye(a, d, b);
		this.target.setNodeDirty()
	}
});
cc.orbitCamera = function(a, b, c, d, e, f, k) {
	return new cc.OrbitCamera(a, b, c, d, e, f, k)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
	_inner: null,
	ctor: function(a) {
		cc.ActionInterval.prototype.ctor.call(this);
		a && this.initWithAction(a)
	},
	initWithAction: function(a) {
		if (!a) throw Error("cc.ActionEase.initWithAction(): action must be non nil");
		return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
	},
	clone: function() {
		var a = new cc.ActionEase;
		a.initWithAction(this._inner.clone());
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._inner.startWithTarget(this.target)
	},
	stop: function() {
		this._inner.stop();
		cc.ActionInterval.prototype.stop.call(this)
	},
	update: function(a) {
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.ActionEase(this._inner.reverse())
	},
	getInnerAction: function() {
		return this._inner
	}
});
cc.actionEase = function(a) {
	return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
	_rate: 0,
	ctor: function(a, b) {
		cc.ActionEase.prototype.ctor.call(this);
		void 0 !== b && this.initWithAction(a, b)
	},
	setRate: function(a) {
		this._rate = a
	},
	getRate: function() {
		return this._rate
	},
	initWithAction: function(a, b) {
		return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
	},
	clone: function() {
		var a = new cc.EaseRateAction;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	},
	reverse: function() {
		return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate)
	}
});
cc.easeRateAction = function(a, b) {
	return new cc.EaseRateAction(a, b)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
	update: function(a) {
		this._inner.update(Math.pow(a, this._rate))
	},
	reverse: function() {
		return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var a = new cc.EaseIn;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	}
});
cc.EaseIn.create = function(a, b) {
	return new cc.EaseIn(a, b)
};
cc.easeIn = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			return Math.pow(a, this._rate)
		},
		reverse: function() {
			return cc.easeIn(1 / this._rate)
		}
	}
};
cc.EaseOut = cc.EaseRateAction.extend({
	update: function(a) {
		this._inner.update(Math.pow(a, 1 / this._rate))
	},
	reverse: function() {
		return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
	},
	clone: function() {
		var a = new cc.EaseOut;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	}
});
cc.EaseOut.create = function(a, b) {
	return new cc.EaseOut(a, b)
};
cc.easeOut = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			return Math.pow(a, 1 / this._rate)
		},
		reverse: function() {
			return cc.easeOut(1 / this._rate)
		}
	}
};
cc.EaseInOut = cc.EaseRateAction.extend({
	update: function(a) {
		a *= 2;
		1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
	},
	clone: function() {
		var a = new cc.EaseInOut;
		a.initWithAction(this._inner.clone(), this._rate);
		return a
	},
	reverse: function() {
		return new cc.EaseInOut(this._inner.reverse(), this._rate)
	}
});
cc.EaseInOut.create = function(a, b) {
	return new cc.EaseInOut(a, b)
};
cc.easeInOut = function(a) {
	return {
		_rate: a,
		easing: function(a) {
			a *= 2;
			return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
		},
		reverse: function() {
			return cc.easeInOut(this._rate)
		}
	}
};
cc.EaseExponentialIn = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
	},
	reverse: function() {
		return new cc.EaseExponentialOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialIn.create = function(a) {
	return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
	easing: function(a) {
		return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
	},
	reverse: function() {
		return cc._easeExponentialOutObj
	}
};
cc.easeExponentialIn = function() {
	return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(1 === a ? 1 : -Math.pow(2, -10 * a) + 1)
	},
	reverse: function() {
		return new cc.EaseExponentialIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialOut.create = function(a) {
	return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
	easing: function(a) {
		return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
	},
	reverse: function() {
		return cc._easeExponentialInObj
	}
};
cc.easeExponentialOut = function() {
	return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
	update: function(a) {
		1 !== a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseExponentialInOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseExponentialInOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseExponentialInOut.create = function(a) {
	return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
	easing: function(a) {
		return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
	},
	reverse: function() {
		return cc._easeExponentialInOutObj
	}
};
cc.easeExponentialInOut = function() {
	return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseSineOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseSineIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseSineIn.create = function(a) {
	return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
	},
	reverse: function() {
		return cc._easeSineOutObj
	}
};
cc.easeSineIn = function() {
	return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseSineIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseSineOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseSineOut.create = function(a) {
	return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2)
	},
	reverse: function() {
		return cc._easeSineInObj
	}
};
cc.easeSineOut = function() {
	return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
	update: function(a) {
		a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
		this._inner.update(a)
	},
	clone: function() {
		var a = new cc.EaseSineInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseSineInOut(this._inner.reverse())
	}
});
cc.EaseSineInOut.create = function(a) {
	return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
	},
	reverse: function() {
		return cc._easeSineInOutObj
	}
};
cc.easeSineInOut = function() {
	return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
	_period: 0.3,
	ctor: function(a, b) {
		cc.ActionEase.prototype.ctor.call(this);
		a && this.initWithAction(a, b)
	},
	getPeriod: function() {
		return this._period
	},
	setPeriod: function(a) {
		this._period = a
	},
	initWithAction: function(a, b) {
		cc.ActionEase.prototype.initWithAction.call(this, a);
		this._period = null == b ? 0.3 : b;
		return !0
	},
	reverse: function() {
		cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
		return null
	},
	clone: function() {
		var a = new cc.EaseElastic;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElastic.create = function(a, b) {
	return new cc.EaseElastic(a, b)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
	update: function(a) {
		var b = 0;
		0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period));
		this._inner.update(b)
	},
	reverse: function() {
		return new cc.EaseElasticOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticIn;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticIn.create = function(a, b) {
	return new cc.EaseElasticIn(a, b)
};
cc._easeElasticInObj = {
	easing: function(a) {
		if (0 === a || 1 === a) return a;
		a -= 1;
		return -Math.pow(2, 10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3)
	},
	reverse: function() {
		return cc._easeElasticOutObj
	}
};
cc.easeElasticIn = function(a) {
	return a && 0.3 !== a ? {
		_period: a,
		easing: function(a) {
			if (0 === a || 1 === a) return a;
			a -= 1;
			return -Math.pow(2, 10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period)
		},
		reverse: function() {
			return cc.easeElasticOut(this._period)
		}
	} : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
	update: function(a) {
		var b = 0;
		0 === a || 1 === a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period) + 1);
		this._inner.update(b)
	},
	reverse: function() {
		return new cc.EaseElasticIn(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticOut;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticOut.create = function(a, b) {
	return new cc.EaseElasticOut(a, b)
};
cc._easeElasticOutObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3) + 1
	},
	reverse: function() {
		return cc._easeElasticInObj
	}
};
cc.easeElasticOut = function(a) {
	return a && 0.3 !== a ? {
		_period: a,
		easing: function(a) {
			return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period) + 1
		},
		reverse: function() {
			return cc.easeElasticIn(this._period)
		}
	} : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
	update: function(a) {
		var b = 0,
			b = this._period;
		if (0 === a || 1 === a) b = a;
		else {
			b || (b = this._period = 0.3 * 1.5);
			var c = b / 4;
			a = 2 * a - 1;
			b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - c) * Math.PI / b) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - c) * Math.PI / b) + 1
		}
		this._inner.update(b)
	},
	reverse: function() {
		return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
	},
	clone: function() {
		var a = new cc.EaseElasticInOut;
		a.initWithAction(this._inner.clone(), this._period);
		return a
	}
});
cc.EaseElasticInOut.create = function(a, b) {
	return new cc.EaseElasticInOut(a, b)
};
cc.easeElasticInOut = function(a) {
	return {
		_period: a || 0.3,
		easing: function(a) {
			var c = 0,
				c = this._period;
			if (0 === a || 1 === a) c = a;
			else {
				c || (c = this._period = 0.3 * 1.5);
				var d = c / 4;
				a = 2 * a - 1;
				c = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - d) * Math.PI / c) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - d) * Math.PI / c) + 1
			}
			return c
		},
		reverse: function() {
			return cc.easeElasticInOut(this._period)
		}
	}
};
cc.EaseBounce = cc.ActionEase.extend({
	bounceTime: function(a) {
		if (a < 1 / 2.75) return 7.5625 * a * a;
		if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
		if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
		a -= 2.625 / 2.75;
		return 7.5625 * a * a + 0.984375
	},
	clone: function() {
		var a = new cc.EaseBounce;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBounce(this._inner.reverse())
	}
});
cc.EaseBounce.create = function(a) {
	return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
	update: function(a) {
		a = 1 - this.bounceTime(1 - a);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseBounceOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBounceIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBounceIn.create = function(a) {
	return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
	if (a < 1 / 2.75) return 7.5625 * a * a;
	if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
	if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
	a -= 2.625 / 2.75;
	return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
	easing: function(a) {
		return 1 - cc._bounceTime(1 - a)
	},
	reverse: function() {
		return cc._easeBounceOutObj
	}
};
cc.easeBounceIn = function() {
	return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
	update: function(a) {
		a = this.bounceTime(a);
		this._inner.update(a)
	},
	reverse: function() {
		return new cc.EaseBounceIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBounceOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBounceOut.create = function(a) {
	return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
	easing: function(a) {
		return cc._bounceTime(a)
	},
	reverse: function() {
		return cc._easeBounceInObj
	}
};
cc.easeBounceOut = function() {
	return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
	update: function(a) {
		var b = 0,
			b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
		this._inner.update(b)
	},
	clone: function() {
		var a = new cc.EaseBounceInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBounceInOut(this._inner.reverse())
	}
});
cc.EaseBounceInOut.create = function(a) {
	return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
	easing: function(a) {
		return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
	},
	reverse: function() {
		return cc._easeBounceInOutObj
	}
};
cc.easeBounceInOut = function() {
	return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
	update: function(a) {
		this._inner.update(0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158))
	},
	reverse: function() {
		return new cc.EaseBackOut(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBackIn;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBackIn.create = function(a) {
	return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
	easing: function(a) {
		return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
	},
	reverse: function() {
		return cc._easeBackOutObj
	}
};
cc.easeBackIn = function() {
	return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
	update: function(a) {
		a -= 1;
		this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
	},
	reverse: function() {
		return new cc.EaseBackIn(this._inner.reverse())
	},
	clone: function() {
		var a = new cc.EaseBackOut;
		a.initWithAction(this._inner.clone());
		return a
	}
});
cc.EaseBackOut.create = function(a) {
	return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
	easing: function(a) {
		a -= 1;
		return a * a * (2.70158 * a + 1.70158) + 1
	},
	reverse: function() {
		return cc._easeBackInObj
	}
};
cc.easeBackOut = function() {
	return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
	update: function(a) {
		a *= 2;
		1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
	},
	clone: function() {
		var a = new cc.EaseBackInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseBackInOut(this._inner.reverse())
	}
});
cc.EaseBackInOut.create = function(a) {
	return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
	easing: function(a) {
		a *= 2;
		if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
		a -= 2;
		return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
	},
	reverse: function() {
		return cc._easeBackInOutObj
	}
};
cc.easeBackInOut = function() {
	return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
	_p0: null,
	_p1: null,
	_p2: null,
	_p3: null,
	ctor: function(a) {
		cc.ActionEase.prototype.ctor.call(this, a)
	},
	_updateTime: function(a, b, c, d, e) {
		return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
	},
	update: function(a) {
		a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
		this._inner.update(a)
	},
	clone: function() {
		var a = new cc.EaseBezierAction;
		a.initWithAction(this._inner.clone());
		a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
		return a
	},
	reverse: function() {
		var a = new cc.EaseBezierAction(this._inner.reverse());
		a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
		return a
	},
	setBezierParamer: function(a, b, c, d) {
		this._p0 = a || 0;
		this._p1 = b || 0;
		this._p2 = c || 0;
		this._p3 = d || 0
	}
});
cc.EaseBezierAction.create = function(a) {
	return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, b, c, d) {
	return {
		easing: function(e) {
			return cc.EaseBezierAction.prototype._updateTime(a, b, c, d, e)
		},
		reverse: function() {
			return cc.easeBezierAction(d, c, b, a)
		}
	}
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return Math.pow(a, 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionIn(this._inner.reverse())
	}
});
cc.EaseQuadraticActionIn.create = function(a) {
	return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
	easing: cc.EaseQuadraticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionIn
	}
};
cc.easeQuadraticActionIn = function() {
	return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		return -a * (a - 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionOut;
		a.initWithAction();
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionOut.create = function(a) {
	return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
	easing: cc.EaseQuadraticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionOut
	}
};
cc.easeQuadraticActionOut = function() {
	return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		var b = a;
		a *= 2;
		1 > a ? b = 0.5 * a * a : (--a, b = -0.5 * (a * (a - 2) - 1));
		return b
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuadraticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuadraticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuadraticActionInOut.create = function(a) {
	return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
	easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuadraticActionInOut
	}
};
cc.easeQuadraticActionInOut = function() {
	return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionIn(this._inner.reverse())
	}
});
cc.EaseQuarticActionIn.create = function(a) {
	return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
	easing: cc.EaseQuarticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionIn
	}
};
cc.easeQuarticActionIn = function() {
	return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return -(a * a * a * a - 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionOut.create = function(a) {
	return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
	easing: cc.EaseQuarticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionOut
	}
};
cc.easeQuarticActionOut = function() {
	return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if (1 > a) return 0.5 * a * a * a * a;
		a -= 2;
		return -0.5 * (a * a * a * a - 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuarticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuarticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuarticActionInOut.create = function(a) {
	return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
	easing: cc.EaseQuarticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuarticActionInOut
	}
};
cc.easeQuarticActionInOut = function() {
	return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionIn(this._inner.reverse())
	}
});
cc.EaseQuinticActionIn.create = function(a) {
	return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
	easing: cc.EaseQuinticActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionIn
	}
};
cc.easeQuinticActionIn = function() {
	return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return a * a * a * a * a + 1
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionOut.create = function(a) {
	return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
	easing: cc.EaseQuinticActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionOut
	}
};
cc.easeQuinticActionOut = function() {
	return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if (1 > a) return 0.5 * a * a * a * a * a;
		a -= 2;
		return 0.5 * (a * a * a * a * a + 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseQuinticActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseQuinticActionInOut(this._inner.reverse())
	}
});
cc.EaseQuinticActionInOut.create = function(a) {
	return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
	easing: cc.EaseQuinticActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeQuinticActionInOut
	}
};
cc.easeQuinticActionInOut = function() {
	return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return -1 * (Math.sqrt(1 - a * a) - 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionIn(this._inner.reverse())
	}
});
cc.EaseCircleActionIn.create = function(a) {
	return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
	easing: cc.EaseCircleActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionIn
	}
};
cc.easeCircleActionIn = function() {
	return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return Math.sqrt(1 - a * a)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionOut(this._inner.reverse())
	}
});
cc.EaseCircleActionOut.create = function(a) {
	return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
	easing: cc.EaseCircleActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionOut
	}
};
cc.easeCircleActionOut = function() {
	return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
		a -= 2;
		return 0.5 * (Math.sqrt(1 - a * a) + 1)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCircleActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCircleActionInOut(this._inner.reverse())
	}
});
cc.EaseCircleActionInOut.create = function(a) {
	return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
	easing: cc.EaseCircleActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCircleActionInOut
	}
};
cc.easeCircleActionInOut = function() {
	return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
	_updateTime: function(a) {
		return a * a * a
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},

	clone: function() {
		var a = new cc.EaseCubicActionIn;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionIn(this._inner.reverse())
	}
});
cc.EaseCubicActionIn.create = function(a) {
	return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
	easing: cc.EaseCubicActionIn.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionIn
	}
};
cc.easeCubicActionIn = function() {
	return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a -= 1;
		return a * a * a + 1
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCubicActionOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionOut(this._inner.reverse())
	}
});
cc.EaseCubicActionOut.create = function(a) {
	return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
	easing: cc.EaseCubicActionOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionOut
	}
};
cc.easeCubicActionOut = function() {
	return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
	_updateTime: function(a) {
		a *= 2;
		if (1 > a) return 0.5 * a * a * a;
		a -= 2;
		return 0.5 * (a * a * a + 2)
	},
	update: function(a) {
		this._inner.update(this._updateTime(a))
	},
	clone: function() {
		var a = new cc.EaseCubicActionInOut;
		a.initWithAction(this._inner.clone());
		return a
	},
	reverse: function() {
		return new cc.EaseCubicActionInOut(this._inner.reverse())
	}
});
cc.EaseCubicActionInOut.create = function(a) {
	return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
	easing: cc.EaseCubicActionInOut.prototype._updateTime,
	reverse: function() {
		return cc._easeCubicActionInOut
	}
};
cc.easeCubicActionInOut = function() {
	return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, b, c, d, e, f) {
	var k = f * f,
		m = k * f,
		n = (1 - e) / 2;
	e = n * (-m + 2 * k - f);
	var p = n * (-m + k) + (2 * m - 3 * k + 1);
	f = n * (m - 2 * k + f) + (-2 * m + 3 * k);
	k = n * (m - k);
	return cc.p(a.x * e + b.x * p + c.x * f + d.x * k, a.y * e + b.y * p + c.y * f + d.y * k)
};
cc.reverseControlPoints = function(a) {
	for (var b = [], c = a.length - 1; 0 <= c; c--) b.push(cc.p(a[c].x, a[c].y));
	return b
};
cc.cloneControlPoints = function(a) {
	for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
	return b
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(a, b) {
	var c = Math.min(a.length - 1, Math.max(b, 0));
	return a[c]
};
cc.reverseControlPointsInline = function(a) {
	for (var b = a.length, c = 0 | b / 2, d = 0; d < c; ++d) {
		var e = a[d];
		a[d] = a[b - d - 1];
		a[b - d - 1] = e
	}
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
	_points: null,
	_deltaT: 0,
	_tension: 0,
	_previousPosition: null,
	_accumulatedDiff: null,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._points = [];
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		if (!b || 0 === b.length) throw Error("Invalid configuration. It must at least have one control point");
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = c, !0) : !1
	},
	clone: function() {
		var a = new cc.CardinalSplineTo;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._deltaT = 1 / (this._points.length - 1);
		this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
		this._accumulatedDiff = cc.p(0, 0)
	},
	update: function(a) {
		a = this._computeEaseTime(a);
		var b, c = this._points;
		if (1 === a) b = c.length - 1, a = 1;
		else {
			var d = this._deltaT;
			b = 0 | a / d;
			a = (a - d * b) / d
		}
		b = cc.cardinalSplineAt(cc.getControlPointAt(c, b - 1), cc.getControlPointAt(c, b - 0), cc.getControlPointAt(c, b + 1), cc.getControlPointAt(c, b + 2), this._tension, a);
		if (cc.ENABLE_STACKABLE_ACTIONS && (c = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 !== c || 0 !== a)) d = this._accumulatedDiff, c = d.x + c, a = d.y + a, d.x = c, d.y = a, b.x += c, b.y += a;
		this.updatePosition(b)
	},
	reverse: function() {
		var a = cc.reverseControlPoints(this._points);
		return cc.cardinalSplineTo(this._duration, a, this._tension)
	},
	updatePosition: function(a) {
		this.target.setPosition(a);
		this._previousPosition = a
	},
	getPoints: function() {
		return this._points
	},
	setPoints: function(a) {
		this._points = a
	}
});
cc.cardinalSplineTo = function(a, b, c) {
	return new cc.CardinalSplineTo(a, b, c)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
	_startPosition: null,
	ctor: function(a, b, c) {
		cc.CardinalSplineTo.prototype.ctor.call(this);
		this._startPosition = cc.p(0, 0);
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	startWithTarget: function(a) {
		cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
		this._startPosition.x = a.getPositionX();
		this._startPosition.y = a.getPositionY()
	},
	reverse: function() {
		for (var a = this._points.slice(), b, c = a[0], d = 1; d < a.length; ++d) b = a[d], a[d] = cc.pSub(b, c), c = b;
		a = cc.reverseControlPoints(a);
		c = a[a.length - 1];
		a.pop();
		c.x = -c.x;
		c.y = -c.y;
		a.unshift(c);
		for (d = 1; d < a.length; ++d) b = a[d], b.x = -b.x, b.y = -b.y, b.x += c.x, b.y += c.y, c = a[d] = b;
		return cc.cardinalSplineBy(this._duration, a, this._tension)
	},
	updatePosition: function(a) {
		var b = this._startPosition,
			c = a.x + b.x;
		a = a.y + b.y;
		this._previousPosition.x = c;
		this._previousPosition.y = a;
		this.target.setPosition(c, a)
	},
	clone: function() {
		var a = new cc.CardinalSplineBy;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
		return a
	}
});
cc.cardinalSplineBy = function(a, b, c) {
	return new cc.CardinalSplineBy(a, b, c)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
	ctor: function(a, b) {
		b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
	},
	clone: function() {
		var a = new cc.CatmullRomTo;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return a
	}
});
cc.catmullRomTo = function(a, b) {
	return new cc.CatmullRomTo(a, b)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
	ctor: function(a, b) {
		cc.CardinalSplineBy.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
	},
	clone: function() {
		var a = new cc.CatmullRomBy;
		a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
		return a
	}
});
cc.catmullRomBy = function(a, b) {
	return new cc.CatmullRomBy(a, b)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
	updateTweenAction: function(a, b) {}
});
cc.ActionTween = cc.ActionInterval.extend({
	key: "",
	from: 0,
	to: 0,
	delta: 0,
	ctor: function(a, b, c, d) {
		cc.ActionInterval.prototype.ctor.call(this);
		this.key = "";
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
	},
	startWithTarget: function(a) {
		if (!a || !a.updateTweenAction) throw Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this.delta = this.to - this.from
	},
	update: function(a) {
		this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
	},
	reverse: function() {
		return new cc.ActionTween(this.duration, this.key, this.to, this.from)
	},
	clone: function() {
		var a = new cc.ActionTween;
		a.initWithDuration(this._duration, this.key, this.from, this.to);
		return a
	}
});
cc.actionTween = function(a, b, c, d) {
	return new cc.ActionTween(a, b, c, d)
};
cc.ActionTween.create = cc.actionTween;
cc.GridAction = cc.ActionInterval.extend({
	_gridSize: null,
	_gridNodeTarget: null,
	ctor: function(a, b) {
		cc._checkWebGLRenderMode();
		cc.ActionInterval.prototype.ctor.call(this);
		this._gridSize = cc.size(0, 0);
		b && this.initWithDuration(a, b)
	},
	_cacheTargetAsGridNode: function() {},
	clone: function() {
		var a = new cc.GridAction,
			b = this._gridSize;
		a.initWithDuration(this._duration, cc.size(b.width, b.height));
		return a
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		cc.renderer.childrenOrderDirty = !0;
		var b = this.getGrid();
		(a = this._gridNodeTarget.getGrid()) && 0 < a.getReuseGrid() ? (b = a.getGridSize(), a.isActive() && (b.width === this._gridSize.width && b.height === this._gridSize.height) && a.reuse()) : (a && a.isActive() && a.setActive(!1), this._gridNodeTarget.setGrid(b), this._gridNodeTarget.getGrid().setActive(!0))
	},
	reverse: function() {
		return new cc.ReverseTime(this)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
	},
	getGrid: function() {
		cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
	}
});
cc.gridAction = function(a, b) {
	return new cc.GridAction(a, b)
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
	getGrid: function() {
		return new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
	},
	getGridRect: function() {
		return this._gridNodeTarget.getGridRect()
	},
	vertex: function(a) {
		return this.getVertex(a)
	},
	getVertex: function(a) {
		return this.target.grid.getVertex(a)
	},
	originalVertex: function(a) {
		return this.getOriginalVertex(a)
	},
	getOriginalVertex: function(a) {
		return this.target.grid.originalVertex(a)
	},
	setVertex: function(a, b) {
		this.target.grid.setVertex(a, b)
	}
});
cc.grid3DAction = function(a, b) {
	return new cc.Grid3DAction(a, b)
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
	tile: function(a) {
		return this.getTile(a)
	},
	getTile: function(a) {
		return this.target.grid.tile(a)
	},
	originalTile: function(a) {
		return this.getOriginalTile(a)
	},
	getOriginalTile: function(a) {
		return this.target.grid.originalTile(a)
	},
	setTile: function(a, b) {
		this.target.grid.setTile(a, b)
	},
	getGrid: function() {
		return new cc.TiledGrid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
	}
});
cc.tiledGrid3DAction = function(a, b) {
	return new cc.TiledGrid3DAction(a, b)
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
	startWithTarget: function(a) {
		cc.ActionInstant.prototype.startWithTarget.call(this, a);
		cc.renderer.childrenOrderDirty = !0;
		(a = this.target.grid) && a.isActive() && a.setActive(!1)
	}
});
cc.stopGrid = function() {
	return new cc.StopGrid
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
	_times: null,
	ctor: function(a) {
		cc.ActionInstant.prototype.ctor.call(this);
		void 0 !== a && this.initWithTimes(a)
	},
	initWithTimes: function(a) {
		this._times = a;
		return !0
	},
	startWithTarget: function(a) {
		cc.ActionInstant.prototype.startWithTarget.call(this, a);
		cc.renderer.childrenOrderDirty = !0;
		this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
	}
});
cc.reuseGrid = function(a) {
	return new cc.ReuseGrid(a)
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		for (var b = this._gridSize, c = this._amplitude, d = cc.p(0, 0), e = this._amplitudeRate, f = this._waves, k = 0; k < b.width + 1; ++k)
		for (var m = 0; m < b.height + 1; ++m) {
			d.x = k;
			d.y = m;
			var n = this.originalVertex(d);
			n.z += Math.sin(2 * Math.PI * a * f + 0.01 * (n.y + n.x)) * c * e;
			this.setVertex(d, n)
		}
	}
});
cc.waves3D = function(a, b, c, d) {
	return new cc.Waves3D(a, b, c, d)
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
	ctor: function(a) {
		void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
	},
	initWithDuration: function(a) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
	},
	initWithSize: function(a, b) {
		return 1 !== a.width || 1 !== a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
	},
	update: function(a) {
		var b = Math.PI * a;
		a = Math.sin(b);
		var c = Math.cos(b / 2),
			b = new cc.Vertex3F,
			d = cc.p(0, 0);
		d.x = d.y = 1;
		var e = this.originalVertex(d);
		d.x = d.y = 0;
		var d = this.originalVertex(d),
			f = e.x,
			k = d.x,
			m, n;
		f > k ? (e = cc.p(0, 0), d = cc.p(0, 1), m = cc.p(1, 0), n = cc.p(1, 1)) : (m = cc.p(0, 0), n = cc.p(0, 1), e = cc.p(1, 0), d = cc.p(1, 1), f = k);
		b.x = f - f * c;
		b.z = Math.abs(parseFloat(f * a / 4));
		a = this.originalVertex(e);
		a.x = b.x;
		a.z += b.z;
		this.setVertex(e, a);
		a = this.originalVertex(d);
		a.x = b.x;
		a.z += b.z;
		this.setVertex(d, a);
		a = this.originalVertex(m);
		a.x -= b.x;
		a.z -= b.z;
		this.setVertex(m, a);
		a = this.originalVertex(n);
		a.x -= b.x;
		a.z -= b.z;
		this.setVertex(n, a)
	}
});
cc.flipX3D = function(a) {
	return new cc.FlipX3D(a)
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
	ctor: function(a) {
		void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
	},
	update: function(a) {
		var b = Math.PI * a;
		a = Math.sin(b);
		var c = Math.cos(b / 2),
			b = new cc.Vertex3F,
			d = cc.p(0, 0);
		d.x = d.y = 1;
		var e = this.originalVertex(d);
		d.x = d.y = 0;
		var d = this.originalVertex(d),
			f = e.y,
			k = d.y,
			m, n;
		f > k ? (e = cc.p(0, 0), d = cc.p(0, 1), m = cc.p(1, 0), n = cc.p(1, 1)) : (d = cc.p(0, 0), e = cc.p(0, 1), n = cc.p(1, 0), m = cc.p(1, 1), f = k);
		b.y = f - f * c;
		b.z = Math.abs(parseFloat(f * a) / 4);
		a = this.originalVertex(e);
		a.y = b.y;
		a.z += b.z;
		this.setVertex(e, a);
		a = this.originalVertex(d);
		a.y -= b.y;
		a.z -= b.z;
		this.setVertex(d, a);
		a = this.originalVertex(m);
		a.y = b.y;
		a.z += b.z;
		this.setVertex(m, a);
		a = this.originalVertex(n);
		a.y -= b.y;
		a.z -= b.z;
		this.setVertex(n, a)
	}
});
cc.flipY3D = function(a) {
	return new cc.FlipY3D(a)
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
	_position: null,
	_radius: 0,
	_lensEffect: 0,
	_concave: !1,
	_dirty: !1,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	getLensEffect: function() {
		return this._lensEffect
	},
	setLensEffect: function(a) {
		this._lensEffect = a
	},
	setConcave: function(a) {
		this._concave = a
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(a) {
		cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y = a.y, this._dirty = !0)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._lensEffect = 0.7, this._dirty = !0) : !1
	},
	update: function(a) {
		if (this._dirty) {
			a = this._gridSize.width;
			for (var b = this._gridSize.height, c = this._radius, d = this._lensEffect, e = cc.p(0, 0), f = cc.p(0, 0), k, m, n, p = 0; p < a + 1; ++p)
			for (var r = 0; r < b + 1; ++r) e.x = p, e.y = r, k = this.originalVertex(e), f.x = this._position.x - k.x, f.y = this._position.y - k.y, m = cc.pLength(f), m < c && (m = c - m, m /= c, 0 === m && (m = 0.0010), m = Math.log(m) * d, n = Math.exp(m) * c, m = cc.pLength(f), 0 < m && (f.x /= m, f.y /= m, f.x *= n, f.y *= n, k.z += cc.pLength(f) * d)), this.setVertex(e, k);
			this._dirty = !1
		}
	}
});
cc.lens3D = function(a, b, c, d) {
	return new cc.Lens3D(a, b, c, d)
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
	_position: null,
	_radius: 0,
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d, e, f) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(a) {
		this._position.x = a.x;
		this._position.y = a.y
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d, e, f) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._waves = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._radius, f = this._waves, k = this._amplitude, m = this._amplitudeRate, n, p, r = cc.p(0, 0), s = 0; s < b + 1; ++s)
		for (var u = 0; u < c + 1; ++u) {
			d.x = s;
			d.y = u;
			n = this.originalVertex(d);
			r.x = this._position.x - n.x;
			r.y = this._position.y - n.y;
			p = cc.pLength(r);
			if (p < e) {
				p = e - p;
				var t = Math.pow(p / e, 2);
				n.z += Math.sin(2 * a * Math.PI * f + 0.1 * p) * k * m * t
			}
			this.setVertex(d, n)
		}
	}
});
cc.ripple3D = function(a, b, c, d, e, f) {
	return new cc.Ripple3D(a, b, c, d, e, f)
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
	_randRange: 0,
	_shakeZ: !1,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
	},
	update: function(a) {
		a = this._gridSize.width;
		for (var b = this._gridSize.height, c = this._randRange, d = this._shakeZ, e = cc.p(0, 0), f, k = 0; k < a + 1; ++k)
		for (var m = 0; m < b + 1; ++m) e.x = k, e.y = m, f = this.originalVertex(e), f.x += cc.rand() % (2 * c) - c, f.y += cc.rand() % (2 * c) - c, d && (f.z += cc.rand() % (2 * c) - c), this.setVertex(e, f)
	}
});
cc.shaky3D = function(a, b, c, d) {
	return new cc.Shaky3D(a, b, c, d)
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._waves, f = this._amplitude, k = this._amplitudeRate, m, n = 1; n < b; ++n)
		for (var p = 1; p < c; ++p) d.x = n, d.y = p, m = this.originalVertex(d), m.x += Math.sin(2 * a * Math.PI * e + 0.01 * m.x) * f * k, m.y += Math.sin(2 * a * Math.PI * e + 0.01 * m.y) * f * k, this.setVertex(d, m)
	}
});
cc.liquid = function(a, b, c, d) {
	return new cc.Liquid(a, b, c, d)
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	_vertical: !1,
	_horizontal: !1,
	ctor: function(a, b, c, d, e, f) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d, e, f) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, this._horizontal = e, this._vertical = f, !0) : !1
	},
	update: function(a) {
		for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._vertical, f = this._horizontal, k = this._waves, m = this._amplitude, n = this._amplitudeRate, p, r = 0; r < b + 1; ++r)
		for (var s = 0; s < c + 1; ++s) d.x = r, d.y = s, p = this.originalVertex(d), e && (p.x += Math.sin(2 * a * Math.PI * k + 0.01 * p.y) * m * n), f && (p.y += Math.sin(2 * a * Math.PI * k + 0.01 * p.x) * m * n), this.setVertex(d, p)
	}
});
cc.waves = function(a, b, c, d, e, f) {
	return new cc.Waves(a, b, c, d, e, f)
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
	_position: null,
	_twirls: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d, e) {
		cc.GridAction.prototype.ctor.call(this);
		this._position = cc.p(0, 0);
		void 0 !== e && this.initWithDuration(a, b, c, d, e)
	},
	getPosition: function() {
		return this._position
	},
	setPosition: function(a) {
		this._position.x = a.x;
		this._position.y = a.y
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d, e) {
		return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._twirls = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		for (var b = this._position, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = 0.1 * this._amplitude * this._amplitudeRate, k = this._twirls, m, n, p, r = cc.p(0, 0), s = 0; s < c + 1; ++s)
		for (var u = 0; u < d + 1; ++u) e.x = s, e.y = u, m = this.originalVertex(e), r.x = s - c / 2, r.y = u - d / 2, n = cc.pLength(r) * Math.cos(Math.PI / 2 + 2 * a * Math.PI * k) * f, p = Math.sin(n) * (m.y - b.y) + Math.cos(n) * (m.x - b.x), n = Math.cos(n) * (m.y - b.y) - Math.sin(n) * (m.x - b.x), m.x = b.x + p, m.y = b.y + n, this.setVertex(e, m)
	}
});
cc.twirl = function(a, b, c, d, e) {
	return new cc.Twirl(a, b, c, d, e)
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
	_randRange: 0,
	_shakeZ: !1,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
	},
	update: function(a) {
		a = this._gridSize;
		for (var b = this._randRange, c = cc.p(0, 0), d = 0; d < a.width; ++d)
		for (var e = 0; e < a.height; ++e) {
			c.x = d;
			c.y = e;
			var f = this.originalTile(c);
			f.bl.x += cc.rand() % (2 * b) - b;
			f.br.x += cc.rand() % (2 * b) - b;
			f.tl.x += cc.rand() % (2 * b) - b;
			f.tr.x += cc.rand() % (2 * b) - b;
			f.bl.y += cc.rand() % (2 * b) - b;
			f.br.y += cc.rand() % (2 * b) - b;
			f.tl.y += cc.rand() % (2 * b) - b;
			f.tr.y += cc.rand() % (2 * b) - b;
			this._shakeZ && (f.bl.z += cc.rand() % (2 * b) - b, f.br.z += cc.rand() % (2 * b) - b, f.tl.z += cc.rand() % (2 * b) - b, f.tr.z += cc.rand() % (2 * b) - b);
			this.setTile(c, f)
		}
	}
});
cc.shakyTiles3D = function(a, b, c, d) {
	return new cc.ShakyTiles3D(a, b, c, d)
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
	_randRange: 0,
	_once: !1,
	_shatterZ: !1,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	initWithDuration: function(a, b, c, d) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = c, this._shatterZ = d, !0) : !1
	},
	update: function(a) {
		if (!1 === this._once) {
			a = this._gridSize;
			for (var b = this._randRange, c, d = cc.p(0, 0), e = 0; e < a.width; ++e)
			for (var f = 0; f < a.height; ++f) d.x = e, d.y = f, c = this.originalTile(d), c.bl.x += cc.rand() % (2 * b) - b, c.br.x += cc.rand() % (2 * b) - b, c.tl.x += cc.rand() % (2 * b) - b, c.tr.x += cc.rand() % (2 * b) - b, c.bl.y += cc.rand() % (2 * b) - b, c.br.y += cc.rand() % (2 * b) - b, c.tl.y += cc.rand() % (2 * b) - b, c.tr.y += cc.rand() % (2 * b) - b, this._shatterZ && (c.bl.z += cc.rand() % (2 * b) - b, c.br.z += cc.rand() % (2 * b) - b, c.tl.z += cc.rand() % (2 * b) - b, c.tr.z += cc.rand() % (2 * b) - b), this.setTile(d, c);
			this._once = !0
		}
	}
});
cc.shatteredTiles3D = function(a, b, c, d) {
	return new cc.ShatteredTiles3D(a, b, c, d)
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function(a, b, c) {
	this.position = a || cc.p(0, 0);
	this.startPosition = b || cc.p(0, 0);
	this.delta = c || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
	_seed: 0,
	_tilesCount: 0,
	_tilesOrder: null,
	_tiles: null,
	ctor: function(a, b, c) {
		cc.GridAction.prototype.ctor.call(this);
		this._tilesOrder = [];
		this._tiles = [];
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
	},
	shuffle: function(a, b) {
		for (var c = b - 1; 0 <= c; c--) {
			var d = 0 | cc.rand() % (c + 1),
				e = a[c];
			a[c] = a[d];
			a[d] = e
		}
	},
	getDelta: function(a) {
		var b = this._gridSize,
			c = a.width * b.height + a.height;
		return cc.size(this._tilesOrder[c] / b.height - a.width, this._tilesOrder[c] % b.height - a.height)
	},
	placeTile: function(a, b) {
		var c = this.originalTile(a),
			d = this.target.grid.getStep(),
			e = b.position;
		c.bl.x += e.x * d.x;
		c.bl.y += e.y * d.y;
		c.br.x += e.x * d.x;
		c.br.y += e.y * d.y;
		c.tl.x += e.x * d.x;
		c.tl.y += e.y * d.y;
		c.tr.x += e.x * d.x;
		c.tr.y += e.y * d.y;
		this.setTile(a, c)
	},
	startWithTarget: function(a) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
		a = this._gridSize;
		this._tilesCount = a.width * a.height;
		for (var b = this._tilesOrder, c = b.length = 0; c < this._tilesCount; ++c) b[c] = c;
		this.shuffle(b, this._tilesCount);
		for (var b = this._tiles, c = b.length = 0, d = cc.size(0, 0), e = 0; e < a.width; ++e)
		for (var f = 0; f < a.height; ++f) b[c] = new cc.Tile, b[c].position = cc.p(e, f), b[c].startPosition = cc.p(e, f), d.width = e, d.height = f, b[c].delta = this.getDelta(d), ++c
	},
	update: function(a) {
		for (var b = 0, c = this._gridSize, d = this._tiles, e, f = cc.p(0, 0), k = 0; k < c.width; ++k)
		for (var m = 0; m < c.height; ++m) f.x = k, f.y = m, e = d[b], e.position.x = e.delta.width * a, e.position.y = e.delta.height * a, this.placeTile(f, e), ++b
	}
});
cc.shuffleTiles = function(a, b, c) {
	return new cc.ShuffleTiles(a, b, c)
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
	testFunc: function(a, b) {
		var c = this._gridSize.width * b,
			d = this._gridSize.height * b;
		return 0 === c + d ? 1 : Math.pow((a.width + a.height) / (c + d), 6)
	},
	turnOnTile: function(a) {
		this.setTile(a, this.originalTile(a))
	},
	turnOffTile: function(a) {
		this.setTile(a, new cc.Quad3)
	},
	transformTile: function(a, b) {
		var c = this.originalTile(a),
			d = this.target.grid.getStep();
		c.bl.x += d.x / 2 * (1 - b);
		c.bl.y += d.y / 2 * (1 - b);
		c.br.x -= d.x / 2 * (1 - b);
		c.br.y += d.y / 2 * (1 - b);
		c.tl.x += d.x / 2 * (1 - b);
		c.tl.y -= d.y / 2 * (1 - b);
		c.tr.x -= d.x / 2 * (1 - b);
		c.tr.y -= d.y / 2 * (1 - b);
		this.setTile(a, c)
	},
	update: function(a) {
		for (var b = this._gridSize, c = cc.p(0, 0), d = cc.size(0, 0), e, f = 0; f < b.width; ++f)
		for (var k = 0; k < b.height; ++k) c.x = f, c.y = k, d.width = f, d.height = k, e = this.testFunc(d, a), 0 === e ? this.turnOffTile(c) : 1 > e ? this.transformTile(c, e) : this.turnOnTile(c)
	}
});
cc.fadeOutTRTiles = function(a, b) {
	return new cc.FadeOutTRTiles(a, b)
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
	testFunc: function(a, b) {
		return 0 === a.width + a.height ? 1 : Math.pow((this._gridSize.width * (1 - b) + this._gridSize.height * (1 - b)) / (a.width + a.height), 6)
	}
});
cc.fadeOutBLTiles = function(a, b) {
	return new cc.FadeOutBLTiles(a, b)
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
	testFunc: function(a, b) {
		var c = this._gridSize.height * b;
		return 0 === c ? 1 : Math.pow(a.height / c, 6)
	},
	transformTile: function(a, b) {
		var c = this.originalTile(a),
			d = this.target.grid.getStep();
		c.bl.y += d.y / 2 * (1 - b);
		c.br.y += d.y / 2 * (1 - b);
		c.tl.y -= d.y / 2 * (1 - b);
		c.tr.y -= d.y / 2 * (1 - b);
		this.setTile(a, c)
	}
});
cc.fadeOutUpTiles = function(a, b) {
	return new cc.FadeOutUpTiles(a, b)
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
	testFunc: function(a, b) {
		return 0 === a.height ? 1 : Math.pow(this._gridSize.height * (1 - b) / a.height, 6)
	}
});
cc.fadeOutDownTiles = function(a, b) {
	return new cc.FadeOutDownTiles(a, b)
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
	_seed: null,
	_tilesCount: 0,
	_tilesOrder: null,
	ctor: function(a, b, c) {
		cc.GridAction.prototype.ctor.call(this);
		this._tilesOrder = [];
		void 0 !== b && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c || 0, this._tilesOrder.length = 0, !0) : !1
	},
	shuffle: function(a, b) {
		for (var c = b - 1; 0 <= c; c--) {
			var d = 0 | cc.rand() % (c + 1),
				e = a[c];
			a[c] = a[d];
			a[d] = e
		}
	},
	turnOnTile: function(a) {
		this.setTile(a, this.originalTile(a))
	},
	turnOffTile: function(a) {
		this.setTile(a, new cc.Quad3)
	},
	startWithTarget: function(a) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
		this._tilesCount = this._gridSize.width * this._gridSize.height;
		a = this._tilesOrder;
		for (var b = a.length = 0; b < this._tilesCount; ++b) a[b] = b;
		this.shuffle(a, this._tilesCount)
	},
	update: function(a) {
		a = 0 | a * this._tilesCount;
		for (var b = this._gridSize, c, d = cc.p(0, 0), e = this._tilesOrder, f = 0; f < this._tilesCount; f++) c = e[f], d.x = 0 | c / b.height, d.y = c % (0 | b.height), f < a ? this.turnOffTile(d) : this.turnOnTile(d)
	}
});
cc.turnOffTiles = function(a, b, c) {
	return new cc.TurnOffTiles(a, b, c)
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
	_waves: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		for (var b = this._gridSize, c = this._waves, d = this._amplitude, e = this._amplitudeRate, f = cc.p(0, 0), k, m = 0; m < b.width; m++)
		for (var n = 0; n < b.height; n++) f.x = m, f.y = n, k = this.originalTile(f), k.bl.z = Math.sin(2 * a * Math.PI * c + 0.01 * (k.bl.y + k.bl.x)) * d * e, k.br.z = k.bl.z, k.tl.z = k.bl.z, k.tr.z = k.bl.z, this.setTile(f, k)
	}
});
cc.wavesTiles3D = function(a, b, c, d) {
	return new cc.WavesTiles3D(a, b, c, d)
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
	_jumps: 0,
	_amplitude: 0,
	_amplitudeRate: 0,
	ctor: function(a, b, c, d) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== d && this.initWithDuration(a, b, c, d)
	},
	getAmplitude: function() {
		return this._amplitude
	},
	setAmplitude: function(a) {
		this._amplitude = a
	},
	getAmplitudeRate: function() {
		return this._amplitudeRate
	},
	setAmplitudeRate: function(a) {
		this._amplitudeRate = a
	},
	initWithDuration: function(a, b, c, d) {
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
	},
	update: function(a) {
		var b = Math.sin(2 * Math.PI * a * this._jumps) * this._amplitude * this._amplitudeRate;
		a = Math.sin(Math.PI * (2 * a * this._jumps + 1)) * this._amplitude * this._amplitudeRate;
		for (var c = this._gridSize, d = this.target.grid, e, f = cc.p(0, 0), k = 0; k < c.width; k++)
		for (var m = 0; m < c.height; m++) f.x = k, f.y = m, e = d.originalTile(f), 0 === (k + m) % 2 ? (e.bl.z += b, e.br.z += b, e.tl.z += b, e.tr.z += b) : (e.bl.z += a, e.br.z += a, e.tl.z += a, e.tr.z += a), d.setTile(f, e)
	}
});
cc.jumpTiles3D = function(a, b, c, d) {
	return new cc.JumpTiles3D(a, b, c, d)
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
	_rows: 0,
	_winSize: null,
	ctor: function(a, b) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		this._rows = b;
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
	},
	update: function(a) {
		for (var b = this._gridSize, c = this._winSize.width, d, e, f = cc.p(0, 0), k = 0; k < b.height; ++k) f.y = k, d = this.originalTile(f), e = 1, 0 === k % 2 && (e = -1), d.bl.x += e * c * a, d.br.x += e * c * a, d.tl.x += e * c * a, d.tr.x += e * c * a, this.setTile(f, d)
	},
	startWithTarget: function(a) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
		this._winSize = cc.director.getWinSizeInPixels()
	}
});
cc.splitRows = function(a, b) {
	return new cc.SplitRows(a, b)
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
	_cols: 0,
	_winSize: null,

	ctor: function(a, b) {
		cc.GridAction.prototype.ctor.call(this);
		void 0 !== b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		this._cols = b;
		return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
	},
	update: function(a) {
		for (var b = this._gridSize.width, c = this._winSize.height, d, e, f = cc.p(0, 0), k = 0; k < b; ++k) f.x = k, d = this.originalTile(f), e = 1, 0 === k % 2 && (e = -1), d.bl.y += e * c * a, d.br.y += e * c * a, d.tl.y += e * c * a, d.tr.y += e * c * a, this.setTile(f, d);
		cc.renderer.childrenOrderDirty = !0
	},
	startWithTarget: function(a) {
		cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
		this._winSize = cc.director.getWinSizeInPixels()
	}
});
cc.splitCols = function(a, b) {
	return new cc.SplitCols(a, b)
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
	getGrid: function() {
		var a = new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
		a.setNeedDepthTestForBlit(!0);
		return a
	},
	clone: function() {
		var a = new cc.PageTurn3D;
		a.initWithDuration(this._duration, this._gridSize);
		return a
	},
	update: function(a) {
		var b = Math.max(0, a - 0.25),
			b = -100 - 500 * b * b,
			c = Math.sqrt(a),
			d = 0.5 < c ? Math.PI / 2 * c : Math.PI / 2 * (1 - c);
		a = (2 - a) * Math.PI;
		for (var c = Math.sin(d), d = Math.cos(d), e = this._gridSize, f = cc.p(0, 0), k = 0; k <= e.width; ++k)
		for (var m = 0; m <= e.height; ++m) {
			f.x = k;
			f.y = m;
			var n = this.getOriginalVertex(f);
			n.x -= this.getGridRect().x;
			var p = Math.sqrt(n.x * n.x + (n.y - b) * (n.y - b)),
				r = p * c,
				s = Math.asin(n.x / p) / c,
				u = Math.cos(s);
			n.x = s <= Math.PI ? r * Math.sin(s) : 0;
			n.y = p + b - r * (1 - u) * c;
			n.z = r * (1 - u) * d;
			n.x = n.z * Math.sin(a) + n.x * Math.cos(a);
			n.z = n.z * Math.cos(a) - n.x * Math.cos(a);
			n.z /= 7;
			0.5 > n.z && (n.z = 0.5);
			n.x += this.getGridRect().x;
			this.setVertex(f, n)
		}
	}
});
cc.pageTurn3D = function(a, b) {
	return new cc.PageTurn3D(a, b)
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
	_type: null,
	_percentage: 0,
	_sprite: null,
	_midPoint: null,
	_barChangeRate: null,
	_reverseDirection: !1,
	_className: "ProgressTimer",
	ctor: function(a) {
		cc.Node.prototype.ctor.call(this);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._percentage = 0;
		this._midPoint = cc.p(0, 0);
		this._barChangeRate = cc.p(0, 0);
		this._reverseDirection = !1;
		this._sprite = null;
		a && this.initWithSprite(a)
	},
	getMidpoint: function() {
		return cc.p(this._midPoint.x, this._midPoint.y)
	},
	setMidpoint: function(a) {
		this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
	},
	getBarChangeRate: function() {
		return cc.p(this._barChangeRate.x, this._barChangeRate.y)
	},
	setBarChangeRate: function(a) {
		this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
	},
	getType: function() {
		return this._type
	},
	getPercentage: function() {
		return this._percentage
	},
	getSprite: function() {
		return this._sprite
	},
	setPercentage: function(a) {
		this._percentage !== a && (this._percentage = cc.clampf(a, 0, 100), this._renderCmd._updateProgress())
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	isReverseDirection: function() {
		return this._reverseDirection
	},
	setColor: function(a) {
		this._sprite.color = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
	},
	setOpacity: function(a) {
		this._sprite.opacity = a;
		this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
	},
	getColor: function() {
		return this._sprite.color
	},
	getOpacity: function() {
		return this._sprite.opacity
	},
	setReverseProgress: function(a) {
		this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
	},
	setSprite: function(a) {
		this._sprite !== a && ((this._sprite = a) ? this.setContentSize(a.width, a.height) : this.setContentSize(0, 0), this._renderCmd.releaseData())
	},
	setType: function(a) {
		a !== this._type && (this._type = a, this._renderCmd.releaseData())
	},
	setReverseDirection: function(a) {
		this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
	},
	initWithSprite: function(a) {
		this.percentage = 0;
		this.setAnchorPoint(0.5, 0.5);
		this._type = cc.ProgressTimer.TYPE_RADIAL;
		this._reverseDirection = !1;
		this.midPoint = cc.p(0.5, 0.5);
		this.barChangeRate = cc.p(1, 1);
		this.setSprite(a);
		this._renderCmd.initCmd();
		return !0
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
	}
});
_p = cc.ProgressTimer.prototype;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(a) {
	return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(a, b) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== b && this.initWithDuration(a, b)
	},
	initWithDuration: function(a, b) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
	},
	clone: function() {
		var a = new cc.ProgressTo;
		a.initWithDuration(this._duration, this._to);
		return a
	},
	reverse: function() {
		cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
		return null
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a);
		this._from = a.percentage
	},
	update: function(a) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
	}
});
cc.progressTo = function(a, b) {
	return new cc.ProgressTo(a, b)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
	_to: 0,
	_from: 0,
	ctor: function(a, b, c) {
		cc.ActionInterval.prototype.ctor.call(this);
		this._from = this._to = 0;
		void 0 !== c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
	},
	clone: function() {
		var a = new cc.ProgressFromTo;
		a.initWithDuration(this._duration, this._from, this._to);
		return a
	},
	reverse: function() {
		return cc.progressFromTo(this._duration, this._to, this._from)
	},
	startWithTarget: function(a) {
		cc.ActionInterval.prototype.startWithTarget.call(this, a)
	},
	update: function(a) {
		this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
	}
});
cc.progressFromTo = function(a, b, c) {
	return new cc.ProgressFromTo(a, b, c)
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function() {
	cc.ProgressTimer.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._PI180 = Math.PI / 180;
		this._barRect = cc.rect(0, 0, 0, 0);
		this._origin = cc.p(0, 0);
		this._radius = 0;
		this._endAngle = this._startAngle = 270;
		this._counterClockWise = !1
	};
	var a = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ProgressTimer.CanvasRenderCmd;
	a.rendering = function(a, c, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			k = f._sprite,
			m = k._renderCmd._textureCoord,
			n = k._renderCmd._displayedOpacity / 255;
		if (!(0 === m.width || 0 === m.height) && k._texture && m.validRect && 0 !== n) {
			a.setTransform(this._worldTransform, c, d);
			a.setCompositeOperation(k._blendFuncStr);
			a.setGlobalAlpha(n);
			var p = k._rect,
				r = k._offsetPosition,
				n = r.x,
				s = -r.y - p.height,
				u = p.width,
				p = p.height;
			a.save();
			k._flippedX && (n = -n - u, e.scale(-1, 1));
			k._flippedY && (s = r.y, e.scale(1, -1));
			f._type === cc.ProgressTimer.TYPE_BAR ? (f = this._barRect, e.beginPath(), e.rect(f.x * c, f.y * d, f.width * c, f.height * d), e.clip(), e.closePath()) : f._type === cc.ProgressTimer.TYPE_RADIAL && (f = this._origin.x * c, r = this._origin.y * d, e.beginPath(), e.arc(f, r, this._radius * d, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), e.lineTo(f, r), e.clip(), e.closePath());
			f = k._texture.getHtmlElementObj();
			k._renderCmd._colorized ? e.drawImage(f, 0, 0, m.width, m.height, n * c, s * d, u * c, p * d) : e.drawImage(f, m.renderX, m.renderY, m.width, m.height, n * c, s * d, u * c, p * d);
			a.restore();
			cc.g_NumberOfDraws++
		}
	};
	a.releaseData = function() {};
	a.initCmd = function() {};
	a._updateProgress = function() {
		var a = this._node,
			c = a._sprite,
			d = c.width,
			e = c.height,
			f = a._midPoint;
		if (a._type === cc.ProgressTimer.TYPE_RADIAL) {
			this._radius = Math.round(Math.sqrt(d * d + e * e));
			var k, m = !1,
				n = this._origin;
			n.x = d * f.x;
			n.y = -e * f.y;
			a._reverseDirection ? (k = 270, f = 270 - 3.6 * a._percentage) : (f = -90, k = -90 + 3.6 * a._percentage);
			c._flippedX && (n.x -= d * 2 * a._midPoint.x, f = -f - 180, k = -k - 180, m = !m);
			c._flippedY && (n.y += e * 2 * a._midPoint.y, m = !m, f = -f, k = -k);
			this._startAngle = f;
			this._endAngle = k;
			this._counterClockWise = m
		} else m = a._barChangeRate, n = a._percentage / 100, a = this._barRect, m = cc.size(d * (1 - m.x), e * (1 - m.y)), n = cc.size((d - m.width) * n, (e - m.height) * n), m = cc.size(m.width + n.width, m.height + n.height), k = cc.p(d * f.x, e * f.y), n = k.x - m.width / 2, 0.5 < f.x && m.width / 2 >= d - k.x && (n = d - m.width), d = k.y - m.height / 2, 0.5 < f.y && m.height / 2 >= e - k.y && (d = e - m.height), a.x = 0, e = 1, c._flippedX && (a.x -= m.width, e = -1), 0 < n && (a.x += n * e), a.y = 0, e = 1, c._flippedY && (a.y += m.height, e = -1), 0 < d && (a.y -= d * e), a.width = m.width, a.height = -m.height
	};
	a._updateColor = function() {};
	a._syncStatus = function(a) {
		var c = this._node;
		if (c._sprite) {
			var d = cc.Node._dirtyFlags,
				e = this._dirtyFlag,
				f = a ? a._node : null;
			f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
			f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
			a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
			this._dirtyFlag = e;
			var c = c._sprite._renderCmd,
				k = c._dirtyFlag,
				f = k & d.colorDirty,
				k = k & d.opacityDirty;
			f && c._syncDisplayColor();
			k && c._syncDisplayOpacity();
			(f || k) && c._updateColor();
			e & d.transformDirty && this.transform(a)
		}
	};
	a.updateStatus = function() {
		var a = this._node;
		if (a._sprite) {
			var c = cc.Node._dirtyFlags,
				d = this._dirtyFlag,
				a = a._sprite._renderCmd,
				e = a._dirtyFlag,
				f = e & c.colorDirty,
				e = e & c.opacityDirty;
			f && a._updateDisplayColor();
			e && a._updateDisplayOpacity();
			(f || e) && a._updateColor();
			d & c.transformDirty && this.transform(this.getParentRenderCmd(), !0);
			this._dirtyFlag = 0
		}
	}
})();
(function() {
	cc.ProgressTimer.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._vertexWebGLBuffer = cc._renderContext.createBuffer();
		this._vertexDataCount = 0;
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataDirty = !1
	};
	var a = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.ProgressTimer.WebGLRenderCmd;
	a.rendering = function(a) {
		var c = this._node;
		a = a || cc._renderContext;
		if (this._vertexData && c._sprite) {
			this._shaderProgram.use();
			this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
			var d = c._sprite._blendFunc;
			cc.glBlendFunc(d.src, d.dst);
			cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
			cc.glBindTexture2D(c._sprite.texture);
			a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
			this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1);
			d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, d, 0);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, d, 8);
			a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, d, 12);
			c._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : c._type === cc.ProgressTimer.TYPE_BAR && (c._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
			cc.g_NumberOfDraws++
		}
	};
	a._syncStatus = function(a) {
		var c = this._node;
		if (c._sprite) {
			var d = cc.Node._dirtyFlags,
				e = this._dirtyFlag,
				f = a ? a._node : null;
			f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
			f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
			a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
			this._dirtyFlag = e;
			c = c._sprite._renderCmd;
			f = c._dirtyFlag;
			e = f & d.colorDirty;
			d = f & d.opacityDirty;
			e && c._syncDisplayColor();
			d && c._syncDisplayOpacity();
			if (e || d) c._updateColor(), this._updateColor();
			this.transform(a);
			c._dirtyFlag = 0
		}
	};
	a.updateStatus = function() {
		var a = this._node;
		if (a._sprite) {
			var c = cc.Node._dirtyFlags,
				d = this._dirtyFlag,
				a = a._sprite._renderCmd,
				e = a._dirtyFlag,
				f = e & c.colorDirty,
				e = e & c.opacityDirty;
			f && (a._updateDisplayColor(), this._dirtyFlag ^= this._dirtyFlag & c.colorDirty);
			e && (a._updateDisplayOpacity(), this._dirtyFlag ^= this._dirtyFlag & c.opacityDirty);
			if (f || e) a._updateColor(), this._updateColor();
			d & c.transformDirty && this.transform(this.getParentRenderCmd(), !0)
		}
	};
	a.releaseData = function() {
		this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
	};
	a.initCmd = function() {
		this._vertexArrayBuffer = this._vertexData = null;
		this._vertexDataCount = 0;
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a._updateProgress = function() {
		var a = this._node._type;
		a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
		this._vertexDataDirty = !0
	};
	a._updateBar = function() {
		var a = this._node;
		if (a._sprite) {
			var c, d = a._percentage / 100;
			c = a._barChangeRate;
			c = cc.pMult(cc.p(1 - c.x + d * c.x, 1 - c.y + d * c.y), 0.5);
			d = cc.pSub(a._midPoint, c);
			a = cc.pAdd(a._midPoint, c);
			0 > d.x && (a.x += -d.x, d.x = 0);
			1 < a.x && (d.x -= a.x - 1, a.x = 1);
			0 > d.y && (a.y += -d.y, d.y = 0);
			1 < a.y && (d.y -= a.y - 1, a.y = 1);
			if (this._reverseDirection) {
				if (!this._vertexData) {
					this._vertexDataCount = 8;
					var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
					this._vertexArrayBuffer = new ArrayBuffer(8 * e);
					var f = [];
					for (c = 0; 8 > c; c++) f[c] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, c * e);
					f[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
					f[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
					f[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
					f[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
					f[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
					f[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
					f[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
					f[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
					this._vertexData = f
				}
				c = this._vertexData;
				c[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
				c[2].vertices = this._vertexFromAlphaPoint(cc.p(d.x, a.y));
				c[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
				c[3].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
				c[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
				c[4].vertices = this._vertexFromAlphaPoint(cc.p(a.x, a.y));
				c[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
				c[5].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
			} else {
				if (!this._vertexData) {
					this._vertexDataCount = 4;
					e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
					this._vertexArrayBuffer = new ArrayBuffer(4 * e);
					this._vertexData = [];
					for (c = 0; 4 > c; c++) this._vertexData[c] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, c * e)
				}
				c = this._vertexData;
				c[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
				c[0].vertices = this._vertexFromAlphaPoint(cc.p(d.x, a.y));
				c[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
				c[1].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
				c[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
				c[2].vertices = this._vertexFromAlphaPoint(cc.p(a.x, a.y));
				c[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
				c[3].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
			}
			this._updateColor()
		}
	};
	a._updateRadial = function() {
		var a = this._node;
		if (a._sprite) {
			var c, d = a._midPoint;
			c = a._percentage / 100;
			var e = 2 * cc.PI * (a._reverseDirection ? c : 1 - c),
				a = cc.p(d.x, 1),
				f = cc.pRotateByAngle(a, d, e),
				e = 0;
			if (0 === c) f = a, e = 0;
			else if (1 === c) f = a, e = 4;
			else {
				var k = cc.FLT_MAX,
					m = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
				for (c = 0; c <= m; ++c) {
					var n = (c + (m - 1)) % m,
						p = this._boundaryTexCoord(c % m),
						n = this._boundaryTexCoord(n);
					0 === c ? n = cc.pLerp(p, n, 1 - d.x) : 4 === c && (p = cc.pLerp(p, n, 1 - d.x));
					var r = cc.p(0, 0);
					if (cc.pLineIntersect(p, n, d, f, r) && (!(0 === c || 4 === c) || 0 <= r.x && 1 >= r.x) && 0 <= r.y && r.y < k) k = r.y, e = c
				}
				f = cc.pAdd(d, cc.pMult(cc.pSub(f, d), k))
			}
			k = !0;
			this._vertexDataCount !== e + 3 && (k = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
			if (!this._vertexData) {
				m = this._vertexDataCount = e + 3;
				p = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
				this._vertexArrayBuffer = new ArrayBuffer(m * p);
				n = [];
				for (c = 0; c < m; c++) n[c] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, c * p);
				this._vertexData = n;
				if (!this._vertexData) {
					cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
					return
				}
			}
			this._updateColor();
			m = this._vertexData;
			if (!k) {
				m[0].texCoords = this._textureCoordFromAlphaPoint(d);
				m[0].vertices = this._vertexFromAlphaPoint(d);
				m[1].texCoords = this._textureCoordFromAlphaPoint(a);
				m[1].vertices = this._vertexFromAlphaPoint(a);
				for (c = 0; c < e; c++) d = this._boundaryTexCoord(c), m[c + 2].texCoords = this._textureCoordFromAlphaPoint(d), m[c + 2].vertices = this._vertexFromAlphaPoint(d)
			}
			m[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(f);
			m[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(f)
		}
	};
	a._boundaryTexCoord = function(a) {
		if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
			var c = cc.ProgressTimer.TEXTURE_COORDS;
			return this._node._reverseDirection ? cc.p(c >> 7 - (a << 1) & 1, c >> 7 - ((a << 1) + 1) & 1) : cc.p(c >> (a << 1) + 1 & 1, c >> (a << 1) & 1)
		}
		return cc.p(0, 0)
	};
	a._textureCoordFromAlphaPoint = function(a) {
		var c = this._node._sprite;
		if (!c) return {
			u: 0,
			v: 0
		};
		var d = c.quad,
			e = cc.p(d.bl.texCoords.u, d.bl.texCoords.v),
			d = cc.p(d.tr.texCoords.u, d.tr.texCoords.v);
		c.textureRectRotated && (c = a.x, a.x = a.y, a.y = c);
		return {
			u: e.x * (1 - a.x) + d.x * a.x,
			v: e.y * (1 - a.y) + d.y * a.y
		}
	};
	a._vertexFromAlphaPoint = function(a) {
		var c = this._node._sprite;
		if (!c) return {
			x: 0,
			y: 0
		};
		var d = c.quad,
			c = cc.p(d.bl.vertices.x, d.bl.vertices.y),
			d = cc.p(d.tr.vertices.x, d.tr.vertices.y);
		return {
			x: c.x * (1 - a.x) + d.x * a.x,
			y: c.y * (1 - a.y) + d.y * a.y
		}
	};
	a._updateColor = function() {
		var a = this._node;
		if (a._sprite && this._vertexData) {
			for (var a = a._sprite.quad.tl.colors, c = this._vertexData, d = 0, e = this._vertexDataCount; d < e; ++d) c[d].colors = a;
			this._vertexDataDirty = !0
		}
	}
})();
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
	_inScene: null,
	_outScene: null,
	_duration: null,
	_isInSceneOnTop: !1,
	_isSendCleanupToScene: !1,
	_className: "TransitionScene",
	ctor: function(a, b) {
		cc.Scene.prototype.ctor.call(this);
		void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
	},
	_setNewScene: function(a) {
		this.unschedule(this._setNewScene);
		a = cc.director;
		this._isSendCleanupToScene = a.isSendCleanupToScene();
		a.runScene(this._inScene);
		cc.eventManager.setEnabled(!0);
		this._outScene.visible = !0
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	visit: function() {
		this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
		cc.Node.prototype.visit.call(this)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		cc.eventManager.setEnabled(!1);
		this._outScene.onExitTransitionDidStart();
		this._inScene.onEnter()
	},
	onExit: function() {
		cc.Node.prototype.onExit.call(this);
		cc.eventManager.setEnabled(!0);
		this._outScene.onExit();
		this._inScene.onEnterTransitionDidFinish()
	},
	cleanup: function() {
		cc.Node.prototype.cleanup.call(this);
		this._isSendCleanupToScene && this._outScene.cleanup()
	},
	initWithDuration: function(a, b) {
		if (!b) throw Error("cc.TransitionScene.initWithDuration(): Argument scene must be non-nil");
		if (this.init()) {
			this._duration = a;
			this.attr({
				x: 0,
				y: 0,
				anchorX: 0,
				anchorY: 0
			});
			this._inScene = b;
			this._outScene = cc.director.getRunningScene();
			this._outScene || (this._outScene = new cc.Scene, this._outScene.init());
			if (this._inScene === this._outScene) throw Error("cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene");
			this._sceneOrder();
			return !0
		}
		return !1
	},
	finish: function() {
		this._inScene.attr({
			visible: !0,
			x: 0,
			y: 0,
			scale: 1,
			rotation: 0
		});
		cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
		this._outScene.attr({
			visible: !1,
			x: 0,
			y: 0,
			scale: 1,
			rotation: 0
		});
		cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
		this.schedule(this._setNewScene, 0)
	},
	hideOutShowIn: function() {
		this._inScene.visible = !0;
		this._outScene.visible = !1
	}
});
cc.TransitionScene.create = function(a, b) {
	return new cc.TransitionScene(a, b)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
	_orientation: 0,
	ctor: function(a, b, c) {
		cc.TransitionScene.prototype.ctor.call(this);
		void 0 != c && this.initWithDuration(a, b, c)
	},
	initWithDuration: function(a, b, c) {
		cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c);
		return !0
	}
});
cc.TransitionSceneOriented.create = function(a, b, c) {
	return new cc.TransitionSceneOriented(a, b, c)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._inScene.attr({
			scale: 0.0010,
			anchorX: 0.5,
			anchorY: 0.5
		});
		this._outScene.attr({
			scale: 1,
			anchorX: 0.5,
			anchorY: 0.5
		});
		var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, 0.0010), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
		this._outScene.runAction(a);
		this._inScene.runAction(cc.sequence(a.reverse(), cc.callFunc(this.finish, this)))
	}
});
cc.TransitionRotoZoom.create = function(a, b) {
	return new cc.TransitionRotoZoom(a, b)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a = cc.director.getWinSize();
		this._inScene.attr({
			scale: 0.5,
			x: a.width,
			y: 0,
			anchorX: 0.5,
			anchorY: 0.5
		});
		this._outScene.anchorX = 0.5;
		this._outScene.anchorY = 0.5;
		var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
			c = cc.scaleTo(this._duration / 4, 1),
			a = cc.scaleTo(this._duration / 4, 0.5),
			a = cc.sequence(a, b),
			b = cc.sequence(b, c),
			c = cc.delayTime(this._duration / 2);
		this._outScene.runAction(a);
		this._inScene.runAction(cc.sequence(c, b, cc.callFunc(this.finish, this)))
	}
});
cc.TransitionJumpZoom.create = function(a, b) {
	return new cc.TransitionJumpZoom(a, b)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this.initScenes();
		var a = this.action();
		this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
	},
	initScenes: function() {
		this._inScene.setPosition(-cc.director.getWinSize().width, 0)
	},
	action: function() {
		return cc.moveTo(this._duration, cc.p(0, 0))
	},
	easeActionWithAction: function(a) {
		return new cc.EaseOut(a, 2)
	}
});
cc.TransitionMoveInL.create = function(a, b) {
	return new cc.TransitionMoveInL(a, b)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
	ctor: function(a, b) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	initScenes: function() {
		this._inScene.setPosition(cc.director.getWinSize().width, 0)
	}
});
cc.TransitionMoveInR.create = function(a, b) {
	return new cc.TransitionMoveInR(a, b)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
	ctor: function(a, b) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	initScenes: function() {
		this._inScene.setPosition(0, cc.director.getWinSize().height)
	}
});
cc.TransitionMoveInT.create = function(a, b) {
	return new cc.TransitionMoveInT(a, b)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
	ctor: function(a, b) {
		cc.TransitionMoveInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	initScenes: function() {
		this._inScene.setPosition(0, -cc.director.getWinSize().height)
	}
});
cc.TransitionMoveInB.create = function(a, b) {
	return new cc.TransitionMoveInB(a, b)
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this.initScenes();
		var a = this.action(),
			b = this.action(),
			a = cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)),
			b = this.easeActionWithAction(b);
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	},
	initScenes: function() {
		this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
	},
	easeActionWithAction: function(a) {
		return new cc.EaseInOut(a, 2)
	}
});
cc.TransitionSlideInL.create = function(a, b) {
	return new cc.TransitionSlideInL(a, b)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
	ctor: function(a, b) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	initScenes: function() {
		this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
	}
});
cc.TransitionSlideInR.create = function(a, b) {
	return new cc.TransitionSlideInR(a, b)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
	ctor: function(a, b) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	initScenes: function() {
		this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
	}
});
cc.TransitionSlideInB.create = function(a, b) {
	return new cc.TransitionSlideInB(a, b)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
	ctor: function(a, b) {
		cc.TransitionSlideInL.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !0
	},
	initScenes: function() {
		this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
	},
	action: function() {
		return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
	}
});
cc.TransitionSlideInT.create = function(a, b) {
	return new cc.TransitionSlideInT(a, b)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._inScene.attr({
			scale: 0.0010,
			anchorX: 2 / 3,
			anchorY: 0.5
		});
		this._outScene.attr({
			scale: 1,
			anchorX: 1 / 3,
			anchorY: 0.5
		});
		var a = cc.scaleTo(this._duration, 0.01),
			b = cc.scaleTo(this._duration, 1);
		this._inScene.runAction(cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this)));
		this._outScene.runAction(this.easeActionWithAction(a))
	},
	easeActionWithAction: function(a) {
		return new cc.EaseOut(a, 2)
	}
});
cc.TransitionShrinkGrow.create = function(a, b) {
	return new cc.TransitionShrinkGrow(a, b)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, 0, 0), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionFlipX.create = function(a, b, c) {
	return new cc.TransitionFlipX(a, b, c)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, 90, 0), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionFlipY.create = function(a, b, c) {
	return new cc.TransitionFlipY(a, b, c)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, -45, 0), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionFlipAngular.create = function(a, b, c) {
	return new cc.TransitionFlipAngular(a, b, c)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = 0.5;
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionZoomFlipX.create = function(a, b, c) {
	return new cc.TransitionZoomFlipX(a, b, c)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = 0.5;
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionZoomFlipY.create = function(a, b, c) {
	return new cc.TransitionZoomFlipY(a, b, c)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
	ctor: function(a, b, c) {
		cc.TransitionSceneOriented.prototype.ctor.call(this);
		null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a, b;
		this._inScene.visible = !1;
		var c;
		this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
		a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this));
		b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
		this._inScene.scale = 0.5;
		this._inScene.runAction(a);
		this._outScene.runAction(b)
	}
});
cc.TransitionZoomFlipAngular.create = function(a, b, c) {
	return new cc.TransitionZoomFlipAngular(a, b, c)
};
cc.TransitionFade = cc.TransitionScene.extend({
	_color: null,
	ctor: function(a, b, c) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._color = cc.color();
		b && this.initWithDuration(a, b, c)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a = new cc.LayerColor(this._color);
		this._inScene.visible = !1;
		this.addChild(a, 2, cc.SCENE_FADE);
		var a = this.getChildByTag(cc.SCENE_FADE),
			b = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish, this));
		a.runAction(b)
	},
	onExit: function() {
		cc.TransitionScene.prototype.onExit.call(this);
		this.removeChildByTag(cc.SCENE_FADE, !1)
	},
	initWithDuration: function(a, b, c) {
		c = c || cc.color.BLACK;
		cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0);
		return !0
	}
});
cc.TransitionFade.create = function(a, b, c) {
	return new cc.TransitionFade(a, b, c)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a = cc.color(0, 0, 0, 0),
			b = cc.director.getWinSize(),
			a = new cc.LayerColor(a),
			c = new cc.RenderTexture(b.width, b.height);
		c.sprite.anchorX = 0.5;
		c.sprite.anchorY = 0.5;
		c.attr({
			x: b.width / 2,
			y: b.height / 2,
			anchorX: 0.5,
			anchorY: 0.5
		});
		c.begin();
		this._inScene.visit();
		c.end();
		var d = new cc.RenderTexture(b.width, b.height);
		d.setPosition(b.width / 2, b.height / 2);
		d.sprite.anchorX = d.anchorX = 0.5;
		d.sprite.anchorY = d.anchorY = 0.5;
		d.begin();
		this._outScene.visit();
		d.end();
		c.sprite.setBlendFunc(cc.ONE, cc.ONE);
		d.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
		a.addChild(c);
		a.addChild(d);
		c.sprite.opacity = 255;
		d.sprite.opacity = 255;
		b = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
		d.sprite.runAction(b);
		this.addChild(a, 2, cc.SCENE_FADE)
	},
	onExit: function() {
		this.removeChildByTag(cc.SCENE_FADE, !1);
		cc.TransitionScene.prototype.onExit.call(this)
	},
	visit: function() {
		cc.Node.prototype.visit.call(this)
	},
	draw: function() {}
});
cc.TransitionCrossFade.create = function(a, b) {
	return new cc.TransitionCrossFade(a, b)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
	_gridProxy: null,
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var a = cc.director.getWinSize(),
			a = cc.turnOffTiles(this._duration, cc.size(0 | 12 * (a.width / a.height), 12)),
			a = this.easeActionWithAction(a);
		this._gridProxy.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	visit: function() {
		this._inScene.visit();
		this._gridProxy.visit()
	},
	easeActionWithAction: function(a) {
		return a
	}
});
cc.TransitionTurnOffTiles.create = function(a, b) {
	return new cc.TransitionTurnOffTiles(a, b)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
	_gridProxy: null,
	_switchTargetToInscene: function() {
		this._gridProxy.setTarget(this._inScene)
	},
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		b && this.initWithDuration(a, b)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var a = this.action(),
			a = cc.sequence(a, cc.callFunc(this._switchTargetToInscene, this), a.reverse());
		this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	onExit: function() {
		this._gridProxy.setTarget(null);
		this._gridProxy.onExit();
		cc.TransitionScene.prototype.onExit.call(this)
	},
	visit: function() {
		this._gridProxy.visit()
	},
	easeActionWithAction: function(a) {
		return new cc.EaseInOut(a, 3)
	},
	action: function() {
		return cc.splitCols(this._duration / 2, 3)
	}
});
cc.TransitionSplitCols.create = function(a, b) {
	return new cc.TransitionSplitCols(a, b)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
	ctor: function(a, b) {
		cc.TransitionSplitCols.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	action: function() {
		return cc.splitRows(this._duration / 2, 3)
	}
});
cc.TransitionSplitRows.create = function(a, b) {
	return new cc.TransitionSplitRows(a, b)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
	_gridProxy: null,
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		b && this.initWithDuration(a, b)
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._gridProxy.setTarget(this._outScene);
		this._gridProxy.onEnter();
		var a = cc.director.getWinSize(),
			a = this.actionWithSize(cc.size(0 | 12 * (a.width / a.height), 12));
		this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this), cc.stopGrid()))
	},
	visit: function() {
		this._inScene.visit();
		this._gridProxy.visit()
	},
	easeActionWithAction: function(a) {
		return a
	},
	actionWithSize: function(a) {
		return cc.fadeOutTRTiles(this._duration, a)
	}
});
cc.TransitionFadeTR.create = function(a, b) {
	return new cc.TransitionFadeTR(a, b)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
	ctor: function(a, b) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	actionWithSize: function(a) {
		return cc.fadeOutBLTiles(this._duration, a)
	}
});
cc.TransitionFadeBL.create = function(a, b) {
	return new cc.TransitionFadeBL(a, b)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
	ctor: function(a, b) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	actionWithSize: function(a) {
		return new cc.FadeOutUpTiles(this._duration, a)
	}
});
cc.TransitionFadeUp.create = function(a, b) {
	return new cc.TransitionFadeUp(a, b)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
	ctor: function(a, b) {
		cc.TransitionFadeTR.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	actionWithSize: function(a) {
		return cc.fadeOutDownTiles(this._duration, a)
	}
});
cc.TransitionFadeDown.create = function(a, b) {
	return new cc.TransitionFadeDown(a, b)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
	_to: 0,
	_from: 0,
	_sceneToBeModified: null,
	_className: "TransitionProgress",
	ctor: function(a, b) {
		cc.TransitionScene.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_setAttrs: function(a, b, c) {
		a.attr({
			x: b,
			y: c,
			anchorX: 0.5,
			anchorY: 0.5
		})
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		this._setupTransition();
		var a = cc.director.getWinSize(),
			b = new cc.RenderTexture(a.width, a.height);
		b.sprite.anchorX = 0.5;
		b.sprite.anchorY = 0.5;
		this._setAttrs(b, a.width / 2, a.height / 2);
		b.clear(0, 0, 0, 1);
		b.begin();
		this._sceneToBeModified.visit();
		b.end();
		this._sceneToBeModified === this._outScene && this.hideOutShowIn();
		a = this._progressTimerNodeWithRenderTexture(b);
		b = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
		a.runAction(b);
		this.addChild(a, 2, cc.SCENE_RADIAL)
	},
	onExit: function() {
		this.removeChildByTag(cc.SCENE_RADIAL, !0);
		cc.TransitionScene.prototype.onExit.call(this)
	},
	_setupTransition: function() {
		this._sceneToBeModified = this._outScene;
		this._from = 100;
		this._to = 0
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
		return null
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	}
});
cc.TransitionProgress.create = function(a, b) {
	return new cc.TransitionProgress(a, b)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_RADIAL;
		a.reverseDir = !1;
		a.percentage = 100;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	}
});
cc.TransitionProgressRadialCCW.create = function(a, b) {
	return new cc.TransitionProgressRadialCCW(a, b)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_RADIAL;
		a.reverseDir = !0;
		a.percentage = 100;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	}
});
cc.TransitionProgressRadialCW.create = function(a, b) {
	var c = new cc.TransitionProgressRadialCW;
	return null !== c && c.initWithDuration(a, b) ? c : new cc.TransitionProgressRadialCW(a, b)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_BAR;
		a.midPoint = cc.p(1, 0);
		a.barChangeRate = cc.p(1, 0);
		a.percentage = 100;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	}
});
cc.TransitionProgressHorizontal.create = function(a, b) {
	return new cc.TransitionProgressHorizontal(a, b)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_BAR;
		a.midPoint = cc.p(0, 0);
		a.barChangeRate = cc.p(0, 1);
		a.percentage = 100;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	}
});
cc.TransitionProgressVertical.create = function(a, b) {
	return new cc.TransitionProgressVertical(a, b)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_BAR;
		a.midPoint = cc.p(0.5, 0.5);
		a.barChangeRate = cc.p(1, 1);
		a.percentage = 0;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = !1
	},
	_setupTransition: function() {
		this._sceneToBeModified = this._inScene;
		this._from = 0;
		this._to = 100
	}
});
cc.TransitionProgressInOut.create = function(a, b) {
	return new cc.TransitionProgressInOut(a, b)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
	ctor: function(a, b) {
		cc.TransitionProgress.prototype.ctor.call(this);
		b && this.initWithDuration(a, b)
	},
	_progressTimerNodeWithRenderTexture: function(a) {
		var b = cc.director.getWinSize();
		a = new cc.ProgressTimer(a.sprite);
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
		a.type = cc.ProgressTimer.TYPE_BAR;
		a.midPoint = cc.p(0.5, 0.5);
		a.barChangeRate = cc.p(1, 1);
		a.percentage = 100;
		this._setAttrs(a, b.width / 2, b.height / 2);
		return a
	}
});
cc.TransitionProgressOutIn.create = function(a, b) {
	return new cc.TransitionProgressOutIn(a, b)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
	ctor: function(a, b, c) {
		cc.TransitionScene.prototype.ctor.call(this);
		this._gridProxy = new cc.NodeGrid;
		this.initWithDuration(a, b, c)
	},
	_back: !0,
	_gridProxy: null,
	_className: "TransitionPageTurn",
	initWithDuration: function(a, b, c) {
		this._back = c;
		cc.TransitionScene.prototype.initWithDuration.call(this, a, b);
		return !0
	},
	actionWithSize: function(a) {
		return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
	},
	onEnter: function() {
		cc.TransitionScene.prototype.onEnter.call(this);
		var a = cc.director.getWinSize(),
			b;
		a.width > a.height ? (a = 16, b = 12) : (a = 12, b = 16);
		a = this.actionWithSize(cc.size(a, b));
		b = this._gridProxy;
		this._back ? (b.setTarget(this._inScene), b.onEnter(), this._inScene.visible = !1, b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (b.setTarget(this._outScene), b.onEnter(), b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())))
	},
	visit: function() {
		this._back ? this._outScene.visit() : this._inScene.visit();
		this._gridProxy.visit()
	},
	_sceneOrder: function() {
		this._isInSceneOnTop = this._back
	}
});
cc.TransitionPageTurn.create = function(a, b, c) {
	return new cc.TransitionPageTurn(a, b, c)
};
cc.Codec = {
	name: "Jacob__Codec"
};
cc.unzip = function() {
	return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
	var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
	return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function(a, b) {
	b = b || 1;
	var c = this.unzipBase64(a),
		d = [],
		e, f, k;
	e = 0;
	for (k = c.length / b; e < k; e++) {
		d[e] = 0;
		for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
	}
	return d
};
cc.unzipAsArray = function(a, b) {
	b = b || 1;
	var c = this.unzip(a),
		d = [],
		e, f, k;
	e = 0;
	for (k = c.length / b; e < k; e++) {
		d[e] = 0;
		for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
	}
	return d
};
cc.StringToArray = function(a) {
	a = a.split(",");
	var b = [],
		c;
	for (c = 0; c < a.length; c++) b.push(parseInt(a[c]));
	return b
};
cc.Codec.Base64 = {
	name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
cc.Codec.Base64.decode = function(a) {
	var b = [],
		c, d, e, f, k, m = 0;
	for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); m < a.length;) c = this._keyStr.indexOf(a.charAt(m++)), d = this._keyStr.indexOf(a.charAt(m++)), f = this._keyStr.indexOf(a.charAt(m++)), k = this._keyStr.indexOf(a.charAt(m++)), c = c << 2 | d >> 4, d = (d & 15) << 4 | f >> 2, e = (f & 3) << 6 | k, b.push(String.fromCharCode(c)), 64 !== f && b.push(String.fromCharCode(d)), 64 !== k && b.push(String.fromCharCode(e));
	return b = b.join("")
};
cc.Codec.Base64.decodeAsArray = function(a, b) {
	var c = this.decode(a),
		d = [],
		e, f, k;
	e = 0;
	for (k = c.length / b; e < k; e++) {
		d[e] = 0;
		for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
	}
	return d
};
cc.uint8ArrayToUint32Array = function(a) {
	if (0 !== a.length % 4) return null;
	for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; d < b; d++) {
		var e = 4 * d;
		c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + 16777216 * a[e + 3]
	}
	return c
};
cc.Codec.GZip = function(a) {
	this.data = a;
	this.debug = !1;
	this.gpflags = void 0;
	this.files = 0;
	this.unzipped = [];
	this.buf32k = Array(32768);
	this.bIdx = 0;
	this.modeZIP = !1;
	this.bytepos = 0;
	this.bb = 1;
	this.bits = 0;
	this.nameBuf = [];
	this.fileout = void 0;
	this.literalTree = Array(cc.Codec.GZip.LITERALS);
	this.distanceTree = Array(32);
	this.treepos = 0;
	this.Places = null;
	this.len = 0;
	this.fpos = Array(17);
	this.fpos[0] = 0;
	this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function(a) {
	return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
	this.b1 = this.b0 = 0;
	this.jump = null;
	this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
	this.outputArr = [];
	this.nextFile();
	return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
	this.bits += 8;
	return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function() {
	this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
	var a;
	this.bits++;
	a = this.bb & 1;
	this.bb >>= 1;
	0 === this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
	return a
};
cc.Codec.GZip.prototype.readBits = function(a) {
	for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
	a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a);
	return b
};
cc.Codec.GZip.prototype.flushBuffer = function() {
	this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(a) {
	this.buf32k[this.bIdx++] = a;
	this.outputArr.push(String.fromCharCode(a));
	32768 === this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function() {
	for (;;) {
		if (this.fpos[this.len] >= this.fmax) return -1;
		if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
		this.fpos[this.len]++
	}
};
cc.Codec.GZip.prototype.Rec = function() {
	var a = this.Places[this.treepos],
		b;
	if (17 === this.len) return -1;
	this.treepos++;
	this.len++;
	b = this.IsPat();
	if (0 <= b) a.b0 = b;
	else if (a.b0 = 32768, this.Rec()) return -1;
	b = this.IsPat();
	if (0 <= b) a.b1 = b, a.jump = null;
	else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec()) return -1;
	this.len--;
	return 0
};
cc.Codec.GZip.prototype.CreateTree = function(a, b, c, d) {
	this.Places = a;
	this.treepos = 0;
	this.flens = c;
	this.fmax = b;
	for (a = 0; 17 > a; a++) this.fpos[a] = 0;
	this.len = 0;
	return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function(a) {
	for (var b, c, d = 0, e = a[d];;)
	if (b = this.readBit()) {
		if (!(e.b1 & 32768)) return e.b1;
		e = e.jump;
		b = a.length;
		for (c = 0; c < b; c++)
		if (a[c] === e) {
			d = c;
			break
		}
	} else {
		if (!(e.b0 & 32768)) return e.b0;
		d++;
		e = a[d]
	}
	return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
	var a, b, c, d, e;
	do
	if (a = this.readBit(), c = this.readBits(2), 0 === c) {
		this.byteAlign();
		c = this.readByte();
		c |= this.readByte() << 8;
		b = this.readByte();
		b |= this.readByte() << 8;
		for ((c ^ ~b) & 65535 && document.write("BlockLen checksum mismatch\n"); c--;) b = this.readByte(), this.addBuffer(b)
	} else if (1 === c) for (;;)
	if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < c ? (c = c << 1 | this.readBit(), 199 < c ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, 143 < c && (c += 136))) : c += 256, 256 > c) this.addBuffer(c);
	else if (256 === c) break;
	else {
		var f;
		c -= 257;
		e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c];
		c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
		8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
		f += cc.Codec.GZip.cpdist[c];
		for (c = 0; c < e; c++) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
	} else if (2 === c) {
		var k = Array(320);
		b = 257 + this.readBits(5);
		f = 1 + this.readBits(5);
		d = 4 + this.readBits(4);
		for (c = 0; 19 > c; c++) k[c] = 0;
		for (c = 0; c < d; c++) k[cc.Codec.GZip.border[c]] = this.readBits(3);
		e = this.distanceTree.length;
		for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
		if (this.CreateTree(this.distanceTree, 19, k, 0)) return this.flushBuffer(), 1;
		e = b + f;
		d = 0;
		for (var m = -1; d < e;)
		if (m++, c = this.DecodeValue(this.distanceTree), 16 > c) k[d++] = c;
		else if (16 === c) {
			var n;
			c = 3 + this.readBits(2);
			if (d + c > e) return this.flushBuffer(), 1;
			for (n = d ? k[d - 1] : 0; c--;) k[d++] = n
		} else {
			c = 17 === c ? 3 + this.readBits(3) : 11 + this.readBits(7);
			if (d + c > e) return this.flushBuffer(), 1;
			for (; c--;) k[d++] = 0
		}
		e = this.literalTree.length;
		for (d = 0; d < e; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
		if (this.CreateTree(this.literalTree, b, k, 0)) return this.flushBuffer(), 1;
		e = this.literalTree.length;
		for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
		c = [];
		for (d = b; d < k.length; d++) c[d - b] = k[d];
		if (this.CreateTree(this.distanceTree, f, c, 0)) return this.flushBuffer(), 1;
		for (;;)
		if (c = this.DecodeValue(this.literalTree), 256 <= c) {
			c -= 256;
			if (0 === c) break;
			c--;
			e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c];
			c = this.DecodeValue(this.distanceTree);
			8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
			for (f += cc.Codec.GZip.cpdist[c]; e--;) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
		} else this.addBuffer(c)
	}
	while (!a);
	this.flushBuffer();
	this.byteAlign();
	return 0
};
cc.Codec.GZip.prototype.unzipFile = function(a) {
	var b;
	this.gunzip();
	for (b = 0; b < this.unzipped.length; b++)
	if (this.unzipped[b][1] === a) return this.unzipped[b][0]
};
cc.Codec.GZip.prototype.nextFile = function() {
	this.outputArr = [];
	this.modeZIP = !1;
	var a = [];
	a[0] = this.readByte();
	a[1] = this.readByte();
	120 === a[0] && 218 === a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
	31 === a[0] && 139 === a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
	if (80 === a[0] && 75 === a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 === a[2] && 4 === a[3])) {
		a[0] = this.readByte();
		a[1] = this.readByte();
		this.gpflags = this.readByte();
		this.gpflags |= this.readByte() << 8;
		a = this.readByte();
		a |= this.readByte() << 8;
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		this.readByte();
		var b = this.readByte(),
			b = b | this.readByte() << 8,
			c = this.readByte(),
			c = c | this.readByte() << 8,
			d = 0;
		for (this.nameBuf = []; b--;) {
			var e = this.readByte();
			"/" === e | ":" === e ? d = 0 : d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = String.fromCharCode(e))
		}
		this.fileout || (this.fileout = this.nameBuf);
		for (var d = 0; d < c;) this.readByte(), d++;
		8 === a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
		this.skipdir()
	}
};
cc.Codec.GZip.prototype.skipdir = function() {
	var a = [],
		b;
	this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
	this.modeZIP && this.nextFile();
	a[0] = this.readByte();
	if (8 !== a[0]) return 0;
	this.gpflags = this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	if (this.gpflags & 4) {
		a[0] = this.readByte();
		a[2] = this.readByte();
		this.len = a[0] + 256 * a[1];
		for (a = 0; a < this.len; a++) this.readByte()
	}
	if (this.gpflags & 8) {
		a = 0;
		for (this.nameBuf = []; b = this.readByte();) {
			if ("7" === b || ":" === b) a = 0;
			a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = b)
		}
	}
	if (this.gpflags & 16) for (; this.readByte(););
	this.gpflags & 2 && (this.readByte(), this.readByte());
	this.DeflateLoop();
	this.readByte();
	this.readByte();
	this.readByte();
	this.readByte();
	this.modeZIP && this.nextFile()
};
(function() {
	function a(a) {
		throw a;
	}

	function b(a, b) {
		var c = a.split("."),
			d = C;
		!(c[0] in d) && d.execScript && d.execScript("var " + c[0]);
		for (var e; c.length && (e = c.shift());)!c.length && b !== F ? d[e] = b : d = d[e] ? d[e] : d[e] = {}
	}

	function c(a) {
		if ("string" === typeof a) {
			a = a.split("");
			var b, c;
			b = 0;
			for (c = a.length; b < c; b++) a[b] = (a[b].charCodeAt(0) & 255) >>> 0
		}
		b = 1;
		c = 0;
		for (var d = a.length, e, f = 0; 0 < d;) {
			e = 1024 < d ? 1024 : d;
			d -= e;
			do b += a[f++], c += b;
			while (--e);
			b %= 65521;
			c %= 65521
		}
		return (c << 16 | b) >>> 0
	}

	function d(b, c) {
		this.index = "number" === typeof c ? c : 0;
		this.i = 0;
		this.buffer = b instanceof(A ? Uint8Array : Array) ? b : new(A ? Uint8Array : Array)(32768);
		2 * this.buffer.length <= this.index && a(Error("invalid index"));
		this.buffer.length <= this.index && this.f()
	}

	function e(a) {
		this.buffer = new(A ? Uint16Array : Array)(2 * a);
		this.length = 0
	}

	function f(a) {
		var b = a.length,
			c = 0,
			d = Number.POSITIVE_INFINITY,
			e, f, k, m, n, p, r, s, u;
		for (s = 0; s < b; ++s) a[s] > c && (c = a[s]), a[s] < d && (d = a[s]);
		e = 1 << c;
		f = new(A ? Uint32Array : Array)(e);
		k = 1;
		m = 0;
		for (n = 2; k <= c;) {
			for (s = 0; s < b; ++s)
			if (a[s] === k) {
				p = 0;
				r = m;
				for (u = 0; u < k; ++u) p = p << 1 | r & 1, r >>= 1;
				for (u = p; u < e; u += n) f[u] = k << 16 | s;
				++m
			}++k;
			m <<= 1;
			n <<= 1
		}
		return [f, c, d]
	}

	function k(a, b) {
		this.h = L;
		this.w = 0;
		this.input = a;
		this.b = 0;
		b && (b.lazy && (this.w = b.lazy), "number" === typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = A && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" === typeof b.outputIndex && (this.b = b.outputIndex));
		this.a || (this.a = new(A ? Uint8Array : Array)(32768))
	}

	function m(a, b) {
		this.length = a;
		this.G = b
	}

	function n() {
		var b = M;
		switch (E) {
		case 3 === b:
			return [257, b - 3, 0];
		case 4 === b:
			return [258, b - 4, 0];
		case 5 === b:
			return [259, b - 5, 0];
		case 6 === b:
			return [260, b - 6, 0];
		case 7 === b:
			return [261, b - 7, 0];
		case 8 === b:
			return [262, b - 8, 0];
		case 9 === b:
			return [263, b - 9, 0];
		case 10 === b:
			return [264, b - 10, 0];
		case 12 >= b:
			return [265, b - 11, 1];
		case 14 >= b:
			return [266, b - 13, 1];
		case 16 >= b:
			return [267, b - 15, 1];
		case 18 >= b:
			return [268, b - 17, 1];
		case 22 >= b:
			return [269, b - 19, 2];
		case 26 >= b:
			return [270, b - 23, 2];
		case 30 >= b:
			return [271, b - 27, 2];
		case 34 >= b:
			return [272, b - 31, 2];
		case 42 >= b:
			return [273, b - 35, 3];
		case 50 >= b:
			return [274, b - 43, 3];
		case 58 >= b:
			return [275, b - 51, 3];
		case 66 >= b:
			return [276, b - 59, 3];
		case 82 >= b:
			return [277, b - 67, 4];
		case 98 >= b:
			return [278, b - 83, 4];
		case 114 >= b:
			return [279, b - 99, 4];
		case 130 >= b:
			return [280, b - 115, 4];
		case 162 >= b:
			return [281, b - 131, 5];
		case 194 >= b:
			return [282, b - 163, 5];
		case 226 >= b:
			return [283, b - 195, 5];
		case 257 >= b:
			return [284, b - 227, 5];
		case 258 === b:
			return [285, b - 258, 0];
		default:
			a("invalid length: " + b)
		}
	}

	function p(b, c) {
		function d(b, c) {
			var e = b.G,
				f = [],
				k = 0,
				m;
			m = P[b.length];
			f[k++] = m & 65535;
			f[k++] = m >> 16 & 255;
			f[k++] = m >> 24;
			var n;
			switch (E) {
			case 1 === e:
				n = [0, e - 1, 0];
				break;
			case 2 === e:
				n = [1, e - 2, 0];
				break;
			case 3 === e:
				n = [2, e - 3, 0];
				break;
			case 4 === e:
				n = [3, e - 4, 0];
				break;
			case 6 >= e:
				n = [4, e - 5, 1];
				break;
			case 8 >= e:
				n = [5, e - 7, 1];
				break;
			case 12 >= e:
				n = [6, e - 9, 2];
				break;
			case 16 >= e:
				n = [7, e - 13, 2];
				break;
			case 24 >= e:
				n = [8, e - 17, 3];
				break;
			case 32 >= e:
				n = [9, e - 25, 3];
				break;
			case 48 >= e:
				n = [10, e - 33, 4];
				break;
			case 64 >= e:
				n = [11, e - 49, 4];
				break;
			case 96 >= e:
				n = [12, e - 65, 5];
				break;
			case 128 >= e:
				n = [13, e - 97, 5];
				break;
			case 192 >= e:
				n = [14, e - 129, 6];
				break;
			case 256 >= e:
				n = [15, e - 193, 6];
				break;
			case 384 >= e:
				n = [16, e - 257, 7];
				break;
			case 512 >= e:
				n = [17, e - 385, 7];
				break;
			case 768 >= e:
				n = [18, e - 513, 8];
				break;
			case 1024 >= e:
				n = [19, e - 769, 8];
				break;
			case 1536 >= e:
				n = [20, e - 1025, 9];
				break;
			case 2048 >= e:
				n = [21, e - 1537, 9];
				break;
			case 3072 >= e:
				n = [22, e - 2049, 10];
				break;
			case 4096 >= e:
				n = [23, e - 3073, 10];
				break;
			case 6144 >= e:
				n = [24, e - 4097, 11];
				break;
			case 8192 >= e:
				n = [25, e - 6145, 11];
				break;
			case 12288 >= e:
				n = [26, e - 8193, 12];
				break;
			case 16384 >= e:
				n = [27, e - 12289, 12];
				break;
			case 24576 >= e:
				n = [28, e - 16385, 13];
				break;
			case 32768 >= e:
				n = [29, e - 24577, 13];
				break;
			default:
				a("invalid distance")
			}
			m = n;
			f[k++] = m[0];
			f[k++] = m[1];
			f[k++] = m[2];
			e = 0;
			for (k = f.length; e < k; ++e) u[t++] = f[e];
			w[f[0]]++;
			x[f[3]]++;
			v = b.length + c - 1;
			s = null
		}
		var e, f, k, n, p, r = {},
			s, u = A ? new Uint16Array(2 * c.length) : [],
			t = 0,
			v = 0,
			w = new(A ? Uint32Array : Array)(286),
			x = new(A ? Uint32Array : Array)(30),
			B = b.w,
			G;
		if (!A) {
			for (k = 0; 285 >= k;) w[k++] = 0;
			for (k = 0; 29 >= k;) x[k++] = 0
		}
		w[256] = 1;
		e = 0;
		for (f = c.length; e < f; ++e) {
			k = p = 0;
			for (n = 3; k < n && e + k !== f; ++k) p = p << 8 | c[e + k];
			r[p] === F && (r[p] = []);
			k = r[p];
			if (!(0 < v--)) {
				for (; 0 < k.length && 32768 < e - k[0];) k.shift();
				if (e + 3 >= f) {
					s && d(s, -1);
					k = 0;
					for (n = f - e; k < n; ++k) G = c[e + k], u[t++] = G, ++w[G];
					break
				}
				if (0 < k.length) {
					p = n = F;
					var y = 0,
						H = F,
						D = F,
						z = H = F,
						J = c.length,
						D = 0,
						z = k.length;
					a: for (; D < z; D++) {
						n = k[z - D - 1];
						H = 3;
						if (3 < y) {
							for (H = y; 3 < H; H--)
							if (c[n + H - 1] !== c[e + H - 1]) continue a;
							H = y
						}
						for (; 258 > H && e + H < J && c[n + H] === c[e + H];)++H;
						H > y && (p = n, y = H);
						if (258 === H) break
					}
					n = new m(y, e - p);
					s ? s.length < n.length ? (G = c[e - 1], u[t++] = G, ++w[G], d(n, 0)) : d(s, -1) : n.length < B ? s = n : d(n, 0)
				} else s ? d(s, -1) : (G = c[e], u[t++] = G, ++w[G])
			}
			k.push(e)
		}
		u[t++] = 256;
		w[256]++;
		b.L = w;
		b.K = x;
		return A ? u.subarray(0, t) : u
	}

	function r(a, b) {
		function c(a) {
			var b = u[a][t[a]];
			b === r ? (c(a + 1), c(a + 1)) : --s[b];
			++t[a]
		}
		var d = a.length,
			f = new e(572),
			k = new(A ? Uint8Array : Array)(d),
			m, n, p;
		if (!A) for (n = 0; n < d; n++) k[n] = 0;
		for (n = 0; n < d; ++n) 0 < a[n] && f.push(n, a[n]);
		d = Array(f.length / 2);
		m = new(A ? Uint32Array : Array)(f.length / 2);
		if (1 === d.length) return k[f.pop().index] = 1, k;
		n = 0;
		for (p = f.length / 2; n < p; ++n) d[n] = f.pop(), m[n] = d[n].value;
		var r = m.length;
		n = new(A ? Uint16Array : Array)(b);
		var f = new(A ? Uint8Array : Array)(b),
			s = new(A ? Uint8Array : Array)(r);
		p = Array(b);
		var u = Array(b),
			t = Array(b),
			v = (1 << b) - r,
			w = 1 << b - 1,
			x, B, G;
		n[b - 1] = r;
		for (x = 0; x < b; ++x) v < w ? f[x] = 0 : (f[x] = 1, v -= w), v <<= 1, n[b - 2 - x] = (n[b - 1 - x] / 2 | 0) + r;
		n[0] = f[0];
		p[0] = Array(n[0]);
		u[0] = Array(n[0]);
		for (x = 1; x < b; ++x) n[x] > 2 * n[x - 1] + f[x] && (n[x] = 2 * n[x - 1] + f[x]), p[x] = Array(n[x]), u[x] = Array(n[x]);
		for (v = 0; v < r; ++v) s[v] = b;
		for (w = 0; w < n[b - 1]; ++w) p[b - 1][w] = m[w], u[b - 1][w] = w;
		for (v = 0; v < b; ++v) t[v] = 0;
		1 === f[b - 1] && (--s[0], ++t[b - 1]);
		for (x = b - 2; 0 <= x; --x) {
			B = v = 0;
			G = t[x + 1];
			for (w = 0; w < n[x]; w++) B = p[x + 1][G] + p[x + 1][G + 1], B > m[v] ? (p[x][w] = B, u[x][w] = r, G += 2) : (p[x][w] = m[v], u[x][w] = v, ++v);
			t[x] = 0;
			1 === f[x] && c(x)
		}
		m = s;
		n = 0;
		for (p = d.length; n < p; ++n) k[d[n].index] = m[n];
		return k
	}

	function s(b) {
		var c = new(A ? Uint16Array : Array)(b.length),
			d = [],
			e = [],
			f = 0,
			k, m, n;
		k = 0;
		for (m = b.length; k < m; k++) d[b[k]] = (d[b[k]] | 0) + 1;
		k = 1;
		for (m = 16; k <= m; k++) e[k] = f, f += d[k] | 0, f > 1 << k && a("overcommitted"), f <<= 1;
		65536 > f && a("undercommitted");
		k = 0;
		for (m = b.length; k < m; k++) {
			f = e[b[k]];
			e[b[k]] += 1;
			d = c[k] = 0;
			for (n = b[k]; d < n; d++) c[k] = c[k] << 1 | f & 1, f >>>= 1
		}
		return c
	}

	function u(a, b) {
		this.input = a;
		this.a = new(A ? Uint8Array : Array)(32768);
		this.h = I.j;
		var c = {},
			d;
		if ((b || !(b = {})) && "number" === typeof b.compressionType) this.h = b.compressionType;
		for (d in b) c[d] = b[d];
		c.outputBuffer = this.a;
		this.z = new k(this.input, c)
	}

	function t(b, c) {
		this.k = [];
		this.l = 32768;
		this.e = this.g = this.c = this.q = 0;
		this.input = A ? new Uint8Array(b) : b;
		this.s = !1;
		this.m = O;
		this.B = !1;
		if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);
		switch (this.m) {
		case K:
			this.b = 32768;
			this.a = new(A ? Uint8Array : Array)(32768 + this.l + 258);
			break;
		case O:
			this.b = 0;
			this.a = new(A ? Uint8Array : Array)(this.l);
			this.f = this.J;
			this.t = this.H;
			this.o = this.I;
			break;
		default:
			a(Error("invalid inflate mode"))
		}
	}

	function w(b, c) {
		for (var d = b.g, e = b.e, f = b.input, k = b.c, m; e < c;) m = f[k++], m === F && a(Error("input buffer is broken")), d |= m << e, e += 8;
		b.g = d >>> c;
		b.e = e - c;
		b.c = k;
		return d & (1 << c) - 1
	}

	function v(b, c) {
		for (var d = b.g, e = b.e, f = b.input, k = b.c, m = c[0], n = c[1], p; e < n;) p = f[k++], p === F && a(Error("input buffer is broken")), d |= p << e, e += 8;
		f = m[d & (1 << n) - 1];
		m = f >>> 16;
		b.g = d >> m;
		b.e = e - m;
		b.c = k;
		return f & 65535
	}

	function y(a) {
		function b(a, c, d) {
			var e, f, k, m;
			for (m = 0; m < a;) switch (e = v(this, c), e) {
			case 16:
				for (k = 3 + w(this, 2); k--;) d[m++] = f;
				break;
			case 17:
				for (k = 3 + w(this, 3); k--;) d[m++] = 0;
				f = 0;
				break;
			case 18:
				for (k = 11 + w(this, 7); k--;) d[m++] = 0;
				f = 0;
				break;
			default:
				f = d[m++] = e
			}
			return d
		}
		var c = w(a, 5) + 257,
			d = w(a, 5) + 1,
			e = w(a, 4) + 4,
			k = new(A ? Uint8Array : Array)(Q.length),
			m;
		for (m = 0; m < e; ++m) k[Q[m]] = w(a, 3);
		e = f(k);
		k = new(A ? Uint8Array : Array)(c);
		m = new(A ? Uint8Array : Array)(d);
		a.o(f(b.call(a, c, e, k)), f(b.call(a, d, e, m)))
	}

	function z(b, c) {
		var d, e;
		this.input = b;
		this.c = 0;
		if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
		d = b[this.c++];
		e = b[this.c++];
		switch (d & 15) {
		case T:
			this.method = T;
			break;
		default:
			a(Error("unsupported compression method"))
		}
		0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31));
		e & 32 && a(Error("fdict flag is not supported"));
		this.A = new t(b, {
			index: this.c,
			bufferSize: c.bufferSize,
			bufferType: c.bufferType,
			resize: c.resize
		})
	}
	var F = void 0,
		E = !0,
		C = this,
		A = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
	d.prototype.f = function() {
		var a = this.buffer,
			b, c = a.length,
			d = new(A ? Uint8Array : Array)(c << 1);
		if (A) d.set(a);
		else for (b = 0; b < c; ++b) d[b] = a[b];
		return this.buffer = d
	};
	d.prototype.d = function(a, b, c) {
		var d = this.buffer,
			e = this.index,
			f = this.i,
			k = d[e];
		c && 1 < b && (a = 8 < b ? (H[a & 255] << 24 | H[a >>> 8 & 255] << 16 | H[a >>> 16 & 255] << 8 | H[a >>> 24 & 255]) >> 32 - b : H[a] >> 8 - b);
		if (8 > b + f) k = k << b | a, f += b;
		else for (c = 0; c < b; ++c) k = k << 1 | a >> b - c - 1 & 1, 8 === ++f && (f = 0, d[e++] = H[k], k = 0, e === d.length && (d = this.f()));
		d[e] = k;
		this.buffer = d;
		this.i = f;
		this.index = e
	};
	d.prototype.finish = function() {
		var a = this.buffer,
			b = this.index,
			c;
		0 < this.i && (a[b] <<= 8 - this.i, a[b] = H[a[b]], b++);
		A ? c = a.subarray(0, b) : (a.length = b, c = a);
		return c
	};
	var x = new(A ? Uint8Array : Array)(256),
		B;
	for (B = 0; 256 > B; ++B) {
		for (var G = B, D = G, J = 7, G = G >>> 1; G; G >>>= 1) D <<= 1, D |= G & 1, --J;
		x[B] = (D << J & 255) >>> 0
	}
	var H = x,
		x = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
	A && new Uint32Array(x);
	e.prototype.getParent = function(a) {
		return 2 * ((a - 2) / 4 | 0)
	};
	e.prototype.push = function(a, b) {
		var c, d, e = this.buffer,
			f;
		c = this.length;
		e[this.length++] = b;
		for (e[this.length++] = a; 0 < c;)
		if (d = this.getParent(c), e[c] > e[d]) f = e[c], e[c] = e[d], e[d] = f, f = e[c + 1], e[c + 1] = e[d + 1], e[d + 1] = f, c = d;
		else break;
		return this.length
	};
	e.prototype.pop = function() {
		var a, b, c = this.buffer,
			d, e, f;
		b = c[0];
		a = c[1];
		this.length -= 2;
		c[0] = c[this.length];
		c[1] = c[this.length + 1];
		for (f = 0;;) {
			e = 2 * f + 2;
			if (e >= this.length) break;
			e + 2 < this.length && c[e + 2] > c[e] && (e += 2);
			if (c[e] > c[f]) d = c[f], c[f] = c[e], c[e] = d, d = c[f + 1], c[f + 1] = c[e + 1], c[e + 1] = d;
			else break;
			f = e
		}
		return {
			index: a,
			value: b,
			length: this.length
		}
	};
	var L = 2,
		x = {
			NONE: 0,
			r: 1,
			j: L,
			N: 3
		},
		N = [];
	for (B = 0; 288 > B; B++) switch (E) {
	case 143 >= B:
		N.push([B + 48, 8]);
		break;
	case 255 >= B:
		N.push([B - 144 + 400, 9]);
		break;
	case 279 >= B:
		N.push([B - 256 + 0, 7]);
		break;
	case 287 >= B:
		N.push([B - 280 + 192, 8]);
		break;
	default:
		a("invalid literal: " + B)
	}
	k.prototype.n = function() {
		var b, c, e, f, k = this.input;
		switch (this.h) {
		case 0:
			e = 0;
			for (f = k.length; e < f;) {
				c = A ? k.subarray(e, e + 65535) : k.slice(e, e + 65535);
				e += c.length;
				var m = e === f,
					n = F,
					u = n = F,
					u = n = F,
					t = this.a,
					x = this.b;
				if (A) {
					for (t = new Uint8Array(this.a.buffer); t.length <= x + c.length + 5;) t = new Uint8Array(t.length << 1);
					t.set(this.a)
				}
				n = m ? 1 : 0;
				t[x++] = n | 0;
				n = c.length;
				u = ~n + 65536 & 65535;
				t[x++] = n & 255;
				t[x++] = n >>> 8 & 255;
				t[x++] = u & 255;
				t[x++] = u >>> 8 & 255;
				if (A) t.set(c, x), x += c.length, t = t.subarray(0, x);
				else {
					n = 0;
					for (u = c.length; n < u; ++n) t[x++] = c[n];
					t.length = x
				}
				this.b = x;
				this.a = t
			}
			break;
		case 1:
			e = new d(new Uint8Array(this.a.buffer), this.b);
			e.d(1, 1, E);
			e.d(1, 2, E);
			k = p(this, k);
			c = 0;
			for (m = k.length; c < m; c++)
			if (f = k[c], d.prototype.d.apply(e, N[f]), 256 < f) e.d(k[++c], k[++c], E), e.d(k[++c], 5), e.d(k[++c], k[++c], E);
			else if (256 === f) break;
			this.a = e.finish();
			this.b = this.a.length;
			break;
		case L:
			f = new d(new Uint8Array(this.a), this.b);
			var v, w, B, G = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
				H, y, n = Array(19),
				D, t = L;
			f.d(1, 1, E);
			f.d(t, 2, E);
			k = p(this, k);
			u = r(this.L, 15);
			H = s(u);
			t = r(this.K, 7);
			x = s(t);
			for (v = 286; 257 < v && 0 === u[v - 1]; v--);
			for (w = 30; 1 < w && 0 === t[w - 1]; w--);
			var z = v,
				J = w;
			b = new(A ? Uint32Array : Array)(z + J);
			var C = new(A ? Uint32Array : Array)(316),
				K, I;
			y = new(A ? Uint8Array : Array)(19);
			for (D = B = 0; D < z; D++) b[B++] = u[D];
			for (D = 0; D < J; D++) b[B++] = t[D];
			if (!A) {
				D = 0;
				for (J = y.length; D < J; ++D) y[D] = 0
			}
			D = K = 0;
			for (J = b.length; D < J; D += B) {
				for (B = 1; D + B < J && b[D + B] === b[D]; ++B);
				z = B;
				if (0 === b[D]) if (3 > z) for (; 0 < z--;) C[K++] = 0, y[0]++;
				else for (; 0 < z;) I = 138 > z ? z : 138, I > z - 3 && I < z && (I = z - 3), 10 >= I ? (C[K++] = 17, C[K++] = I - 3, y[17]++) : (C[K++] = 18, C[K++] = I - 11, y[18]++), z -= I;
				else if (C[K++] = b[D], y[b[D]]++, z--, 3 > z) for (; 0 < z--;) C[K++] = b[D], y[b[D]]++;
				else for (; 0 < z;) I = 6 > z ? z : 6, I > z - 3 && I < z && (I = z - 3), C[K++] = 16, C[K++] = I - 3, y[16]++, z -= I
			}
			b = A ? C.subarray(0, K) : C.slice(0, K);
			y = r(y, 7);
			for (D = 0; 19 > D; D++) n[D] = y[G[D]];
			for (B = 19; 4 < B && 0 === n[B - 1]; B--);
			G = s(y);
			f.d(v - 257, 5, E);
			f.d(w - 1, 5, E);
			f.d(B - 4, 4, E);
			for (D = 0; D < B; D++) f.d(n[D], 3, E);
			D = 0;
			for (n = b.length; D < n; D++)
			if (c = b[D], f.d(G[c], y[c], E), 16 <= c) {
				D++;
				switch (c) {
				case 16:
					m = 2;
					break;
				case 17:
					m = 3;
					break;
				case 18:
					m = 7;
					break;
				default:
					a("invalid code: " + c)
				}
				f.d(b[D], m, E)
			}
			m = [H, u];
			x = [x, t];
			c = m[0];
			m = m[1];
			t = x[0];
			H = x[1];
			x = 0;
			for (n = k.length; x < n; ++x)
			if (e = k[x], f.d(c[e], m[e], E), 256 < e) f.d(k[++x], k[++x], E), u = k[++x], f.d(t[u], H[u], E), f.d(k[++x], k[++x], E);
			else if (256 === e) break;
			this.a = f.finish();
			this.b = this.a.length;
			break;
		default:
			a("invalid compression type")
		}
		return this.a
	};
	B = [];
	var M;
	for (M = 3; 258 >= M; M++) G = n(), B[M] = G[2] << 24 | G[1] << 16 | G[0];
	var P = A ? new Uint32Array(B) : B,
		I = x;
	u.prototype.n = function() {
		var b, d, e, f, k = 0;
		f = this.a;
		b = T;
		switch (b) {
		case T:
			d = Math.LOG2E * Math.log(32768) - 8;
			break;
		default:
			a(Error("invalid compression method"))
		}
		d = d << 4 | b;
		f[k++] = d;
		switch (b) {
		case T:
			switch (this.h) {
			case I.NONE:
				e = 0;
				break;
			case I.r:
				e = 1;
				break;
			case I.j:
				e = 2;
				break;
			default:
				a(Error("unsupported compression type"))
			}
			break;
		default:
			a(Error("invalid compression method"))
		}
		b = e << 6 | 0;
		f[k++] = b | 31 - (256 * d + b) % 31;
		b = c(this.input);
		this.z.b = k;
		f = this.z.n();
		k = f.length;
		A && (f = new Uint8Array(f.buffer), f.length <= k + 4 && (this.a = new Uint8Array(f.length + 4), this.a.set(f), f = this.a), f = f.subarray(0, k + 4));
		f[k++] = b >> 24 & 255;
		f[k++] = b >> 16 & 255;
		f[k++] = b >> 8 & 255;
		f[k++] = b & 255;
		return f
	};
	b("Zlib.Deflate", u);
	b("Zlib.Deflate.compress", function(a, b) {
		return (new u(a, b)).n()
	});
	b("Zlib.Deflate.CompressionType", I);
	b("Zlib.Deflate.CompressionType.NONE", I.NONE);
	b("Zlib.Deflate.CompressionType.FIXED", I.r);
	b("Zlib.Deflate.CompressionType.DYNAMIC", I.j);
	var K = 0,
		O = 1,
		x = {
			D: K,
			C: O
		};
	t.prototype.p = function() {
		for (; !this.s;) {
			var b = w(this, 3);
			b & 1 && (this.s = E);
			b >>>= 1;
			switch (b) {
			case 0:
				var b = this.input,
					c = this.c,
					d = this.a,
					e = this.b,
					f = F,
					k = F,
					m = F,
					n = d.length,
					f = F;
				this.e = this.g = 0;
				f = b[c++];
				f === F && a(Error("invalid uncompressed block header: LEN (first byte)"));
				k = f;
				f = b[c++];
				f === F && a(Error("invalid uncompressed block header: LEN (second byte)"));
				k |= f << 8;
				f = b[c++];
				f === F && a(Error("invalid uncompressed block header: NLEN (first byte)"));
				m = f;
				f = b[c++];
				f === F && a(Error("invalid uncompressed block header: NLEN (second byte)"));
				m |= f << 8;
				k === ~m && a(Error("invalid uncompressed block header: length verify"));
				c + k > b.length && a(Error("input buffer is broken"));
				switch (this.m) {
				case K:
					for (; e + k > d.length;) {
						f = n - e;
						k -= f;
						if (A) d.set(b.subarray(c, c + f), e), e += f, c += f;
						else for (; f--;) d[e++] = b[c++];
						this.b = e;
						d = this.f();
						e = this.b
					}
					break;
				case O:
					for (; e + k > d.length;) d = this.f({
						v: 2
					});
					break;
				default:
					a(Error("invalid inflate mode"))
				}
				if (A) d.set(b.subarray(c, c + k), e), e += k, c += k;
				else for (; k--;) d[e++] = b[c++];
				this.c = c;
				this.b = e;
				this.a = d;
				break;
			case 1:
				this.o(W, X);
				break;
			case 2:
				y(this);
				break;
			default:
				a(Error("unknown BTYPE: " + b))
			}
		}
		return this.t()
	};
	B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	var Q = A ? new Uint16Array(B) : B;
	B = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
	var R = A ? new Uint16Array(B) : B;
	B = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
	var S = A ? new Uint8Array(B) : B;
	B = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
	var V = A ? new Uint16Array(B) : B;
	B = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	var U = A ? new Uint8Array(B) : B;
	B = new(A ? Uint8Array : Array)(288);
	G = 0;
	for (D = B.length; G < D; ++G) B[G] = 143 >= G ? 8 : 255 >= G ? 9 : 279 >= G ? 7 : 8;
	var W = f(B);
	B = new(A ? Uint8Array : Array)(30);
	G = 0;
	for (D = B.length; G < D; ++G) B[G] = 5;
	var X = f(B);
	t.prototype.o = function(a, b) {
		var c = this.a,
			d = this.b;
		this.u = a;
		for (var e = c.length - 258, f, k, m; 256 !== (f = v(this, a));)
		if (256 > f) d >= e && (this.b = d, c = this.f(), d = this.b), c[d++] = f;
		else {
			f -= 257;
			m = R[f];
			0 < S[f] && (m += w(this, S[f]));
			f = v(this, b);
			k = V[f];
			0 < U[f] && (k += w(this, U[f]));
			for (d >= e && (this.b = d, c = this.f(), d = this.b); m--;) c[d] = c[d++-k]
		}
		for (; 8 <= this.e;) this.e -= 8, this.c--;
		this.b = d
	};
	t.prototype.I = function(a, b) {
		var c = this.a,
			d = this.b;
		this.u = a;
		for (var e = c.length, f, k, m; 256 !== (f = v(this, a));)
		if (256 > f) d >= e && (c = this.f(), e = c.length), c[d++] = f;
		else {
			f -= 257;
			m = R[f];
			0 < S[f] && (m += w(this, S[f]));
			f = v(this, b);
			k = V[f];
			0 < U[f] && (k += w(this, U[f]));
			for (d + m > e && (c = this.f(), e = c.length); m--;) c[d] = c[d++-k]
		}
		for (; 8 <= this.e;) this.e -= 8, this.c--;
		this.b = d
	};
	t.prototype.f = function() {
		var a = new(A ? Uint8Array : Array)(this.b - 32768),
			b = this.b - 32768,
			c, d, e = this.a;
		if (A) a.set(e.subarray(32768, a.length));
		else {
			c = 0;
			for (d = a.length; c < d; ++c) a[c] = e[c + 32768]
		}
		this.k.push(a);
		this.q += a.length;
		if (A) e.set(e.subarray(b, b + 32768));
		else for (c = 0; 32768 > c; ++c) e[c] = e[b + c];
		this.b = 32768;
		return e
	};
	t.prototype.J = function(a) {
		var b, c = this.input.length / this.c + 1 | 0,
			d, e, f, k = this.input,
			m = this.a;
		a && ("number" === typeof a.v && (c = a.v), "number" === typeof a.F && (c += a.F));
		2 > c ? (d = (k.length - this.c) / this.u[2], f = 258 * (d / 2) | 0, e = f < m.length ? m.length + f : m.length << 1) : e = m.length * c;
		A ? (b = new Uint8Array(e), b.set(m)) : b = m;
		return this.a = b
	};
	t.prototype.t = function() {
		var a = 0,
			b = this.a,
			c = this.k,
			d, e = new(A ? Uint8Array : Array)(this.q + (this.b - 32768)),
			f, k, m, n;
		if (0 === c.length) return A ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
		f = 0;
		for (k = c.length; f < k; ++f) {
			d = c[f];
			m = 0;
			for (n = d.length; m < n; ++m) e[a++] = d[m]
		}
		f = 32768;
		for (k = this.b; f < k; ++f) e[a++] = b[f];
		this.k = [];
		return this.buffer = e
	};
	t.prototype.H = function() {
		var a, b = this.b;
		A ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a);
		return this.buffer = a
	};
	z.prototype.p = function() {
		var b = this.input,
			d, e;
		d = this.A.p();
		this.c = this.A.c;
		this.M && (e = (b[this.c++] << 24 | b[this.c++] << 16 | b[this.c++] << 8 | b[this.c++]) >>> 0, e !== c(d) && a(Error("invalid adler-32 checksum")));
		return d
	};
	b("Zlib.Inflate", z);
	b("Zlib.Inflate.BufferType", x);
	x.ADAPTIVE = x.C;
	x.BLOCK = x.D;
	b("Zlib.Inflate.prototype.decompress", z.prototype.p);
	x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	A && new Uint16Array(x);
	x = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
	A && new Uint16Array(x);
	x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
	A && new Uint8Array(x);
	x = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
	A && new Uint16Array(x);
	x = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	A && new Uint8Array(x);
	x = new(A ? Uint8Array : Array)(288);
	B = 0;
	for (G = x.length; B < G; ++B) x[B] = 143 >= B ? 8 : 255 >= B ? 9 : 279 >= B ? 7 : 8;
	f(x);
	x = new(A ? Uint8Array : Array)(30);
	B = 0;
	for (G = x.length; B < G; ++B) x[B] = 5;
	f(x);
	var T = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
	ctor: function(a) {
		var b, c, d, e;
		this.data = a;
		this.pos = 8;
		this.palette = [];
		this.imgData = [];
		this.transparency = {};
		this.animation = null;
		this.text = {};
		for (d = null;;) {
			b = this.readUInt32();
			e = a = void 0;
			e = [];
			for (a = 0; 4 > a; ++a) e.push(String.fromCharCode(this.data[this.pos++]));
			a = e.join("");
			switch (a) {
			case "IHDR":
				this.width = this.readUInt32();
				this.height = this.readUInt32();
				this.bits = this.data[this.pos++];
				this.colorType = this.data[this.pos++];
				this.compressionMethod = this.data[this.pos++];
				this.filterMethod = this.data[this.pos++];
				this.interlaceMethod = this.data[this.pos++];
				break;
			case "acTL":
				this.animation = {
					numFrames: this.readUInt32(),
					numPlays: this.readUInt32() || Infinity,
					frames: []
				};
				break;
			case "PLTE":
				this.palette = this.read(b);
				break;
			case "fcTL":
				d && this.animation.frames.push(d);
				this.pos += 4;
				d = {
					width: this.readUInt32(),
					height: this.readUInt32(),
					xOffset: this.readUInt32(),
					yOffset: this.readUInt32()
				};
				a = this.readUInt16();
				b = this.readUInt16() || 100;
				d.delay = 1E3 * a / b;
				d.disposeOp = this.data[this.pos++];
				d.blendOp = this.data[this.pos++];
				d.data = [];
				break;
			case "IDAT":
			case "fdAT":
				"fdAT" === a && (this.pos += 4, b -= 4);
				a = (null != d ? d.data : void 0) || this.imgData;
				for (e = 0; 0 <= b ? e < b : e > b; 0 <= b ? ++e : --e) a.push(this.data[this.pos++]);
				break;
			case "tRNS":
				this.transparency = {};
				switch (this.colorType) {
				case 3:
					this.transparency.indexed = this.read(b);
					b = 255 - this.transparency.indexed.length;
					if (0 < b) for (a = 0; 0 <= b ? a < b : a > b; 0 <= b ? ++a : --a) this.transparency.indexed.push(255);
					break;
				case 0:
					this.transparency.grayscale = this.read(b)[0];
					break;
				case 2:
					this.transparency.rgb = this.read(b)
				}
				break;
			case "tEXt":
				e = this.read(b);
				b = e.indexOf(0);
				a = String.fromCharCode.apply(String, e.slice(0, b));
				this.text[a] = String.fromCharCode.apply(String, e.slice(b + 1));
				break;
			case "IEND":
				d && this.animation.frames.push(d);
				a: {
					switch (this.colorType) {
					case 0:
					case 3:
					case 4:
						d = 1;
						break a;
					case 2:
					case 6:
						d = 3;
						break a
					}
					d = void 0
				}
				this.colors = d;
				this.hasAlphaChannel = 4 === (c = this.colorType) || 6 === c;
				c = this.colors + (this.hasAlphaChannel ? 1 : 0);
				this.pixelBitlength = this.bits * c;
				a: {
					switch (this.colors) {
					case 1:
						c = "DeviceGray";
						break a;
					case 3:
						c = "DeviceRGB";
						break a
					}
					c = void 0
				}
				this.colorSpace = c;
				Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
				return;
			default:
				this.pos += b
			}
			this.pos += 4;
			if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file");
		}
	},
	read: function(a) {
		var b, c;
		c = [];
		for (b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(this.data[this.pos++]);
		return c
	},
	readUInt32: function() {
		var a, b, c, d;
		a = this.data[this.pos++] << 24;
		b = this.data[this.pos++] << 16;
		c = this.data[this.pos++] << 8;
		d = this.data[this.pos++];
		return a | b | c | d
	},
	readUInt16: function() {
		var a, b;
		a = this.data[this.pos++] << 8;
		b = this.data[this.pos++];
		return a | b
	},
	decodePixels: function(a) {
		var b, c, d, e, f, k, m, n, p, r, s, u, t, w, v;
		null == a && (a = this.imgData);
		if (0 === a.length) return new Uint8Array(0);
		a = (new Zlib.Inflate(a, {
			index: 0,
			verify: !1
		})).decompress();
		n = this.pixelBitlength / 8;
		u = n * this.width;
		p = new Uint8Array(u * this.height);
		k = a.length;
		for (c = r = s = 0; r < k;) {
			switch (a[r++]) {
			case 0:
				for (b = 0; b < u; b += 1) p[c++] = a[r++];
				break;
			case 1:
				for (e = t = 0; t < u; e = t += 1) b = a[r++], f = e < n ? 0 : p[c - n], p[c++] = (b + f) % 256;
				break;
			case 2:
				for (e = f = 0; f < u; e = f += 1) b = a[r++], d = (e - e % n) / n, t = s && p[(s - 1) * u + d * n + e % n], p[c++] = (t + b) % 256;
				break;
			case 3:
				for (e = v = 0; v < u; e = v += 1) b = a[r++], d = (e - e % n) / n, f = e < n ? 0 : p[c - n], t = s && p[(s - 1) * u + d * n + e % n], p[c++] = (b + Math.floor((f + t) / 2)) % 256;
				break;
			case 4:
				for (e = v = 0; v < u; e = v += 1) b = a[r++], d = (e - e % n) / n, f = e < n ? 0 : p[c - n], 0 === s ? t = w = 0 : (t = p[(s - 1) * u + d * n + e % n], w = d && p[(s - 1) * u + (d - 1) * n + e % n]), m = f + t - w, e = Math.abs(m - f), d = Math.abs(m - t), m = Math.abs(m - w), f = e <= d && e <= m ? f : d <= m ? t : w, p[c++] = (b + f) % 256;
				break;
			default:
				throw Error("Invalid filter algorithm: " + a[r - 1]);
			}
			s++
		}
		return p
	},
	copyToImageData: function(a, b) {
		var c, d, e, f, k, m, n, p;
		d = this.colors;
		p = null;
		c = this.hasAlphaChannel;
		this.palette.length && (p = null != (e = this._decodedPalette) ? e : this._decodedPalette = this.decodePalette(), d = 4, c = !0);
		e = a.data || a;
		n = e.length;
		k = p || b;
		f = m = 0;
		if (1 === d) for (; f < n;) d = p ? 4 * b[f / 4] : m, m = k[d++], e[f++] = m, e[f++] = m, e[f++] = m, e[f++] = c ? k[d++] : 255, m = d;
		else for (; f < n;) d = p ? 4 * b[f / 4] : m, e[f++] = k[d++], e[f++] = k[d++], e[f++] = k[d++], e[f++] = c ? k[d++] : 255, m = d
	},
	decodePalette: function() {
		var a, b, c, d, e, f, k, m, n;
		c = this.palette;
		f = this.transparency.indexed || [];
		e = new Uint8Array((f.length || 0) + c.length);
		b = k = a = d = 0;
		for (m = c.length; k < m; b = k += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (n = f[a++]) ? n : 255;
		return e
	},
	render: function(a) {
		var b;
		a.width = this.width;
		a.height = this.height;
		a = a.getContext("2d");
		b = a.createImageData(this.width, this.height);
		this.copyToImageData(b, this.decodePixels());
		return a.putImageData(b, 0, 0)
	}
});
cc.tiffReader = {
	_littleEndian: !1,
	_tiffData: null,
	_fileDirectories: [],
	getUint8: function(a) {
		return this._tiffData[a]
	},
	getUint16: function(a) {
		return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
	},
	getUint32: function(a) {
		var b = this._tiffData;
		return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
	},
	checkLittleEndian: function() {
		var a = this.getUint16(0);
		if (18761 === a) this.littleEndian = !0;
		else if (19789 === a) this.littleEndian = !1;
		else throw console.log(a), TypeError("Invalid byte order value.");
		return this.littleEndian
	},
	hasTowel: function() {
		if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
		return !0
	},
	getFieldTypeName: function(a) {
		var b = this.fieldTypeNames;
		return a in b ? b[a] : null
	},
	getFieldTagName: function(a) {
		var b = this.fieldTagNames;
		if (a in b) return b[a];
		console.log("Unknown Field Tag:", a);
		return "Tag" + a
	},
	getFieldTypeLength: function(a) {
		return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
	},
	getFieldValues: function(a, b, c, d) {
		a = [];
		var e = this.getFieldTypeLength(b);
		if (4 >= e * c)!1 === this.littleEndian ? a.push(d >>> 8 * (4 - e)) : a.push(d);
		else for (var f = 0; f < c; f++) {
			var k = e * f;
			8 <= e ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(d + k)), a.push(this.getUint32(d + k + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(e, d + k))
		}
		"ASCII" === b && a.forEach(function(a, b, c) {
			c[b] = String.fromCharCode(a)
		});
		return a
	},
	getBytes: function(a, b) {
		if (0 >= a) cc.log("No bytes requested");
		else {
			if (1 >= a) return this.getUint8(b);
			if (2 >= a) return this.getUint16(b);
			if (3 >= a) return this.getUint32(b) >>> 8;
			if (4 >= a) return this.getUint32(b);
			cc.log("Too many bytes requested")
		}
	},
	getBits: function(a, b, c) {
		c = c || 0;
		b += Math.floor(c / 8);
		var d = c + a;
		a = 32 - a;
		var e, f;
		0 >= d ? console.log("No bits requested") : 8 >= d ? (e = 24 + c, f = this.getUint8(b)) : 16 >= d ? (e = 16 + c, f = this.getUint16(b)) : 32 >= d ? (e = c, f = this.getUint32(b)) : console.log("Too many bits requested");
		return {
			bits: f << e >>> a,
			byteOffset: b + Math.floor(d / 8),
			bitOffset: d % 8
		}
	},
	parseFileDirectory: function(a) {
		var b = this.getUint16(a),
			c = [];
		a += 2;
		for (var d = 0; d < b; a += 12, d++) {
			var e = this.getUint16(a),
				f = this.getUint16(a + 2),
				k = this.getUint32(a + 4),
				m = this.getUint32(a + 8),
				e = this.getFieldTagName(e),
				f = this.getFieldTypeName(f),
				k = this.getFieldValues(e, f, k, m);
			c[e] = {
				type: f,
				values: k
			}
		}
		this._fileDirectories.push(c);
		b = this.getUint32(a);
		0 !== b && this.parseFileDirectory(b)
	},
	clampColorSample: function(a, b) {
		var c = Math.pow(2, 8 - b);
		return Math.floor(a * c + (c - 1))
	},
	parseTIFF: function(a, b) {
		b = b || cc.newElement("canvas");
		this._tiffData = a;
		this.canvas = b;
		this.checkLittleEndian();
		if (this.hasTowel()) {
			var c = this.getUint32(4);
			this._fileDirectories.length = 0;
			this.parseFileDirectory(c);
			var d = this._fileDirectories[0],
				c = d.ImageWidth.values[0],
				e = d.ImageLength.values[0];
			this.canvas.width = c;
			this.canvas.height = e;
			var f = [],
				k = d.Compression ? d.Compression.values[0] : 1,
				m = d.SamplesPerPixel.values[0],
				n = [],
				p = 0,
				r = !1;
			d.BitsPerSample.values.forEach(function(a, b, c) {
				n[b] = {
					bitsPerSample: a,
					hasBytesPerSample: !1,
					bytesPerSample: void 0
				};
				0 === a % 8 && (n[b].hasBytesPerSample = !0, n[b].bytesPerSample = a / 8);
				p += a
			}, this);
			if (0 === p % 8) var r = !0,
				s = p / 8;
			var u = d.StripOffsets.values,
				t = u.length;
			if (d.StripByteCounts) var w = d.StripByteCounts.values;
			else if (cc.log("Missing StripByteCounts!"), 1 === t) w = [Math.ceil(c * e * p / 8)];
			else throw Error("Cannot recover from missing StripByteCounts");
			for (var v = 0; v < t; v++) {
				var y = u[v];
				f[v] = [];
				for (var z = w[v], F = 0, E = 0, C = 1, A = !0, x = [], B = 0, G = 0, D = 0; F < z; F += C) switch (k) {
				case 1:
					C = 0;
					for (x = []; C < m; C++)
					if (n[C].hasBytesPerSample) x.push(this.getBytes(n[C].bytesPerSample, y + F + n[C].bytesPerSample * C));
					else {
						var J = this.getBits(n[C].bitsPerSample, y + F, E);
						x.push(J.bits);
						F = J.byteOffset - y;
						E = J.bitOffset;
						throw RangeError("Cannot handle sub-byte bits per sample");
					}
					f[v].push(x);
					if (r) C = s;
					else throw C = 0, RangeError("Cannot handle sub-byte bits per pixel");
					break;
				case 32773:
					if (A) {
						var A = !1,
							H = 1,
							L = 1,
							C = this.getInt8(y + F);
						0 <= C && 127 >= C ? H = C + 1 : -127 <= C && -1 >= C ? L = -C + 1 : A = !0
					} else {
						for (var N = this.getUint8(y + F), C = 0; C < L; C++) {
							if (n[G].hasBytesPerSample) D = D << 8 * B | N, B++, B === n[G].bytesPerSample && (x.push(D), D = B = 0, G++);
							else throw RangeError("Cannot handle sub-byte bits per sample");
							G === m && (f[v].push(x), x = [], G = 0)
						}
						H--;
						0 === H && (A = !0)
					}
					C = 1
				}
			}
			if (b.getContext) {
				s = this.canvas.getContext("2d");
				s.fillStyle = "rgba(255, 255, 255, 0)";
				v = d.RowsPerStrip ? d.RowsPerStrip.values[0] : e;
				y = f.length;
				e %= v;
				e = 0 === e ? v : e;
				F = v;
				k = 0;
				x = d.PhotometricInterpretation.values[0];
				H = [];
				L = 0;
				d.ExtraSamples && (H = d.ExtraSamples.values, L = H.length);
				if (d.ColorMap) var J = d.ColorMap.values,
					M = Math.pow(2, n[0].bitsPerSample);
				for (v = 0; v < y; v++) {
					v + 1 === y && (F = e);
					d = f[v].length;
					k *= v;
					for (r = m = 0; m < F, r < d; m++)
					for (u = 0; u < c; u++, r++) {
						w = f[v][r];
						A = E = z = 0;
						t = 1;
						if (0 < L) for (z = 0; z < L; z++)
						if (1 === H[z] || 2 === H[z]) {
							t = w[3 + z] / 256;
							break
						}
						switch (x) {
						case 0:
							if (n[0].hasBytesPerSample) var P = Math.pow(16, 2 * n[0].bytesPerSample);
							w.forEach(function(a, b, c) {
								c[b] = P - a
							});
						case 1:
							z = E = A = this.clampColorSample(w[0], n[0].bitsPerSample);
							break;
						case 2:
							z = this.clampColorSample(w[0], n[0].bitsPerSample);
							E = this.clampColorSample(w[1], n[1].bitsPerSample);
							A = this.clampColorSample(w[2], n[2].bitsPerSample);
							break;
						case 3:
							if (void 0 === J) throw Error("Palette image missing color map");
							w = w[0];
							z = this.clampColorSample(J[w], 16);
							E = this.clampColorSample(J[M + w], 16);
							A = this.clampColorSample(J[2 * M + w], 16);
							break;
						default:
							throw RangeError("Unknown Photometric Interpretation:", x);
						}
						s.fillStyle = "rgba(" + z + ", " + E + ", " + A + ", " + t + ")";
						s.fillRect(u, k + m, 1, 1)
					}
					k = F
				}
			}
			return this.canvas
		}
	},
	fieldTagNames: {
		315: "Artist",
		258: "BitsPerSample",
		265: "CellLength",
		264: "CellWidth",
		320: "ColorMap",
		259: "Compression",
		33432: "Copyright",
		306: "DateTime",
		338: "ExtraSamples",
		266: "FillOrder",
		289: "FreeByteCounts",
		288: "FreeOffsets",
		291: "GrayResponseCurve",
		290: "GrayResponseUnit",
		316: "HostComputer",
		270: "ImageDescription",
		257: "ImageLength",
		256: "ImageWidth",
		271: "Make",
		281: "MaxSampleValue",
		280: "MinSampleValue",
		272: "Model",
		254: "NewSubfileType",
		274: "Orientation",
		262: "PhotometricInterpretation",
		284: "PlanarConfiguration",
		296: "ResolutionUnit",
		278: "RowsPerStrip",
		277: "SamplesPerPixel",
		305: "Software",
		279: "StripByteCounts",
		273: "StripOffsets",
		255: "SubfileType",
		263: "Threshholding",
		282: "XResolution",
		283: "YResolution",
		326: "BadFaxLines",
		327: "CleanFaxData",
		343: "ClipPath",
		328: "ConsecutiveBadFaxLines",
		433: "Decode",
		434: "DefaultImageColor",
		269: "DocumentName",
		336: "DotRange",
		321: "HalftoneHints",
		346: "Indexed",
		347: "JPEGTables",
		285: "PageName",
		297: "PageNumber",
		317: "Predictor",
		319: "PrimaryChromaticities",
		532: "ReferenceBlackWhite",
		339: "SampleFormat",
		559: "StripRowCounts",
		330: "SubIFDs",
		292: "T4Options",
		293: "T6Options",
		325: "TileByteCounts",
		323: "TileLength",
		324: "TileOffsets",
		322: "TileWidth",
		301: "TransferFunction",
		318: "WhitePoint",
		344: "XClipPathUnits",
		286: "XPosition",
		529: "YCbCrCoefficients",
		531: "YCbCrPositioning",
		530: "YCbCrSubSampling",
		345: "YClipPathUnits",
		287: "YPosition",
		37378: "ApertureValue",
		40961: "ColorSpace",
		36868: "DateTimeDigitized",
		36867: "DateTimeOriginal",
		34665: "Exif IFD",
		36864: "ExifVersion",
		33434: "ExposureTime",
		41728: "FileSource",
		37385: "Flash",
		40960: "FlashpixVersion",
		33437: "FNumber",
		42016: "ImageUniqueID",
		37384: "LightSource",
		37500: "MakerNote",
		37377: "ShutterSpeedValue",
		37510: "UserComment",
		33723: "IPTC",
		34675: "ICC Profile",
		700: "XMP",
		42112: "GDAL_METADATA",
		42113: "GDAL_NODATA",
		34377: "Photoshop"
	},
	fieldTypeNames: {
		1: "BYTE",
		2: "ASCII",
		3: "SHORT",
		4: "LONG",
		5: "RATIONAL",
		6: "SBYTE",
		7: "UNDEFINED",
		8: "SSHORT",
		9: "SLONG",
		10: "SRATIONAL",
		11: "FLOAT",
		12: "DOUBLE"
	}
};
cc.Particle = function(a, b, c, d, e, f, k, m, n, p, r, s) {
	this.pos = a ? a : cc.p(0, 0);
	this.startPos = b ? b : cc.p(0, 0);
	this.color = c ? c : {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	};
	this.deltaColor = d ? d : {
		r: 0,
		g: 0,
		b: 0,
		a: 255
	};
	this.size = e || 0;
	this.deltaSize = f || 0;
	this.rotation = k || 0;
	this.deltaRotation = m || 0;
	this.timeToLive = n || 0;
	this.atlasIndex = p || 0;
	this.modeA = r ? r : new cc.Particle.ModeA;
	this.modeB = s ? s : new cc.Particle.ModeB;
	this.isChangeColor = !1;
	this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(a, b, c) {
	this.dir = a ? a : cc.p(0, 0);
	this.radialAccel = b || 0;
	this.tangentialAccel = c || 0
};
cc.Particle.ModeB = function(a, b, c, d) {
	this.angle = a || 0;
	this.degreesPerSecond = b || 0;
	this.radius = c || 0;
	this.deltaRadius = d || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
	_className: "ParticleSystem",
	_plistFile: "",
	_elapsed: 0,
	_dontTint: !1,
	modeA: null,
	modeB: null,
	_pointZeroForParticle: cc.p(0, 0),
	_particles: null,
	_emitCounter: 0,
	_particleIdx: 0,
	_batchNode: null,
	atlasIndex: 0,
	_transformSystemDirty: !1,
	_allocatedParticles: 0,
	_isActive: !1,
	particleCount: 0,
	duration: 0,
	_sourcePosition: null,
	_posVar: null,
	life: 0,
	lifeVar: 0,
	angle: 0,
	angleVar: 0,
	startSize: 0,
	startSizeVar: 0,
	endSize: 0,
	endSizeVar: 0,
	_startColor: null,
	_startColorVar: null,
	_endColor: null,
	_endColorVar: null,
	startSpin: 0,
	startSpinVar: 0,
	endSpin: 0,
	endSpinVar: 0,
	emissionRate: 0,
	_totalParticles: 0,
	_texture: null,
	_blendFunc: null,
	_opacityModifyRGB: !1,
	positionType: null,
	autoRemoveOnFinish: !1,
	emitterMode: 0,
	_textureLoaded: null,
	ctor: function(a) {
		cc.Node.prototype.ctor.call(this);
		this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
		this.modeA = new cc.ParticleSystem.ModeA;
		this.modeB = new cc.ParticleSystem.ModeB;
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		this._particles = [];
		this._sourcePosition = cc.p(0, 0);
		this._posVar = cc.p(0, 0);
		this._startColor = cc.color(255, 255, 255, 255);
		this._startColorVar = cc.color(255, 255, 255, 255);
		this._endColor = cc.color(255, 255, 255, 255);
		this._endColorVar = cc.color(255, 255, 255, 255);
		this._plistFile = "";
		this._elapsed = 0;
		this._dontTint = !1;
		this._pointZeroForParticle = cc.p(0, 0);
		this._particleIdx = this._emitCounter = 0;
		this._batchNode = null;
		this.atlasIndex = 0;
		this._transformSystemDirty = !1;
		this._allocatedParticles = 0;
		this._isActive = !1;
		this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
		this._texture = null;
		this._opacityModifyRGB = !1;
		this.positionType = cc.ParticleSystem.TYPE_FREE;
		this.autoRemoveOnFinish = !1;
		this._textureLoaded = !0;
		!a || cc.isNumber(a) ? (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a)) : cc.isString(a) ? this.initWithFile(a) : cc.isObject(a) && this.initWithDictionary(a, "")
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
	},
	ignoreColor: function(a) {
		this._dontTint = a
	},
	initTexCoordsWithRect: function(a) {
		this._renderCmd.initTexCoordsWithRect(a)
	},
	getBatchNode: function() {
		return this._batchNode
	},
	setBatchNode: function(a) {
		this._renderCmd.setBatchNode(a)
	},
	getAtlasIndex: function() {
		return this.atlasIndex
	},
	setAtlasIndex: function(a) {
		this.atlasIndex = a
	},
	getDrawMode: function() {
		return this._renderCmd.getDrawMode()
	},
	setDrawMode: function(a) {
		this._renderCmd.setDrawMode(a)
	},
	getShapeType: function() {
		return this._renderCmd.getShapeType()
	},
	setShapeType: function(a) {
		this._renderCmd.setShapeType(a)
	},
	isActive: function() {
		return this._isActive
	},
	getParticleCount: function() {
		return this.particleCount
	},
	setParticleCount: function(a) {
		this.particleCount = a
	},
	getDuration: function() {
		return this.duration
	},
	setDuration: function(a) {
		this.duration = a
	},
	getSourcePosition: function() {
		return {
			x: this._sourcePosition.x,
			y: this._sourcePosition.y
		}
	},
	setSourcePosition: function(a) {
		this._sourcePosition = a
	},
	getPosVar: function() {
		return {
			x: this._posVar.x,
			y: this._posVar.y
		}
	},
	setPosVar: function(a) {
		this._posVar = a
	},
	getLife: function() {
		return this.life
	},
	setLife: function(a) {
		this.life = a
	},
	getLifeVar: function() {
		return this.lifeVar
	},
	setLifeVar: function(a) {
		this.lifeVar = a
	},
	getAngle: function() {
		return this.angle
	},
	setAngle: function(a) {
		this.angle = a
	},
	getAngleVar: function() {
		return this.angleVar
	},
	setAngleVar: function(a) {
		this.angleVar = a
	},
	getGravity: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
		var a = this.modeA.gravity;
		return cc.p(a.x, a.y)
	},
	setGravity: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
		this.modeA.gravity = a
	},
	getSpeed: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
		return this.modeA.speed
	},
	setSpeed: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
		this.modeA.speed = a
	},
	getSpeedVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
		return this.modeA.speedVar
	},
	setSpeedVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
		this.modeA.speedVar = a
	},
	getTangentialAccel: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
		return this.modeA.tangentialAccel
	},
	setTangentialAccel: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
		this.modeA.tangentialAccel = a
	},
	getTangentialAccelVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
		return this.modeA.tangentialAccelVar
	},
	setTangentialAccelVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
		this.modeA.tangentialAccelVar = a
	},
	getRadialAccel: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
		return this.modeA.radialAccel
	},
	setRadialAccel: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
		this.modeA.radialAccel = a
	},
	getRadialAccelVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
		return this.modeA.radialAccelVar
	},
	setRadialAccelVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
		this.modeA.radialAccelVar = a
	},
	getRotationIsDir: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
		return this.modeA.rotationIsDir
	},
	setRotationIsDir: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
		this.modeA.rotationIsDir = a
	},
	getStartRadius: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
		return this.modeB.startRadius
	},
	setStartRadius: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
		this.modeB.startRadius = a
	},
	getStartRadiusVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
		return this.modeB.startRadiusVar
	},
	setStartRadiusVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
		this.modeB.startRadiusVar = a
	},
	getEndRadius: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
		return this.modeB.endRadius
	},
	setEndRadius: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
		this.modeB.endRadius = a
	},
	getEndRadiusVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
		return this.modeB.endRadiusVar
	},
	setEndRadiusVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
		this.modeB.endRadiusVar = a
	},
	getRotatePerSecond: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
		return this.modeB.rotatePerSecond
	},
	setRotatePerSecond: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
		this.modeB.rotatePerSecond = a
	},
	getRotatePerSecondVar: function() {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
		return this.modeB.rotatePerSecondVar
	},
	setRotatePerSecondVar: function(a) {
		this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
		this.modeB.rotatePerSecondVar = a
	},
	setScale: function(a, b) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScale.call(this, a, b)
	},
	setRotation: function(a) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setRotation.call(this, a)
	},
	setScaleX: function(a) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScaleX.call(this, a)
	},
	setScaleY: function(a) {
		this._transformSystemDirty = !0;
		cc.Node.prototype.setScaleY.call(this, a)
	},
	getStartSize: function() {
		return this.startSize
	},
	setStartSize: function(a) {
		this.startSize = a
	},
	getStartSizeVar: function() {
		return this.startSizeVar
	},
	setStartSizeVar: function(a) {
		this.startSizeVar = a
	},
	getEndSize: function() {
		return this.endSize
	},
	setEndSize: function(a) {
		this.endSize = a
	},
	getEndSizeVar: function() {
		return this.endSizeVar
	},
	setEndSizeVar: function(a) {
		this.endSizeVar = a
	},
	getStartColor: function() {
		return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
	},
	setStartColor: function(a) {
		this._startColor = cc.color(a)
	},
	getStartColorVar: function() {
		return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
	},
	setStartColorVar: function(a) {
		this._startColorVar = cc.color(a)
	},
	getEndColor: function() {
		return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
	},
	setEndColor: function(a) {
		this._endColor = cc.color(a)
	},
	getEndColorVar: function() {
		return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
	},
	setEndColorVar: function(a) {
		this._endColorVar = cc.color(a)
	},
	getStartSpin: function() {
		return this.startSpin
	},
	setStartSpin: function(a) {
		this.startSpin = a
	},
	getStartSpinVar: function() {
		return this.startSpinVar
	},
	setStartSpinVar: function(a) {
		this.startSpinVar = a
	},
	getEndSpin: function() {
		return this.endSpin
	},
	setEndSpin: function(a) {
		this.endSpin = a
	},
	getEndSpinVar: function() {
		return this.endSpinVar
	},
	setEndSpinVar: function(a) {
		this.endSpinVar = a
	},
	getEmissionRate: function() {
		return this.emissionRate
	},
	setEmissionRate: function(a) {
		this.emissionRate = a
	},
	getTotalParticles: function() {
		return this._totalParticles
	},
	setTotalParticles: function(a) {
		this._renderCmd.setTotalParticles(a)
	},
	getTexture: function() {
		return this._texture
	},
	setTexture: function(a) {
		a && (a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addEventListener("load", function(a) {
			this._textureLoaded = !0;
			this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
		}, this)))
	},
	getBlendFunc: function() {
		return this._blendFunc
	},
	setBlendFunc: function(a, b) {
		if (void 0 === b) this._blendFunc !== a && (this._blendFunc = a, this._updateBlendFunc());
		else if (this._blendFunc.src !== a || this._blendFunc.dst !== b) this._blendFunc = {
			src: a,
			dst: b
		}, this._updateBlendFunc()
	},
	isOpacityModifyRGB: function() {
		return this._opacityModifyRGB
	},
	setOpacityModifyRGB: function(a) {
		this._opacityModifyRGB = a
	},
	isBlendAdditive: function() {
		return this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE
	},
	setBlendAdditive: function(a) {
		var b = this._blendFunc;
		a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
	},
	getPositionType: function() {
		return this.positionType
	},
	setPositionType: function(a) {
		this.positionType = a
	},
	isAutoRemoveOnFinish: function() {
		return this.autoRemoveOnFinish
	},
	setAutoRemoveOnFinish: function(a) {
		this.autoRemoveOnFinish = a
	},
	getEmitterMode: function() {
		return this.emitterMode
	},
	setEmitterMode: function(a) {
		this.emitterMode = a
	},
	init: function() {
		return this.initWithTotalParticles(150)
	},
	initWithFile: function(a) {
		this._plistFile = a;
		a = cc.loader.getRes(a);
		return !a ? (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1) : this.initWithDictionary(a, "")
	},
	getBoundingBoxToWorld: function() {
		return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
	},
	initWithDictionary: function(a, b) {
		var c = !1,
			d = null,
			d = this._valueForKey,
			e = parseInt(d("maxParticles", a));
		if (this.initWithTotalParticles(e)) {
			this.angle = parseFloat(d("angle", a));
			this.angleVar = parseFloat(d("angleVariance", a));
			this.duration = parseFloat(d("duration", a));
			this._blendFunc.src = parseInt(d("blendFuncSource", a));
			this._blendFunc.dst = parseInt(d("blendFuncDestination", a));
			c = this._startColor;
			c.r = 255 * parseFloat(d("startColorRed", a));
			c.g = 255 * parseFloat(d("startColorGreen", a));
			c.b = 255 * parseFloat(d("startColorBlue", a));
			c.a = 255 * parseFloat(d("startColorAlpha", a));
			c = this._startColorVar;
			c.r = 255 * parseFloat(d("startColorVarianceRed", a));
			c.g = 255 * parseFloat(d("startColorVarianceGreen", a));
			c.b = 255 * parseFloat(d("startColorVarianceBlue", a));
			c.a = 255 * parseFloat(d("startColorVarianceAlpha", a));
			c = this._endColor;
			c.r = 255 * parseFloat(d("finishColorRed", a));
			c.g = 255 * parseFloat(d("finishColorGreen", a));
			c.b = 255 * parseFloat(d("finishColorBlue", a));
			c.a = 255 * parseFloat(d("finishColorAlpha", a));
			c = this._endColorVar;
			c.r = 255 * parseFloat(d("finishColorVarianceRed", a));
			c.g = 255 * parseFloat(d("finishColorVarianceGreen", a));
			c.b = 255 * parseFloat(d("finishColorVarianceBlue", a));
			c.a = 255 * parseFloat(d("finishColorVarianceAlpha", a));
			this.startSize = parseFloat(d("startParticleSize", a));
			this.startSizeVar = parseFloat(d("startParticleSizeVariance", a));
			this.endSize = parseFloat(d("finishParticleSize", a));
			this.endSizeVar = parseFloat(d("finishParticleSizeVariance", a));
			this.setPosition(parseFloat(d("sourcePositionx", a)), parseFloat(d("sourcePositiony", a)));
			this._posVar.x = parseFloat(d("sourcePositionVariancex", a));
			this._posVar.y = parseFloat(d("sourcePositionVariancey", a));
			this.startSpin = parseFloat(d("rotationStart", a));
			this.startSpinVar = parseFloat(d("rotationStartVariance", a));
			this.endSpin = parseFloat(d("rotationEnd", a));
			this.endSpinVar = parseFloat(d("rotationEndVariance", a));
			this.emitterMode = parseInt(d("emitterType", a));
			if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) c = this.modeA, c.gravity.x = parseFloat(d("gravityx", a)), c.gravity.y = parseFloat(d("gravityy", a)), c.speed = parseFloat(d("speed", a)), c.speedVar = parseFloat(d("speedVariance", a)), e = d("radialAcceleration", a), c.radialAccel = e ? parseFloat(e) : 0, e = d("radialAccelVariance", a), c.radialAccelVar = e ? parseFloat(e) : 0, e = d("tangentialAcceleration", a), c.tangentialAccel = e ? parseFloat(e) : 0, e = d("tangentialAccelVariance", a), c.tangentialAccelVar = e ? parseFloat(e) : 0, e = d("rotationIsDir", a).toLowerCase(), c.rotationIsDir = null != e && ("true" === e || "1" === e);
			else if (this.emitterMode === cc.ParticleSystem.MODE_RADIUS) c = this.modeB, c.startRadius = parseFloat(d("maxRadius", a)), c.startRadiusVar = parseFloat(d("maxRadiusVariance", a)), c.endRadius = parseFloat(d("minRadius", a)), c.endRadiusVar = 0, c.rotatePerSecond = parseFloat(d("rotatePerSecond", a)), c.rotatePerSecondVar = parseFloat(d("rotatePerSecondVariance", a));
			else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
			this.life = parseFloat(d("particleLifespan", a));
			this.lifeVar = parseFloat(d("particleLifespanVariance", a));
			this.emissionRate = this._totalParticles / this.life;
			if (!this._batchNode) if (this._opacityModifyRGB = !1, c = d("textureFileName", a), c = cc.path.changeBasename(this._plistFile, c), e = cc.textureCache.getTextureForKey(c)) this.setTexture(e);
			else if (d = d("textureImageData", a), !d || 0 === d.length) {
				e = cc.textureCache.addImage(c);
				if (!e) return !1;
				this.setTexture(e)
			} else {
				d = cc.unzipBase64AsArray(d, 1);
				if (!d) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
				e = cc.getImageFormatByData(d);
				if (e !== cc.FMT_TIFF && e !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
				var f = cc.newElement("canvas");
				e === cc.FMT_PNG ? (new cc.PNGReader(d)).render(f) : cc.tiffReader.parseTIFF(d, f);
				cc.textureCache.cacheImage(c, f);
				(d = cc.textureCache.getTextureForKey(c)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
				this.setTexture(d)
			}
			c = !0
		}
		return c
	},
	initWithTotalParticles: function(a) {
		this._totalParticles = a;
		var b, c = this._particles;
		for (b = c.length = 0; b < a; b++) c[b] = new cc.Particle;
		if (!c) return cc.log("Particle system: not enough memory"), !1;
		this._allocatedParticles = a;
		if (this._batchNode) for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
		this._isActive = !0;
		this._blendFunc.src = cc.BLEND_SRC;
		this._blendFunc.dst = cc.BLEND_DST;
		this.positionType = cc.ParticleSystem.TYPE_FREE;
		this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
		this._transformSystemDirty = this.autoRemoveOnFinish = !1;
		this.scheduleUpdateWithPriority(1);
		this._renderCmd._initWithTotalParticles(a);
		return !0
	},
	destroyParticleSystem: function() {
		this.unscheduleUpdate()
	},
	addParticle: function() {
		if (this.isFull()) return !1;
		var a = this._renderCmd.addParticle();
		this.initParticle(a);
		++this.particleCount;
		return !0
	},
	initParticle: function(a) {
		var b = cc.randomMinus1To1;
		a.timeToLive = this.life + this.lifeVar * b();
		a.timeToLive = Math.max(0, a.timeToLive);
		a.pos.x = this._sourcePosition.x + this._posVar.x * b();
		a.pos.y = this._sourcePosition.y + this._posVar.y * b();
		var c, d;
		c = this._startColor;
		var e = this._startColorVar,
			f = this._endColor;
		d = this._endColorVar;
		c = {
			r: cc.clampf(c.r + e.r * b(), 0, 255),
			g: cc.clampf(c.g + e.g * b(), 0, 255),
			b: cc.clampf(c.b + e.b * b(), 0, 255),
			a: cc.clampf(c.a + e.a * b(), 0, 255)
		};
		d = {
			r: cc.clampf(f.r + d.r * b(), 0, 255),
			g: cc.clampf(f.g + d.g * b(), 0, 255),
			b: cc.clampf(f.b + d.b * b(), 0, 255),
			a: cc.clampf(f.a + d.a * b(), 0, 255)
		};
		a.color = c;
		e = a.deltaColor;
		f = a.timeToLive;
		e.r = (d.r - c.r) / f;
		e.g = (d.g - c.g) / f;
		e.b = (d.b - c.b) / f;
		e.a = (d.a - c.a) / f;
		c = this.startSize + this.startSizeVar * b();
		c = Math.max(0, c);
		a.size = c;
		this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (d = this.endSize + this.endSizeVar * b(), d = Math.max(0, d), a.deltaSize = (d - c) / f);
		c = this.startSpin + this.startSpinVar * b();
		d = this.endSpin + this.endSpinVar * b();
		a.rotation = c;
		a.deltaRotation = (d - c) / f;
		this.positionType === cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
		c = cc.degreesToRadians(this.angle + this.angleVar * b());
		if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) f = this.modeA, d = a.modeA, e = f.speed + f.speedVar * b(), d.dir.x = Math.cos(c), d.dir.y = Math.sin(c), cc.pMultIn(d.dir, e), d.radialAccel = f.radialAccel + f.radialAccelVar * b(), d.tangentialAccel = f.tangentialAccel + f.tangentialAccelVar * b(), f.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(d.dir)));
		else {
			d = this.modeB;
			a = a.modeB;
			var e = d.startRadius + d.startRadiusVar * b(),
				k = d.endRadius + d.endRadiusVar * b();
			a.radius = e;
			a.deltaRadius = d.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (k - e) / f;
			a.angle = c;
			a.degreesPerSecond = cc.degreesToRadians(d.rotatePerSecond + d.rotatePerSecondVar * b())
		}
	},
	stopSystem: function() {
		this._isActive = !1;
		this._elapsed = this.duration;
		this._emitCounter = 0
	},
	resetSystem: function() {
		this._isActive = !0;
		this._elapsed = 0;
		var a = this._particles;
		for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive = 0
	},
	isFull: function() {
		return this.particleCount >= this._totalParticles
	},
	updateQuadWithParticle: function(a, b) {
		this._renderCmd.updateQuadWithParticle(a, b)
	},
	postStep: function() {
		this._renderCmd.postStep()
	},
	update: function(a) {
		if (this._isActive && this.emissionRate) {
			var b = 1 / this.emissionRate;
			this.particleCount < this._totalParticles && (this._emitCounter += a);
			for (; this.particleCount < this._totalParticles && this._emitCounter > b;) this.addParticle(), this._emitCounter -= b;
			this._elapsed += a; - 1 !== this.duration && this.duration < this._elapsed && this.stopSystem()
		}
		this._particleIdx = 0;
		b = cc.Particle.TemporaryPoints[0];
		this.positionType === cc.ParticleSystem.TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y);
		if (this._visible) {
			for (var c = cc.Particle.TemporaryPoints[1], d = cc.Particle.TemporaryPoints[2], e = cc.Particle.TemporaryPoints[3], f = this._particles; this._particleIdx < this.particleCount;) {
				cc.pZeroIn(c);
				cc.pZeroIn(d);
				cc.pZeroIn(e);
				var k = f[this._particleIdx];
				k.timeToLive -= a;
				if (0 < k.timeToLive) {
					if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
						var m = e,
							n = c,
							p = d;
						k.pos.x || k.pos.y ? (cc.pIn(n, k.pos), cc.pNormalizeIn(n)) : cc.pZeroIn(n);
						cc.pIn(p, n);
						cc.pMultIn(n, k.modeA.radialAccel);
						var r = p.x;
						p.x = -p.y;
						p.y = r;
						cc.pMultIn(p, k.modeA.tangentialAccel);
						cc.pIn(m, n);
						cc.pAddIn(m, p);
						cc.pAddIn(m, this.modeA.gravity);
						cc.pMultIn(m, a);
						cc.pAddIn(k.modeA.dir, m);
						cc.pIn(m, k.modeA.dir);
						cc.pMultIn(m, a);
						cc.pAddIn(k.pos, m)
					} else m = k.modeB, m.angle += m.degreesPerSecond * a, m.radius += m.deltaRadius * a, k.pos.x = -Math.cos(m.angle) * m.radius, k.pos.y = -Math.sin(m.angle) * m.radius;
					this._renderCmd._updateDeltaColor(k, a);
					k.size += k.deltaSize * a;
					k.size = Math.max(0, k.size);
					k.rotation += k.deltaRotation * a;
					m = c;
					this.positionType === cc.ParticleSystem.TYPE_FREE || this.positionType === cc.ParticleSystem.TYPE_RELATIVE ? (n = d, cc.pIn(n, b), cc.pSubIn(n, k.startPos), cc.pIn(m, k.pos), cc.pSubIn(m, n)) : cc.pIn(m, k.pos);
					this._batchNode && (m.x += this._position.x, m.y += this._position.y);
					this._renderCmd.updateParticlePosition(k, m);
					++this._particleIdx
				} else if (k = k.atlasIndex, this._particleIdx !== this.particleCount - 1 && (m = f[this._particleIdx], f[this._particleIdx] = f[this.particleCount - 1], f[this.particleCount - 1] = m), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + k), f[this.particleCount - 1].atlasIndex = k), --this.particleCount, 0 === this.particleCount && this.autoRemoveOnFinish) {
					this.unscheduleUpdate();
					this._parent.removeChild(this, !0);
					return
				}
			}
			this._transformSystemDirty = !1
		}
		this._batchNode || this.postStep()
	},
	updateWithNoTime: function() {
		this.update(0)
	},
	_valueForKey: function(a, b) {
		if (b) {
			var c = b[a];
			return null != c ? c : ""
		}
		return ""
	},
	_updateBlendFunc: function() {
		if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
		else {
			var a = this._texture;
			if (a && a instanceof cc.Texture2D) {
				this._opacityModifyRGB = !1;
				var b = this._blendFunc;
				b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
			}
		}
	},
	clone: function() {
		var a = new cc.ParticleSystem;
		if (a.initWithTotalParticles(this.getTotalParticles())) {
			a.setAngle(this.getAngle());
			a.setAngleVar(this.getAngleVar());
			a.setDuration(this.getDuration());
			var b = this.getBlendFunc();
			a.setBlendFunc(b.src, b.dst);
			a.setStartColor(this.getStartColor());
			a.setStartColorVar(this.getStartColorVar());
			a.setEndColor(this.getEndColor());
			a.setEndColorVar(this.getEndColorVar());
			a.setStartSize(this.getStartSize());
			a.setStartSizeVar(this.getStartSizeVar());
			a.setEndSize(this.getEndSize());
			a.setEndSizeVar(this.getEndSizeVar());
			a.setPosition(cc.p(this.x, this.y));
			a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
			a.setPositionType(this.getPositionType());
			a.setStartSpin(this.getStartSpin() || 0);
			a.setStartSpinVar(this.getStartSpinVar() || 0);
			a.setEndSpin(this.getEndSpin() || 0);
			a.setEndSpinVar(this.getEndSpinVar() || 0);
			a.setEmitterMode(this.getEmitterMode());
			this.getEmitterMode() === cc.ParticleSystem.MODE_GRAVITY ? (b = this.getGravity(), a.setGravity(cc.p(b.x, b.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()), a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() === cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar()));
			a.setLife(this.getLife());
			a.setLifeVar(this.getLifeVar());
			a.setEmissionRate(this.getEmissionRate());
			if (!this.getBatchNode() && (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), b = this.getTexture())) {
				var c = b.getContentSize();
				a.setTextureWithRect(b, cc.rect(0, 0, c.width, c.height))
			}
		}
		return a
	},
	setDisplayFrame: function(a) {
		if (a) {
			var b = a.getOffsetInPixels();
			(0 !== b.x || 0 !== b.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
			a = a.getTexture();
			this._texture !== a && this.setTexture(a)
		}
	},
	setTextureWithRect: function(a, b) {
		this._texture !== a && (this._texture = a, this._updateBlendFunc());
		this.initTexCoordsWithRect(b)
	},
	listenBackToForeground: function(a) {}
});
_p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(a) {
	return new cc.ParticleSystem(a)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(a, b, c, d, e, f, k, m) {
	this.gravity = a ? a : cc.p(0, 0);
	this.speed = b || 0;
	this.speedVar = c || 0;
	this.tangentialAccel = d || 0;
	this.tangentialAccelVar = e || 0;
	this.radialAccel = f || 0;
	this.radialAccelVar = k || 0;
	this.rotationIsDir = m || !1
};
cc.ParticleSystem.ModeB = function(a, b, c, d, e, f) {
	this.startRadius = a || 0;
	this.startRadiusVar = b || 0;
	this.endRadius = c || 0;
	this.endRadiusVar = d || 0;
	this.rotatePerSecond = e || 0;
	this.rotatePerSecondVar = f || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
(function() {
	cc.ParticleSystem.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._drawMode = cc.ParticleSystem.TEXTURE_MODE;
		this._shapeType = cc.ParticleSystem.BALL_SHAPE;
		this._pointRect = cc.rect(0, 0, 0, 0)
	};
	var a = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ParticleSystem.CanvasRenderCmd;
	a.getDrawMode = function() {
		return this._drawMode
	};
	a.setDrawMode = function(a) {
		this._drawMode = a
	};
	a.getShapeType = function() {
		return this._shapeType
	};
	a.setShapeType = function(a) {
		this._shapeType = a
	};
	a.setBatchNode = function(a) {
		this._batchNode !== a && (this._node._batchNode = a)
	};
	a.updateQuadWithParticle = function(a, c) {};
	a.updateParticlePosition = function(a, c) {
		cc.pIn(a.drawPos, c)
	};
	a.rendering = function(a, c, d) {
		a = a || cc._renderContext;
		var e = a.getContext(),
			f = this._node,
			k = this._pointRect;
		a.setTransform(this._worldTransform, c, d);
		a.save();
		f.isBlendAdditive() ? e.globalCompositeOperation = "lighter" : e.globalCompositeOperation = "source-over";
		var m, n;
		d = this._node.particleCount;
		var p = this._node._particles;
		if (f.drawMode !== cc.ParticleSystem.SHAPE_MODE && f._texture) {
			if (!f._texture._textureLoaded) {
				a.restore();
				return
			}
			f = f._texture.getHtmlElementObj();
			if (!f.width || !f.height) {
				a.restore();
				return
			}
			m = f;
			for (c = 0; c < d; c++)
			if (m = p[c], n = m.color.a / 255, 0 !== n) {
				e.globalAlpha = n;
				e.save();
				e.translate(0 | m.drawPos.x, -(0 | m.drawPos.y));
				var r = 4 * Math.floor(m.size / 4);
				n = k.width;
				var s = k.height;
				e.scale(Math.max(1 / n * r, 1E-6), Math.max(1 / s * r, 1E-6));
				m.rotation && e.rotate(cc.degreesToRadians(m.rotation));
				m = m.isChangeColor ? this._changeTextureColor(f, m.color, this._pointRect) : f;
				e.drawImage(m, -(0 | n / 2), -(0 | s / 2));
				e.restore()
			}
		} else {
			s = cc._drawingUtil;
			for (c = 0; c < d; c++) m = p[c], k = 0 | 0.5 * m.size, n = m.color.a / 255, 0 !== n && (e.globalAlpha = n, e.save(), e.translate(0 | m.drawPos.x, -(0 | m.drawPos.y)), f.shapeType === cc.ParticleSystem.STAR_SHAPE ? (m.rotation && e.rotate(cc.degreesToRadians(m.rotation)), s.drawStar(a, k, m.color)) : s.drawColorBall(a, k, m.color), e.restore())
		}
		a.restore();
		cc.g_NumberOfDraws++
	};
	a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ?
	function(a, c, d) {
		a.tintCache || (a.tintCache = document.createElement("canvas"), a.tintCache.width = a.width, a.tintCache.height = a.height);
		return cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(a, c, d, a.tintCache)
	} : function(a, c, d) {
		var e = cc.textureCache.getTextureColors(a);
		return e ? (e.tintCache || (e.tintCache = document.createElement("canvas"), e.tintCache.width = a.width, e.tintCache.height = a.height), cc.Sprite.CanvasRenderCmd._generateTintImage(a, e, c, d, e.tintCache), e.tintCache) : null
	};
	a.initTexCoordsWithRect = function(a) {
		this._pointRect = a
	};
	a.setTotalParticles = function(a) {
		this._node._totalParticles = 200 > a ? a : 200
	};
	a.addParticle = function() {
		var a = this._node,
			c = a._particles;
		a.particleCount < c.length ? a = c[a.particleCount] : (a = new cc.Particle, c.push(a));
		return a
	};
	a._setupVBO = function() {};
	a._allocMemory = function() {
		return !0
	};
	a.postStep = function() {};
	a._setBlendAdditive = function() {
		var a = this._node._blendFunc;
		a.src = cc.BLEND_SRC;
		a.dst = cc.BLEND_DST
	};
	a._initWithTotalParticles = function(a) {};
	a._updateDeltaColor = function(a, c) {
		this._node._dontTint || (a.color.r += a.deltaColor.r * c, a.color.g += a.deltaColor.g * c, a.color.b += a.deltaColor.b * c, a.color.a += a.deltaColor.a * c, a.isChangeColor = !0)
	}
})();
(function() {
	cc.ParticleSystem.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0;
		this._buffersVBO = [0, 0];
		this._quads = [];
		this._indices = [];
		this._quadsArrayBuffer = null
	};
	var a = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.ParticleSystem.WebGLRenderCmd;
	a.getDrawMode = function() {};
	a.setDrawMode = function(a) {};
	a.getShapeType = function() {};
	a.setShapeType = function(a) {};
	a.setBatchNode = function(a) {
		var c = this._node;
		if (c._batchNode !== a) {
			var d = c._batchNode;
			if (c._batchNode = a) for (var e = c._particles, f = 0; f < c._totalParticles; f++) e[f].atlasIndex = f;
			a ? d || (c._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, c.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(c._totalParticles), c.setTexture(d.getTexture()), this._setupVBO())
		}
	};
	a.initIndices = function(a) {
		for (var c = this._indices, d = 0; d < a; ++d) {
			var e = 6 * d,
				f = 4 * d;
			c[e + 0] = f + 0;
			c[e + 1] = f + 1;
			c[e + 2] = f + 2;
			c[e + 5] = f + 1;
			c[e + 4] = f + 2;
			c[e + 3] = f + 3
		}
	};
	a.isDifferentTexture = function(a, c) {
		return a === c
	};
	a.updateParticlePosition = function(a, c) {
		this.updateQuadWithParticle(a, c)
	};
	a.updateQuadWithParticle = function(a, c) {
		var d = null,
			e = this._node;
		e._batchNode ? (d = e._batchNode.textureAtlas.quads[e.atlasIndex + a.atlasIndex], e._batchNode.textureAtlas.dirty = !0) : d = this._quads[e._particleIdx];
		var f, k, m;
		e._opacityModifyRGB ? (e = 0 | a.color.r * a.color.a / 255, f = 0 | a.color.g * a.color.a / 255, k = 0 | a.color.b * a.color.a / 255) : (e = 0 | a.color.r, f = 0 | a.color.g, k = 0 | a.color.b);
		m = 0 | a.color.a;
		var n = d.bl.colors,
			p = d.br.colors,
			r = d.tl.colors,
			s = d.tr.colors;
		n.r = p.r = r.r = s.r = e;
		n.g = p.g = r.g = s.g = f;
		n.b = p.b = r.b = s.b = k;
		n.a = p.a = r.a = s.a = m;
		e = a.size / 2;
		a.rotation ? (f = -e, k = -e, m = c.x, n = c.y, r = -cc.degreesToRadians(a.rotation), p = Math.cos(r), r = Math.sin(r), d.bl.vertices.x = f * p - k * r + m, d.bl.vertices.y = f * r + k * p + n, d.br.vertices.x = e * p - k * r + m, d.br.vertices.y = e * r + k * p + n, d.tl.vertices.x = f * p - e * r + m, d.tl.vertices.y = f * r + e * p + n, d.tr.vertices.x = e * p - e * r + m, d.tr.vertices.y = e * r + e * p + n) : (d.bl.vertices.x = c.x - e, d.bl.vertices.y = c.y - e, d.br.vertices.x = c.x + e, d.br.vertices.y = c.y - e, d.tl.vertices.x = c.x - e, d.tl.vertices.y = c.y + e, d.tr.vertices.x = c.x + e, d.tr.vertices.y = c.y + e)
	};
	a.rendering = function(a) {
		var c = this._node;
		c._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBindTexture2D(c._texture), cc.glBlendFuncForParticle(c._blendFunc.src, c._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * c._particleIdx, a.UNSIGNED_SHORT, 0))
	};
	a.initTexCoordsWithRect = function(a) {
		var c = this._node,
			d = c.texture,
			e = cc.contentScaleFactor(),
			f = cc.rect(a.x * e, a.y * e, a.width * e, a.height * e),
			e = a.width,
			k = a.height;
		d && (e = d.pixelsWidth, k = d.pixelsHeight);
		cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (d = (2 * f.x + 1) / (2 * e), a = (2 * f.y + 1) / (2 * k), e = d + (2 * f.width - 2) / (2 * e), f = a + (2 * f.height - 2) / (2 * k)) : (d = f.x / e, a = f.y / k, e = d + f.width / e, f = a + f.height / k);
		k = f;
		f = a;
		a = k;
		var m = 0,
			n = 0;
		c._batchNode ? (k = c._batchNode.textureAtlas.quads, m = c.atlasIndex, n = c.atlasIndex + c._totalParticles) : (k = this._quads, m = 0, n = c._totalParticles);
		for (c = m; c < n; c++) k[c] || (k[c] = cc.V3F_C4B_T2F_QuadZero()), m = k[c], m.bl.texCoords.u = d, m.bl.texCoords.v = a, m.br.texCoords.u = e, m.br.texCoords.v = a, m.tl.texCoords.u = d, m.tl.texCoords.v = f, m.tr.texCoords.u = e, m.tr.texCoords.v = f
	};
	a.setTotalParticles = function(a) {
		var c = this._node;
		if (a > c._allocatedParticles) {
			var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
			this._indices = new Uint16Array(6 * a);
			var e = new ArrayBuffer(a * d),
				f = c._particles;
			f.length = 0;
			for (var k = this._quads, m = k.length = 0; m < a; m++) f[m] = new cc.Particle, k[m] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, m * d);
			c._allocatedParticles = a;
			c._totalParticles = a;
			if (c._batchNode) for (d = 0; d < a; d++) f[d].atlasIndex = d;
			this._quadsArrayBuffer = e;
			this.initIndices(a);
			this._setupVBO();
			c._texture && this.initTexCoordsWithRect(cc.rect(0, 0, c._texture.width, c._texture.height))
		} else c._totalParticles = a;
		c.resetSystem()
	};
	a.addParticle = function() {
		var a = this._node;
		return a._particles[a.particleCount]
	};
	a._setupVBO = function() {
		var a = cc._renderContext;
		this._buffersVBO[0] = a.createBuffer();
		a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
		this._buffersVBO[1] = a.createBuffer();
		a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
		a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
	};
	a._allocMemory = function() {
		var a = this._node;
		if (a._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
		var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
			a = a._totalParticles,
			d = this._quads;
		d.length = 0;
		this._indices = new Uint16Array(6 * a);
		for (var e = new ArrayBuffer(c * a), f = 0; f < a; f++) d[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, f * c);
		if (!d || !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
		this._quadsArrayBuffer = e;
		return !0
	};
	a.postStep = function() {
		var a = cc._renderContext;
		a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
		a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
	};
	a._setBlendAdditive = function() {
		var a = this._node._blendFunc;
		this._texture && !this._texture.hasPremultipliedAlpha() ? (a.src = cc.SRC_ALPHA, a.dst = cc.ONE_MINUS_SRC_ALPHA) : (a.src = cc.BLEND_SRC, a.dst = cc.BLEND_DST)
	};
	a._initWithTotalParticles = function(a) {
		if (!this._allocMemory()) return !1;
		this.initIndices(a);
		this._setupVBO();
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a._updateDeltaColor = function(a, c) {
		a.color.r += a.deltaColor.r * c;
		a.color.g += a.deltaColor.g * c;
		a.color.b += a.deltaColor.b * c;
		a.color.a += a.deltaColor.a * c;
		a.isChangeColor = !0
	}
})();
cc.ParticleFire = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleFire.create = function() {
	return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleFireworks.create = function() {
	return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
	}
});
cc.ParticleSun.create = function() {
	return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleGalaxy.create = function() {
	return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleFlower.create = function() {
	return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
	}
});
cc.ParticleMeteor.create = function() {
	return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSpiral.create = function() {
	return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleExplosion.create = function() {
	return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSmoke.create = function() {
	return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleSnow.create = function() {
	return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
	ctor: function() {
		cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1E3 : 300)
	},
	initWithTotalParticles: function(a) {
		return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
	}
});
cc.ParticleRain.create = function() {
	return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
	textureAtlas: null,
	_blendFunc: null,
	_className: "ParticleBatchNode",
	ctor: function(a, b) {
		cc.Node.prototype.ctor.call(this);
		this._blendFunc = {
			src: cc.BLEND_SRC,
			dst: cc.BLEND_DST
		};
		cc.isString(a) ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
	},
	initWithTexture: function(a, b) {
		this.textureAtlas = new cc.TextureAtlas;
		this.textureAtlas.initWithTexture(a, b);
		this._children.length = 0;
		this._renderCmd._initWithTexture();
		return !0
	},
	initWithFile: function(a, b) {
		var c = cc.textureCache.addImage(a);
		return this.initWithTexture(c, b)
	},
	init: function(a, b) {
		var c = cc.textureCache.addImage(a);
		return this.initWithTexture(c, b)
	},
	addChild: function(a, b, c) {
		if (!a) throw Error("cc.ParticleBatchNode.addChild() : child should be non-null");
		if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children");
		b = null == b ? a.zIndex : b;
		c = null == c ? a.tag : c;
		if (a.getTexture() !== this.textureAtlas.texture) throw Error("cc.ParticleSystem.addChild() : the child is not using the same texture id");
		var d = a.getBlendFunc();
		if (0 === this._children.length) this.setBlendFunc(d);
		else if (d.src !== this._blendFunc.src || d.dst !== this._blendFunc.dst) {
			cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
			return
		}
		b = this._addChildHelper(a, b, c);
		c = 0;
		0 !== b ? (b = this._children[b - 1], c = b.getAtlasIndex() + b.getTotalParticles()) : c = 0;
		this.insertChild(a, c);
		a.setBatchNode(this)
	},
	insertChild: function(a, b) {
		var c = a.getTotalParticles(),
			d = this.textureAtlas,
			e = d.totalQuads;
		a.setAtlasIndex(b);
		e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c));
		a.getAtlasIndex() + c !== e && d.moveQuadsFromIndex(b, b + c);
		d.increaseTotalQuadsWith(c);
		this._updateAllAtlasIndexes()
	},
	removeChild: function(a, b) {
		if (null != a) {
			if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children");
			if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
			else {
				cc.Node.prototype.removeChild.call(this, a, b);
				var c = this.textureAtlas;
				c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
				c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles());
				a.setBatchNode(null);
				this._updateAllAtlasIndexes()
			}
		}
	},
	reorderChild: function(a, b) {
		if (!a) throw Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
		if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
		if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
		else if (b !== a.zIndex) {
			if (1 < this._children.length) {
				var c = this._getCurrentIndex(a, b);
				if (c.oldIndex !== c.newIndex) {
					this._children.splice(c.oldIndex, 1);
					this._children.splice(c.newIndex, 0, a);
					c = a.getAtlasIndex();
					this._updateAllAtlasIndexes();
					for (var d = 0, e = this._children, f = 0; f < e.length; f++)
					if (e[f] === a) {
						d = a.getAtlasIndex();
						break
					}
					this.textureAtlas.moveQuadsFromIndex(c, a.getTotalParticles(), d);
					a.updateWithNoTime()
				}
			}
			a._setLocalZOrder(b)
		}
	},
	removeChildAtIndex: function(a, b) {
		this.removeChild(this._children[i], b)
	},
	removeAllChildren: function(a) {
		for (var b = this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
		cc.Node.prototype.removeAllChildren.call(this, a);
		this.textureAtlas.removeAllQuads()
	},
	disableParticle: function(a) {
		a = this.textureAtlas.quads[a];
		a.br.vertices.x = a.br.vertices.y = a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
		this.textureAtlas._setDirty(!0)
	},
	getTexture: function() {
		return this.textureAtlas.texture
	},
	setTexture: function(a) {
		this.textureAtlas.texture = a;
		var b = this._blendFunc;
		a && (!a.hasPremultipliedAlpha() && b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST) && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
	},
	setBlendFunc: function(a, b) {
		void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.src = b)
	},
	getBlendFunc: function() {
		return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
	},
	_updateAllAtlasIndexes: function() {
		for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
			var d = b[c];
			d.setAtlasIndex(a);
			a += d.getTotalParticles()
		}
	},
	_increaseAtlasCapacityTo: function(a) {
		cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "].");
		this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
	},
	_searchNewPositionInChildrenForZ: function(a) {
		for (var b = this._children, c = b.length, d = 0; d < c; d++)
		if (b[d].zIndex > a) return d;
		return c
	},
	_getCurrentIndex: function(a, b) {
		for (var c = !1, d = !1, e = 0, f = 0, k = 0, m = this._children, n = m.length, p = 0; p < n; p++) {
			var r = m[p];
			if (r.zIndex > b && !d && (e = p, d = !0, c && d)) break;
			if (a === r && (f = p, c = !0, d || (k = -1), c && d)) break
		}
		d || (e = n);
		return {
			newIndex: e + k,
			oldIndex: f
		}
	},
	_addChildHelper: function(a, b, c) {
		if (!a) throw Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
		if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
		this._children || (this._children = []);
		var d = this._searchNewPositionInChildrenForZ(b);
		this._children.splice(d, 0, a);
		a.tag = c;
		a._setLocalZOrder(b);
		a.parent = this;
		this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
		return d
	},
	_updateBlendFunc: function() {
		this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
	},
	getTextureAtlas: function() {
		return this.textureAtlas
	},
	setTextureAtlas: function(a) {
		this.textureAtlas = a
	}
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(a, b) {
	return new cc.ParticleBatchNode(a, b)
};
(function() {
	cc.ParticleBatchNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !1
	};
	var a = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
	a._initWithTexture = function() {}
})();
(function() {
	cc.ParticleBatchNode.WebGLRenderCmd = function(a) {
		cc.Node.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
	a.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
	a.rendering = function(a) {
		a = this._node;
		0 !== a.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFuncForParticle(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
	};
	a._initWithTexture = function() {
		this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
	};
	a.visit = function(a) {
		if (this._node._visible) {
			var c = cc.current_stack;
			c.stack.push(c.top);
			this._syncStatus(a);
			c.top = this._stackMatrix;
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0;
			cc.kmGLPopMatrix()
		}
	}
})();
cc.IMEKeyboardNotificationInfo = function(a, b, c) {
	this.begin = a || cc.rect(0, 0, 0, 0);
	this.end = b || cc.rect(0, 0, 0, 0);
	this.duration = c || 0
};
cc.IMEDelegate = cc.Class.extend({
	ctor: function() {
		cc.imeDispatcher.addDelegate(this)
	},
	removeDelegate: function() {
		cc.imeDispatcher.removeDelegate(this)
	},
	attachWithIME: function() {
		return cc.imeDispatcher.attachDelegateWithIME(this)
	},
	detachWithIME: function() {
		return cc.imeDispatcher.detachDelegateWithIME(this)
	},
	canAttachWithIME: function() {
		return !1
	},
	didAttachWithIME: function() {},
	canDetachWithIME: function() {
		return !1
	},
	didDetachWithIME: function() {},
	insertText: function(a, b) {},
	deleteBackward: function() {},
	getContentText: function() {
		return ""
	},
	keyboardWillShow: function(a) {},
	keyboardDidShow: function(a) {},
	keyboardWillHide: function(a) {},
	keyboardDidHide: function(a) {}
});
cc.IMEDispatcher = cc.Class.extend({
	_domInputControl: null,
	impl: null,
	_currentInputString: "",
	_lastClickPosition: null,
	ctor: function() {
		this.impl = new cc.IMEDispatcher.Impl;
		this._lastClickPosition = cc.p(0, 0)
	},
	init: function() {
		if (!cc.sys.isMobile) {
			this._domInputControl = cc.$("#imeDispatcherInput");
			this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
			var a = this;
			cc._addEventListener(this._domInputControl, "input", function() {
				a._processDomInputString(a._domInputControl.value)
			}, !1);
			cc._addEventListener(this._domInputControl, "keydown", function(b) {
				b.keyCode === cc.KEY.tab ? (b.stopPropagation(), b.preventDefault()) : b.keyCode === cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
			}, !1);
			/msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(b) {
				b.keyCode === cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
			}, !1);
			cc._addEventListener(window, "mousedown", function(b) {
				var c = b.pageY || 0;
				a._lastClickPosition.x = b.pageX || 0;
				a._lastClickPosition.y = c
			}, !1)
		}
	},
	_processDomInputString: function(a) {
		var b, c;
		b = this._currentInputString.length < a.length ? this._currentInputString.length : a.length;
		for (c = 0; c < b && a[c] === this._currentInputString[c]; c++);
		var d = this._currentInputString.length - c,
			e = a.length - c;
		for (b = 0; b < d; b++) this.dispatchDeleteBackward();
		for (b = 0; b < e; b++) this.dispatchInsertText(a[c + b], 1);
		this._currentInputString = a
	},
	dispatchInsertText: function(a, b) {
		this.impl && a && !(0 >= b) && this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
	},
	dispatchDeleteBackward: function() {
		this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
	},
	getContentText: function() {
		if (this.impl && this.impl._delegateWithIme) {
			var a = this.impl._delegateWithIme.getContentText();
			return a ? a : ""
		}
		return ""
	},
	dispatchKeyboardWillShow: function(a) {
		if (this.impl) for (var b = 0; b < this.impl._delegateList.length; b++) {
			var c = this.impl._delegateList[b];
			c && c.keyboardWillShow(a)
		}
	},
	dispatchKeyboardDidShow: function(a) {
		if (this.impl) for (var b = 0; b < this.impl._delegateList.length; b++) {
			var c = this.impl._delegateList[b];
			c && c.keyboardDidShow(a)
		}
	},
	dispatchKeyboardWillHide: function(a) {
		if (this.impl) for (var b = 0; b < this.impl._delegateList.length; b++) {
			var c = this.impl._delegateList[b];
			c && c.keyboardWillHide(a)
		}
	},
	dispatchKeyboardDidHide: function(a) {
		if (this.impl) for (var b = 0; b < this.impl._delegateList.length; b++) {
			var c = this.impl._delegateList[b];
			c && c.keyboardDidHide(a)
		}
	},
	addDelegate: function(a) {
		a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
	},
	attachDelegateWithIME: function(a) {
		if (!this.impl || !a || -1 === this.impl._delegateList.indexOf(a)) return !1;
		if (this.impl._delegateWithIme) {
			if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME()) return !1;
			var b = this.impl._delegateWithIme;
			this.impl._delegateWithIme = null;
			b.didDetachWithIME();
			this._focusDomInput(a);
			return !0
		}
		if (!a.canAttachWithIME()) return !1;
		this._focusDomInput(a);
		return !0
	},
	_focusDomInput: function(a) {
		cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = a.getTipMessage ? a.getTipMessage() : "please enter your word:", a = window.Window && Window.prototype.prompt != prompt ? Window.prototype.prompt.call(window, a, this._currentInputString) : prompt(a, this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
	},
	_domInputControlTranslate: function() {
		/msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
	},
	detachDelegateWithIME: function(a) {
		if (!this.impl || !a || this.impl._delegateWithIme !== a || !a.canDetachWithIME()) return !1;
		this.impl._delegateWithIme = null;
		a.didDetachWithIME();
		cc._canvas.focus();
		return !0
	},
	removeDelegate: function(a) {
		this.impl && a && -1 !== this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a === this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
	},
	processKeycode: function(a) {
		32 > a ? a === cc.KEY.backspace ? this.dispatchDeleteBackward() : a === cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
	}
});
cc.IMEDispatcher.Impl = cc.Class.extend({
	_delegateWithIme: null,
	_delegateList: null,
	ctor: function() {
		this._delegateList = []
	},
	findDelegate: function(a) {
		for (var b = 0; b < this._delegateList.length; b++)
		if (this._delegateList[b] === a) return b;
		return null
	}
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
	cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
	onTextFieldAttachWithIME: function(a) {
		return !1
	},
	onTextFieldDetachWithIME: function(a) {
		return !1
	},
	onTextFieldInsertText: function(a, b, c) {
		return !1
	},
	onTextFieldDeleteBackward: function(a, b, c) {
		return !1
	},
	onDraw: function(a) {
		return !1
	}
});
cc.TextFieldTTF = cc.LabelTTF.extend({
	delegate: null,
	colorSpaceHolder: null,
	_colorText: null,
	_lens: null,
	_inputText: "",
	_placeHolder: "",
	_charCount: 0,
	_className: "TextFieldTTF",
	ctor: function(a, b, c, d, e) {
		this.colorSpaceHolder = cc.color(127, 127, 127);
		this._colorText = cc.color(255, 255, 255, 255);
		cc.LabelTTF.prototype.ctor.call(this);
		void 0 !== e ? (this.initWithPlaceHolder("", b, c, d, e), a && this.setPlaceHolder(a)) : void 0 === d && void 0 !== c && (this.initWithString("", b, c), a && this.setPlaceHolder(a))
	},
	onEnter: function() {
		cc.LabelTTF.prototype.onEnter.call(this);
		cc.imeDispatcher.addDelegate(this)
	},
	onExit: function() {
		cc.LabelTTF.prototype.onExit.call(this);
		cc.imeDispatcher.removeDelegate(this)
	},
	getDelegate: function() {
		return this.delegate
	},
	setDelegate: function(a) {
		this.delegate = a
	},
	getCharCount: function() {
		return this._charCount
	},
	getColorSpaceHolder: function() {
		return cc.color(this.colorSpaceHolder)
	},
	setColorSpaceHolder: function(a) {
		this.colorSpaceHolder.r = a.r;
		this.colorSpaceHolder.g = a.g;
		this.colorSpaceHolder.b = a.b;
		this.colorSpaceHolder.a = cc.isUndefined(a.a) ? 255 : a.a;
		this._inputText.length || this.setColor(this.colorSpaceHolder)
	},
	setTextColor: function(a) {
		this._colorText.r = a.r;
		this._colorText.g = a.g;
		this._colorText.b = a.b;
		this._colorText.a = cc.isUndefined(a.a) ? 255 : a.a;
		this._inputText.length && this.setColor(this._colorText)
	},
	initWithPlaceHolder: function(a, b, c, d, e) {
		switch (arguments.length) {
		case 5:
			return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, d, e, b, c);
		case 3:
			return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
		default:
			throw Error("Argument must be non-nil ");
		}
	},
	setString: function(a) {
		this._inputText = (a = String(a)) || "";
		this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder));
		cc._renderType === cc._RENDER_TYPE_CANVAS && this._renderCmd._updateTexture();
		this._charCount = this._inputText.length
	},
	getString: function() {
		return this._inputText
	},
	setPlaceHolder: function(a) {
		this._placeHolder = a || "";
		this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
	},
	getPlaceHolder: function() {
		return this._placeHolder
	},
	draw: function(a) {
		a = a || cc._renderContext;
		(!this.delegate || !this.delegate.onDraw(this)) && cc.LabelTTF.prototype.draw.call(this, a)
	},
	visit: function(a) {
		this._super(a)
	},
	attachWithIME: function() {
		return cc.imeDispatcher.attachDelegateWithIME(this)
	},
	detachWithIME: function() {
		return cc.imeDispatcher.detachDelegateWithIME(this)
	},
	canAttachWithIME: function() {
		return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
	},
	didAttachWithIME: function() {},
	canDetachWithIME: function() {
		return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
	},
	didDetachWithIME: function() {},
	deleteBackward: function() {
		var a = this._inputText.length;
		if (0 !== a && (!this.delegate || !this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1))) 1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)) : this.string = this._inputText.substring(0, a - 1)
	},
	removeDelegate: function() {
		cc.imeDispatcher.removeDelegate(this)
	},
	_tipMessage: "please enter your word:",
	setTipMessage: function(a) {
		null != a && (this._tipMessage = a)
	},
	getTipMessage: function() {
		return this._tipMessage
	},
	insertText: function(a, b) {
		var c = a,
			d = c.indexOf("\n"); - 1 < d && (c = c.substring(0, d));
		if (0 < c.length) {
			if (this.delegate && this.delegate.onTextFieldInsertText(this, c, c.length)) return;
			c = this._inputText + c;
			this._charCount = c.length;
			this.string = c
		} - 1 !== d && (!this.delegate || !this.delegate.onTextFieldInsertText(this, "\n", 1)) && this.detachWithIME()
	},
	getContentText: function() {
		return this._inputText
	},
	keyboardWillShow: function(a) {},
	keyboardDidShow: function(a) {},
	keyboardWillHide: function(a) {},
	keyboardDidHide: function(a) {}
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(a, b, c, d, e) {
	return new cc.TextFieldTTF(a, b, c, d, e)
};
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
	_enabled: !1,
	_target: null,
	_callback: null,
	_isSelected: !1,
	_className: "MenuItem",
	ctor: function(a, b) {
		var c = cc.Node.prototype;
		c.ctor.call(this);
		this._callback = this._target = null;
		this._enabled = this._isSelected = !1;
		c.setAnchorPoint.call(this, 0.5, 0.5);
		this._target = b || null;
		if (this._callback = a || null) this._enabled = !0
	},
	isSelected: function() {
		return this._isSelected
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	setTarget: function(a, b) {
		this._target = b;
		this._callback = a
	},
	isEnabled: function() {
		return this._enabled
	},
	setEnabled: function(a) {
		this._enabled = a
	},
	initWithCallback: function(a, b) {
		this.anchorY = this.anchorX = 0.5;
		this._target = b;
		this._callback = a;
		this._enabled = !0;
		this._isSelected = !1;
		return !0
	},
	rect: function() {
		var a = this._position,
			b = this._contentSize,
			c = this._anchorPoint;
		return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
	},
	selected: function() {
		this._isSelected = !0
	},
	unselected: function() {
		this._isSelected = !1
	},
	setCallback: function(a, b) {
		this._target = b;
		this._callback = a
	},
	activate: function() {
		if (this._enabled) {
			var a = this._target,
				b = this._callback;
			if (b) if (a && cc.isString(b)) a[b](this);
			else a && cc.isFunction(b) ? b.call(a, this) : b(this)
		}
	}
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, b) {
	return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
	_disabledColor: null,
	_label: null,
	_originalScale: 0,
	_colorBackup: null,
	ctor: function(a, b, c) {
		cc.MenuItem.prototype.ctor.call(this, b, c);
		this._colorBackup = this._label = this._disabledColor = null;
		a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0))
	},
	getDisabledColor: function() {
		return this._disabledColor
	},
	setDisabledColor: function(a) {
		this._disabledColor = a
	},
	getLabel: function() {
		return this._label
	},
	setLabel: function(a) {
		a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height, a.setCascadeColorEnabled(!0));
		this._label && this.removeChild(this._label, !0);
		this._label = a
	},
	setEnabled: function(a) {
		this._enabled !== a && (a ? this.setColor(this._colorBackup) : (this._colorBackup = this.color, this.setColor(this._disabledColor)));
		cc.MenuItem.prototype.setEnabled.call(this, a)
	},
	initWithLabel: function(a, b, c) {
		this.initWithCallback(b, c);
		this._originalScale = 1;
		this._colorBackup = cc.color.WHITE;
		this._disabledColor = cc.color(126, 126, 126);
		this.setLabel(a);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	setString: function(a) {
		this._label.string = a;
		this.width = this._label.width;
		this.height = this._label.height
	},
	getString: function() {
		return this._label.string
	},
	activate: function() {
		this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
	},
	selected: function() {
		if (this._enabled) {
			cc.MenuItem.prototype.selected.call(this);
			var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
			a ? this.stopAction(a) : this._originalScale = this.scale;
			a = cc.scaleTo(0.1, 1.2 * this._originalScale);
			a.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(a)
		}
	},
	unselected: function() {
		if (this._enabled) {
			cc.MenuItem.prototype.unselected.call(this);
			this.stopActionByTag(cc.ZOOM_ACTION_TAG);
			var a = cc.scaleTo(0.1, this._originalScale);
			a.setTag(cc.ZOOM_ACTION_TAG);
			this.runAction(a)
		}
	}
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, b, c) {
	return new cc.MenuItemLabel(a, b, c)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
	ctor: function(a, b, c, d, e, f, k) {
		var m;
		a && 0 < a.length && (m = new cc.LabelAtlas(a, b, c, d, e));
		cc.MenuItemLabel.prototype.ctor.call(this, m, f, k)
	},
	initWithString: function(a, b, c, d, e, f, k) {
		if (!a || 0 === a.length) throw Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
		var m = new cc.LabelAtlas;
		m.initWithString(a, b, c, d, e);
		this.initWithLabel(m, f, k);
		return !0
	}
});
cc.MenuItemAtlasFont.create = function(a, b, c, d, e, f, k) {
	return new cc.MenuItemAtlasFont(a, b, c, d, e, f, k)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
	_fontSize: null,
	_fontName: null,
	ctor: function(a, b, c) {
		var d;
		a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
		cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
	},
	initWithString: function(a, b, c) {
		if (!a || 0 === a.length) throw Error("Value should be non-null and its length should be greater than 0");
		this._fontName = cc._globalFontName;
		this._fontSize = cc._globalFontSize;
		a = new cc.LabelTTF(a, this._fontName, this._fontSize);
		this.initWithLabel(a, b, c);
		return !0
	},
	setFontSize: function(a) {
		this._fontSize = a;
		this._recreateLabel()
	},
	getFontSize: function() {
		return this._fontSize
	},
	setFontName: function(a) {
		this._fontName = a;
		this._recreateLabel()
	},
	getFontName: function() {
		return this._fontName
	},
	_recreateLabel: function() {
		var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
		this.setLabel(a)
	}
});
cc.MenuItemFont.setFontSize = function(a) {
	cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
	return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
	cc._globalFontNameRelease && (cc._globalFontName = "");
	cc._globalFontName = a;
	cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
	return cc._globalFontName
};
cc.MenuItemFont.create = function(a, b, c) {
	return new cc.MenuItemFont(a, b, c)
};
cc.MenuItemSprite = cc.MenuItem.extend({
	_normalImage: null,
	_selectedImage: null,
	_disabledImage: null,
	ctor: function(a, b, c, d, e) {
		cc.MenuItem.prototype.ctor.call(this);
		this._disabledImage = this._selectedImage = this._normalImage = null;
		if (void 0 !== b) {
			var f, k, m;
			void 0 !== e ? (f = c, m = d, k = e) : void 0 !== d && cc.isFunction(d) ? (f = c, m = d) : void 0 !== d && cc.isFunction(c) ? (k = d, m = c, f = null) : void 0 === c && (f = null);
			this.initWithNormalSprite(a, b, f, m, k)
		}
	},
	getNormalImage: function() {
		return this._normalImage
	},
	setNormalImage: function(a) {
		this._normalImage !== a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
			this.width = a.width;
			this.height = a.height
		}, this))
	},
	getSelectedImage: function() {
		return this._selectedImage
	},
	setSelectedImage: function(a) {
		this._selectedImage !== a && (a && (this.addChild(a, 0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
	},
	getDisabledImage: function() {
		return this._disabledImage
	},
	setDisabledImage: function(a) {
		this._disabledImage !== a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
	},
	initWithNormalSprite: function(a, b, c, d, e) {
		this.initWithCallback(d, e);
		this.setNormalImage(a);
		this.setSelectedImage(b);
		this.setDisabledImage(c);
		if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
			this.width = a.width;
			this.height = a.height;
			this.setCascadeColorEnabled(!0);
			this.setCascadeOpacityEnabled(!0)
		}, this);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
	},
	setEnabled: function(a) {
		this._enabled !== a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
	},
	_updateImagesVisibility: function() {
		var a = this._normalImage,
			b = this._selectedImage,
			c = this._disabledImage;
		this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
	}
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, b, c, d, e) {
	return new cc.MenuItemSprite(a, b, c, d, e || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
	ctor: function(a, b, c, d, e) {
		var f = null,
			k = null,
			m = null,
			n = null,
			p = null;
		void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = new cc.Sprite(a), b && (k = new cc.Sprite(b)), void 0 === d ? n = c : void 0 === e ? (n = c, p = d) : e && (m = new cc.Sprite(c), n = d, p = e), cc.MenuItemSprite.prototype.ctor.call(this, f, k, m, n, p))
	},
	setNormalSpriteFrame: function(a) {
		this.setNormalImage(new cc.Sprite(a))
	},
	setSelectedSpriteFrame: function(a) {
		this.setSelectedImage(new cc.Sprite(a))
	},
	setDisabledSpriteFrame: function(a) {
		this.setDisabledImage(new cc.Sprite(a))
	},
	initWithNormalImage: function(a, b, c, d, e) {
		var f = null,
			k = null,
			m = null;
		a && (f = new cc.Sprite(a));
		b && (k = new cc.Sprite(b));
		c && (m = new cc.Sprite(c));
		return this.initWithNormalSprite(f, k, m, d, e)
	}
});
cc.MenuItemImage.create = function(a, b, c, d, e) {
	return new cc.MenuItemImage(a, b, c, d, e)
};
cc.MenuItemToggle = cc.MenuItem.extend({
	subItems: null,
	_selectedIndex: 0,
	_opacity: null,
	_color: null,
	ctor: function() {
		cc.MenuItem.prototype.ctor.call(this);
		this._selectedIndex = 0;
		this.subItems = [];
		this._opacity = 0;
		this._color = cc.color.WHITE;
		0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
	},
	getOpacity: function() {
		return this._opacity
	},
	setOpacity: function(a) {
		this._opacity = a;
		if (this.subItems && 0 < this.subItems.length) for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
		this._color.a = a
	},
	getColor: function() {
		var a = this._color;
		return cc.color(a.r, a.g, a.b, a.a)
	},
	setColor: function(a) {
		var b = this._color;
		b.r = a.r;
		b.g = a.g;
		b.b = a.b;
		if (this.subItems && 0 < this.subItems.length) for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
		void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
	},
	getSelectedIndex: function() {
		return this._selectedIndex
	},
	setSelectedIndex: function(a) {
		if (a !== this._selectedIndex) {
			this._selectedIndex = a;
			(a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
			a = this.subItems[this._selectedIndex];
			this.addChild(a, 0, cc.CURRENT_ITEM);
			var b = a.width,
				c = a.height;
			this.width = b;
			this.height = c;
			a.setPosition(b / 2, c / 2)
		}
	},
	getSubItems: function() {
		return this.subItems
	},
	setSubItems: function(a) {
		this.subItems = a
	},
	initWithItems: function(a) {
		var b = a.length;
		cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
		for (var c = this.subItems, d = c.length = 0; d < b; d++) a[d] && c.push(a[d]);
		this._selectedIndex = cc.UINT_MAX;
		this.setSelectedIndex(0);
		this.setCascadeColorEnabled(!0);
		this.setCascadeOpacityEnabled(!0);
		return !0
	},
	addSubItem: function(a) {
		this.subItems.push(a)
	},
	activate: function() {
		this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
		cc.MenuItem.prototype.activate.call(this)
	},
	selected: function() {
		cc.MenuItem.prototype.selected.call(this);
		this.subItems[this._selectedIndex].selected()
	},
	unselected: function() {
		cc.MenuItem.prototype.unselected.call(this);
		this.subItems[this._selectedIndex].unselected()
	},
	setEnabled: function(a) {
		if (this._enabled !== a) {
			cc.MenuItem.prototype.setEnabled.call(this, a);
			var b = this.subItems;
			if (b && 0 < b.length) for (var c = 0; c < b.length; c++) b[c].enabled = a
		}
	},
	selectedItem: function() {
		return this.subItems[this._selectedIndex]
	},
	getSelectedItem: function() {
		return this.subItems[this._selectedIndex]
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.setSelectedIndex(this._selectedIndex)
	}
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
	0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
	var a = new cc.MenuItemToggle;
	a.initWithItems(Array.prototype.slice.apply(arguments));
	return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
	enabled: !1,
	_selectedItem: null,
	_state: -1,
	_touchListener: null,
	_className: "Menu",
	ctor: function(a) {
		cc.Layer.prototype.ctor.call(this);
		this._color = cc.color.WHITE;
		this.enabled = !1;
		this._opacity = 255;
		this._selectedItem = null;
		this._state = -1;
		this._touchListener = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: this._onTouchBegan,
			onTouchMoved: this._onTouchMoved,
			onTouchEnded: this._onTouchEnded,
			onTouchCancelled: this._onTouchCancelled
		});
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var b = arguments.length,
			c;
		if (0 === b) c = [];
		else if (1 === b) c = a instanceof Array ? a : [a];
		else if (1 < b) {
			c = [];
			for (var d = 0; d < b; d++) arguments[d] && c.push(arguments[d])
		}
		this.initWithArray(c)
	},
	onEnter: function() {
		var a = this._touchListener;
		a._isRegistered() || cc.eventManager.addListener(a, this);
		cc.Node.prototype.onEnter.call(this)
	},
	isEnabled: function() {
		return this.enabled
	},
	setEnabled: function(a) {
		this.enabled = a
	},
	initWithItems: function(a) {
		var b = [];
		if (a) for (var c = 0; c < a.length; c++) a[c] && b.push(a[c]);
		return this.initWithArray(b)
	},
	initWithArray: function(a) {
		if (cc.Layer.prototype.init.call(this)) {
			this.enabled = !0;
			var b = cc.winSize;
			this.setPosition(b.width / 2, b.height / 2);
			this.setContentSize(b);
			this.setAnchorPoint(0.5, 0.5);
			this.ignoreAnchorPointForPosition(!0);
			if (a) for (b = 0; b < a.length; b++) this.addChild(a[b], b);
			this._selectedItem = null;
			this._state = cc.MENU_STATE_WAITING;
			return this.cascadeOpacity = this.cascadeColor = !0
		}
		return !1
	},
	addChild: function(a, b, c) {
		if (!(a instanceof cc.MenuItem)) throw Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
		cc.Layer.prototype.addChild.call(this, a, b, c)
	},
	alignItemsVertically: function() {
		this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsVerticallyWithPadding: function(a) {
		var b = -a,
			c = this._children,
			d, e, f, k;
		if (c && 0 < c.length) {
			e = 0;
			for (d = c.length; e < d; e++) b += c[e].height * c[e].scaleY + a;
			var m = b / 2;
			e = 0;
			for (d = c.length; e < d; e++) k = c[e], f = k.height, b = k.scaleY, k.setPosition(0, m - f * b / 2), m -= f * b + a
		}
	},
	alignItemsHorizontally: function() {
		this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
	},
	alignItemsHorizontallyWithPadding: function(a) {
		var b = -a,
			c = this._children,
			d, e, f, k;
		if (c && 0 < c.length) {
			d = 0;
			for (e = c.length; d < e; d++) b += c[d].width * c[d].scaleX + a;
			var m = -b / 2;
			d = 0;
			for (e = c.length; d < e; d++) k = c[d], b = k.scaleX, f = c[d].width, k.setPosition(m + f * b / 2, 0), m += f * b + a
		}
	},
	alignItemsInColumns: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
		var c = -5,
			d = 0,
			e = 0,
			f = 0,
			k, m, n, p = this._children;
		if (p && 0 < p.length) {
			b = 0;
			for (n = p.length; b < n; b++)
			if (!(d >= a.length) && (k = a[d])) m = p[b].height, e = e >= m || isNaN(m) ? e : m, ++f, f >= k && (c += e + 5, e = f = 0, ++d)
		}
		var r = cc.director.getWinSize(),
			s = k = e = d = 0,
			u = 0,
			c = c / 2;
		if (p && 0 < p.length) {
			b = 0;
			for (n = p.length; b < n; b++) {
				var t = p[b];
				0 === k && (k = a[d], u = s = r.width / (1 + k));
				m = t._getHeight();
				e = e >= m || isNaN(m) ? e : m;
				t.setPosition(u - r.width / 2, c - m / 2);
				u += s;
				++f;
				f >= k && (c -= e + 5, e = k = f = 0, ++d)
			}
		}
	},
	alignItemsInRows: function() {
		0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
		var a = [],
			b;
		for (b = 0; b < arguments.length; b++) a.push(arguments[b]);
		var c = [],
			d = [],
			e = -10,
			f = -5,
			k = 0,
			m = 0,
			n = 0,
			p, r, s, u, t = this._children;
		if (t && 0 < t.length) {
			b = 0;
			for (s = t.length; b < s; b++)
			if (r = t[b], !(k >= a.length) && (p = a[k])) u = r.width, m = m >= u || isNaN(u) ? m : u, f += r.height + 5, ++n, n >= p && (c.push(m), d.push(f), e += m + 10, m = n = 0, f = -5, ++k)
		}
		f = cc.director.getWinSize();
		p = m = k = 0;
		var e = -e / 2,
			w = 0;
		if (t && 0 < t.length) {
			b = 0;
			for (s = t.length; b < s; b++) r = t[b], 0 === p && (p = a[k], w = d[k]), u = r._getWidth(), m = m >= u || isNaN(u) ? m : u, r.setPosition(e + c[k] / 2, w - f.height / 2), w -= r.height + 10, ++n, n >= p && (e += m + 5, m = p = n = 0, ++k)
		}
	},
	removeChild: function(a, b) {
		null != a && (a instanceof cc.MenuItem ? (this._selectedItem === a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
	},
	_onTouchBegan: function(a, b) {
		var c = b.getCurrentTarget();
		if (c._state !== cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
		for (var d = c.parent; null != d; d = d.parent)
		if (!d.isVisible()) return !1;
		c._selectedItem = c._itemForTouch(a);
		return c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), c._selectedItem.setNodeDirty(), !0) : !1
	},
	_onTouchEnded: function(a, b) {
		var c = b.getCurrentTarget();
		c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty(), c._selectedItem.activate()), c._state = cc.MENU_STATE_WAITING)
	},
	_onTouchCancelled: function(a, b) {
		var c = b.getCurrentTarget();
		c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), c._state = cc.MENU_STATE_WAITING)
	},
	_onTouchMoved: function(a, b) {
		var c = b.getCurrentTarget();
		if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
		else {
			var d = c._itemForTouch(a);
			d !== c._selectedItem && (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), c._selectedItem = d, c._selectedItem && (c._selectedItem.selected(), c._selectedItem.setNodeDirty()))
		}
	},
	onExit: function() {
		this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
		cc.Node.prototype.onExit.call(this)
	},
	setOpacityModifyRGB: function(a) {},
	isOpacityModifyRGB: function() {
		return !1
	},
	_itemForTouch: function(a) {
		a = a.getLocation();
		var b = this._children,
			c;
		if (b && 0 < b.length) for (var d = b.length - 1; 0 <= d; d--)
		if (c = b[d], c.isVisible() && c.isEnabled()) {
			var e = c.convertToNodeSpace(a),
				f = c.rect();
			f.x = 0;
			f.y = 0;
			if (cc.rectContainsPoint(f, e)) return c
		}
		return null
	}
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
	var b = arguments.length;
	0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
	return 0 === b ? new cc.Menu : 1 === b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(a, b, c, d, e, f, k) {
	this.status = a || 0;
	this.type = b || 0;
	this.pixelDepth = c || 0;
	this.width = d || 0;
	this.height = e || 0;
	this.imageData = f || [];
	this.flipped = k || 0
};
cc.tgaLoadHeader = function(a, b, c) {
	var d = 2;
	if (d + 1 > b) return !1;
	a = new cc.BinaryStreamReader(a);
	a.setOffset(d);
	c.type = a.readByte();
	d += 10;
	if (d + 4 + 1 > b) return !1;
	a.setOffset(d);
	c.width = a.readUnsignedShort();
	c.height = a.readUnsignedInteger();
	c.pixelDepth = a.readByte();
	if (d + 5 + 1 > b) return !1;
	b = a.readByte();
	c.flipped = 0;
	b & 32 && (c.flipped = 1);
	return !0
};
cc.tgaLoadImageData = function(a, b, c) {
	var d, e;
	d = 0 | c.pixelDepth / 2;
	e = c.height * c.width * d;
	if (18 + e > b) return !1;
	c.imageData = cc.__getSubArray(a, 18, 18 + e);
	if (3 <= d) for (a = 0; a < e; a += d) b = c.imageData[a], c.imageData[a] = c.imageData[a + 2], c.imageData[a + 2] = b;
	return !0
};
cc.tgaRGBtogreyscale = function(a) {
	var b, c;
	if (8 !== a.pixelDepth) {
		var d = a.pixelDepth / 8,
			e = new Uint8Array(a.height * a.width);
		if (null !== e) {
			for (c = b = 0; c < a.width * a.height; b += d, c++) e[c] = 0.3 * a.imageData[b] + 0.59 * a.imageData[b + 1] + 0.11 * a.imageData[b + 2];
			a.pixelDepth = 8;
			a.type = 3;
			a.imageData = e
		}
	}
};
cc.tgaDestroy = function(a) {
	a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function(a, b, c) {
	var d, e, f, k = 0,
		m = 0,
		n = 0,
		p = [],
		r = 0,
		s = 18;
	d = c.pixelDepth / 8;
	e = c.height * c.width;
	for (f = 0; f < e; f++) {
		if (0 !== r) r--, m = 0 !== n;
		else {
			if (s + 1 > b) break;
			r = a[s];
			s += 1;
			(n = r & 128) && (r -= 128);
			m = 0
		}
		if (!m) {
			if (s + d > b) break;
			p = cc.__getSubArray(a, s, s + d);
			s += d;
			3 <= d && (m = p[0], p[0] = p[2], p[2] = m)
		}
		for (m = 0; m < d; m++) c.imageData[k + m] = p[m];
		k += d
	}
	return !0
};
cc.tgaFlipImage = function(a) {
	for (var b = a.width * (a.pixelDepth / 8), c = 0; c < a.height / 2; c++) {
		var d = cc.__getSubArray(a.imageData, c * b, c * b + b);
		cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (c + 1)) * b, b), a.imageData, c * b);
		cc.__setDataToArray(d, a.imageData, (a.height - (c + 1)) * b)
	}
	a.flipped = 0
};
cc.__getSubArray = function(a, b, c) {
	return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
};
cc.__setDataToArray = function(a, b, c) {
	for (var d = 0; d < a.length; d++) b[c + d] = a[d]
};
cc.BinaryStreamReader = cc.Class.extend({
	_binaryData: null,
	_offset: 0,
	ctor: function(a) {
		this._binaryData = a
	},
	setBinaryData: function(a) {
		this._binaryData = a;
		this._offset = 0
	},
	getBinaryData: function() {
		return this._binaryData
	},
	_checkSize: function(a) {
		if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound");
	},
	_decodeFloat: function(a, b) {
		var c = a + b + 1,
			d = c >> 3;
		this._checkSize(c);
		var c = Math.pow(2, b - 1) - 1,
			e = this._readBits(a + b, 1, d),
			f = this._readBits(a, b, d),
			k = 0,
			m = 2,
			n = 0;
		do
		for (var p = this._readByte(++n, d), r = a % 8 || 8, s = 1 << r; s >>= 1;) p & s && (k += 1 / m), m *= 2;
		while (a -= r);
		this._offset += d;
		return f === (c << 1) + 1 ? k ? NaN : e ? -Infinity : Infinity : (1 + -2 * e) * (f || k ? !f ? Math.pow(2, -c + 1) * k : Math.pow(2, f - c) * (1 + k) : 0)
	},
	_readByte: function(a, b) {
		return this._data[this._offset + b - a - 1]
	},
	_decodeInt: function(a, b) {
		var c = this._readBits(0, a, a / 8),
			d = Math.pow(2, a);
		this._offset += a / 8;
		return b && c >= d / 2 ? c - d : c
	},
	_shl: function(a, b) {
		for (++b; --b; a = 1073741824 === ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
		return a
	},
	_readBits: function(a, b, c) {
		var d = (a + b) % 8,
			e = a % 8,
			f = c - (a >> 3) - 1;
		a = c + (-(a + b) >> 3);
		var k = f - a;
		b = this._readByte(f, c) >> e & (1 << (k ? 8 - e : b)) - 1;
		for (k && d && (b += (this._readByte(a++, c) & (1 << d) - 1) << (k-- << 3) - e); k;) b += this._shl(this._readByte(a++, c), (k-- << 3) - e);
		return b
	},
	readInteger: function() {
		return this._decodeInt(32, !0)
	},
	readUnsignedInteger: function() {
		return this._decodeInt(32, !1)
	},
	readSingle: function() {
		return this._decodeFloat(23, 8)
	},
	readShort: function() {
		return this._decodeInt(16, !0)
	},
	readUnsignedShort: function() {
		return this._decodeInt(16, !1)
	},
	readByte: function() {
		var a = this._data[this._offset];
		this._offset += 1;
		return a
	},
	readData: function(a, b) {
		return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
	},
	setOffset: function(a) {
		this._offset = a
	},
	getOffset: function() {
		return this._offset
	}
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
	properties: null,
	mapOrientation: null,
	objectGroups: null,
	_mapSize: null,
	_tileSize: null,
	_tileProperties: null,
	_className: "TMXTiledMap",
	ctor: function(a, b) {
		cc.Node.prototype.ctor.call(this);
		this._mapSize = cc.size(0, 0);
		this._tileSize = cc.size(0, 0);
		void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
	},
	getMapSize: function() {
		return cc.size(this._mapSize.width, this._mapSize.height)
	},
	setMapSize: function(a) {
		this._mapSize.width = a.width;
		this._mapSize.height = a.height
	},
	_getMapWidth: function() {
		return this._mapSize.width
	},
	_setMapWidth: function(a) {
		this._mapSize.width = a
	},
	_getMapHeight: function() {
		return this._mapSize.height
	},
	_setMapHeight: function(a) {
		this._mapSize.height = a
	},
	getTileSize: function() {
		return cc.size(this._tileSize.width, this._tileSize.height)
	},
	setTileSize: function(a) {
		this._tileSize.width = a.width;
		this._tileSize.height = a.height
	},
	_getTileWidth: function() {
		return this._tileSize.width
	},
	_setTileWidth: function(a) {
		this._tileSize.width = a
	},
	_getTileHeight: function() {
		return this._tileSize.height
	},
	_setTileHeight: function(a) {
		this._tileSize.height = a
	},
	getMapOrientation: function() {
		return this.mapOrientation
	},
	setMapOrientation: function(a) {
		this.mapOrientation = a
	},
	getObjectGroups: function() {
		return this.objectGroups
	},
	setObjectGroups: function(a) {
		this.objectGroups = a
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(a) {
		this.properties = a
	},
	initWithTMXFile: function(a) {
		if (!a || 0 === a.length) throw Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
		this.height = this.width = 0;
		a = new cc.TMXMapInfo(a);
		if (!a) return !1;
		var b = a.getTilesets();
		(!b || 0 === b.length) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
		this._buildWithMapInfo(a);
		return !0
	},
	initWithXML: function(a, b) {
		this.height = this.width = 0;
		var c = new cc.TMXMapInfo(a, b),
			d = c.getTilesets();
		(!d || 0 === d.length) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
		this._buildWithMapInfo(c);
		return !0
	},
	_buildWithMapInfo: function(a) {
		this._mapSize = a.getMapSize();
		this._tileSize = a.getTileSize();
		this.mapOrientation = a.orientation;
		this.objectGroups = a.getObjectGroups();
		this.properties = a.properties;
		this._tileProperties = a.getTileProperties();
		var b = 0,
			c = a.getLayers();
		if (c) for (var d = null, e = 0, f = c.length; e < f; e++)
		if ((d = c[e]) && d.visible) d = this._parseLayer(d, a), this.addChild(d, b, b), this.width = Math.max(this.width, d.width), this.height = Math.max(this.height, d.height), b++
	},
	allLayers: function() {
		for (var a = [], b = this._children, c = 0, d = b.length; c < d; c++) {
			var e = b[c];
			e && e instanceof cc.TMXLayer && a.push(e)
		}
		return a
	},
	getLayer: function(a) {
		if (!a || 0 === a.length) throw Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
		for (var b = this._children, c = 0; c < b.length; c++) {
			var d = b[c];
			if (d && d.layerName === a) return d
		}
		return null
	},
	getObjectGroup: function(a) {
		if (!a || 0 === a.length) throw Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
		if (this.objectGroups) for (var b = 0; b < this.objectGroups.length; b++) {
			var c = this.objectGroups[b];
			if (c && c.groupName === a) return c
		}
		return null
	},
	getProperty: function(a) {
		return this.properties[a.toString()]
	},
	propertiesForGID: function(a) {
		cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
		return this.getPropertiesForGID[a]
	},
	getPropertiesForGID: function(a) {
		return this._tileProperties[a]
	},
	_parseLayer: function(a, b) {
		var c = this._tilesetForLayer(a, b),
			c = new cc.TMXLayer(c, a, b);
		a.ownTiles = !1;
		c.setupTiles();
		return c
	},
	_tilesetForLayer: function(a, b) {
		var c = a._layerSize,
			d = b.getTilesets();
		if (d) for (var e = d.length - 1; 0 <= e; e--) {
			var f = d[e];
			if (f) for (var k = 0; k < c.height; k++)
			for (var m = 0; m < c.width; m++) {
				var n = a._tiles[m + c.width * k];
				if (0 !== n && (n & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
			}
		}
		cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
		return null
	}
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(a, b) {
	return new cc.TMXTiledMap(a, b)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
	properties: null,
	name: "",
	_layerSize: null,
	_tiles: null,
	visible: null,
	_opacity: null,
	ownTiles: !0,
	_minGID: 1E5,
	_maxGID: 0,
	offset: null,
	ctor: function() {
		this.properties = [];
		this.name = "";
		this._layerSize = null;
		this._tiles = [];
		this.visible = !0;
		this._opacity = 0;
		this.ownTiles = !0;
		this._minGID = 1E5;
		this._maxGID = 0;
		this.offset = cc.p(0, 0)
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(a) {
		this.properties = a
	}
});
cc.TMXTilesetInfo = cc.Class.extend({
	name: "",
	firstGid: 0,
	_tileSize: null,
	spacing: 0,
	margin: 0,
	sourceImage: "",
	imageSize: null,
	ctor: function() {
		this._tileSize = cc.size(0, 0);
		this.imageSize = cc.size(0, 0)
	},
	rectForGID: function(a) {
		var b = cc.rect(0, 0, 0, 0);
		b.width = this._tileSize.width;
		b.height = this._tileSize.height;
		a &= cc.TMX_TILE_FLIPPED_MASK;
		a -= parseInt(this.firstGid, 10);
		var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
		b.x = parseInt(a % c * (this._tileSize.width + this.spacing) + this.margin, 10);
		b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
		return b
	}
});
cc.TMXMapInfo = cc.SAXParser.extend({
	properties: null,
	orientation: null,
	parentElement: null,
	parentGID: null,
	layerAttrs: 0,
	storingCharacters: !1,
	tmxFileName: null,
	currentString: null,
	_objectGroups: null,
	_mapSize: null,
	_tileSize: null,
	_layers: null,
	_tilesets: null,
	_tileProperties: null,
	_resources: "",
	_currentFirstGID: 0,
	ctor: function(a, b) {
		cc.SAXParser.prototype.ctor.apply(this);
		this._mapSize = cc.size(0, 0);
		this._tileSize = cc.size(0, 0);
		this._layers = [];
		this._tilesets = [];
		this._objectGroups = [];
		this.properties = [];
		this._tileProperties = {};
		this._currentFirstGID = 0;
		void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
	},
	getOrientation: function() {
		return this.orientation
	},
	setOrientation: function(a) {
		this.orientation = a
	},
	getMapSize: function() {
		return cc.size(this._mapSize.width, this._mapSize.height)
	},
	setMapSize: function(a) {
		this._mapSize.width = a.width;
		this._mapSize.height = a.height
	},
	_getMapWidth: function() {
		return this._mapSize.width
	},
	_setMapWidth: function(a) {
		this._mapSize.width = a
	},
	_getMapHeight: function() {
		return this._mapSize.height
	},
	_setMapHeight: function(a) {
		this._mapSize.height = a
	},
	getTileSize: function() {
		return cc.size(this._tileSize.width, this._tileSize.height)
	},
	setTileSize: function(a) {
		this._tileSize.width = a.width;
		this._tileSize.height = a.height
	},
	_getTileWidth: function() {
		return this._tileSize.width
	},
	_setTileWidth: function(a) {
		this._tileSize.width = a
	},
	_getTileHeight: function() {
		return this._tileSize.height
	},
	_setTileHeight: function(a) {
		this._tileSize.height = a
	},
	getLayers: function() {
		return this._layers
	},
	setLayers: function(a) {
		this._layers.push(a)
	},
	getTilesets: function() {
		return this._tilesets
	},
	setTilesets: function(a) {
		this._tilesets.push(a)
	},
	getObjectGroups: function() {
		return this._objectGroups
	},
	setObjectGroups: function(a) {
		this._objectGroups.push(a)
	},
	getParentElement: function() {
		return this.parentElement
	},
	setParentElement: function(a) {
		this.parentElement = a
	},
	getParentGID: function() {
		return this.parentGID
	},
	setParentGID: function(a) {
		this.parentGID = a
	},
	getLayerAttribs: function() {
		return this.layerAttrs
	},
	setLayerAttribs: function(a) {
		this.layerAttrs = a
	},
	getStoringCharacters: function() {
		return this.storingCharacters
	},
	setStoringCharacters: function(a) {
		this.storingCharacters = a
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(a) {
		this.properties = a
	},
	initWithTMXFile: function(a) {
		this._internalInit(a, null);
		return this.parseXMLFile(a)
	},
	initWithXML: function(a, b) {
		this._internalInit(null, b);
		return this.parseXMLString(a)
	},
	parseXMLFile: function(a, b) {
		var c = (b = b || !1) ? a : cc.loader.getRes(a);
		if (!c) throw Error("Please load the resource first : " + a);
		var d, e, c = this._parseXML(c).documentElement;
		d = c.getAttribute("version");
		e = c.getAttribute("orientation");
		if ("map" === c.nodeName && ("1.0" !== d && null !== d && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + d), "orthogonal" === e ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" === e ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" === e ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== e && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + e), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("width")), d.height = parseFloat(c.getAttribute("height")), this.setMapSize(d), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("tilewidth")), d.height = parseFloat(c.getAttribute("tileheight")), this.setTileSize(d), e = c.querySelectorAll("map > properties >  property"))) {
			var f = {};
			for (d = 0; d < e.length; d++) f[e[d].getAttribute("name")] = e[d].getAttribute("value");
			this.properties = f
		}
		f = c.getElementsByTagName("tileset");
		"map" !== c.nodeName && (f = [], f.push(c));
		for (d = 0; d < f.length; d++) {
			e = f[d];
			var k = e.getAttribute("source");
			if (k) e = b ? cc.path.join(this._resources, k) : cc.path.changeBasename(a, k), this.parseXMLFile(e);
			else {
				k = new cc.TMXTilesetInfo;
				k.name = e.getAttribute("name") || "";
				k.firstGid = parseInt(e.getAttribute("firstgid")) || 0;
				k.spacing = parseInt(e.getAttribute("spacing")) || 0;
				k.margin = parseInt(e.getAttribute("margin")) || 0;
				var m = cc.size(0, 0);
				m.width = parseFloat(e.getAttribute("tilewidth"));
				m.height = parseFloat(e.getAttribute("tileheight"));
				k._tileSize = m;
				var m = e.getElementsByTagName("image")[0].getAttribute("source"),
					n = -1;
				this.tmxFileName && (n = this.tmxFileName.lastIndexOf("/")); - 1 !== n ? (n = this.tmxFileName.substr(0, n + 1), k.sourceImage = n + m) : k.sourceImage = this._resources + (this._resources ? "/" : "") + m;
				this.setTilesets(k);
				if (m = e.getElementsByTagName("tile")) for (n = 0; n < m.length; n++) {
					e = m[n];
					this.parentGID = parseInt(k.firstGid) + parseInt(e.getAttribute("id") || 0);
					var p = e.querySelectorAll("properties > property");
					if (p) {
						var r = {};
						for (e = 0; e < p.length; e++) {
							var s = p[e].getAttribute("name");
							r[s] = p[e].getAttribute("value")
						}
						this._tileProperties[this.parentGID] = r
					}
				}
			}
		}
		if (f = c.getElementsByTagName("layer")) for (d = 0; d < f.length; d++) {
			m = f[d];
			n = m.getElementsByTagName("data")[0];
			k = new cc.TMXLayerInfo;
			k.name = m.getAttribute("name");
			e = cc.size(0, 0);
			e.width = parseFloat(m.getAttribute("width"));
			e.height = parseFloat(m.getAttribute("height"));
			k._layerSize = e;
			e = m.getAttribute("visible");
			k.visible = "0" != e;
			e = m.getAttribute("opacity") || 1;
			k._opacity = e ? parseInt(255 * parseFloat(e)) : 255;
			k.offset = cc.p(parseFloat(m.getAttribute("x")) || 0, parseFloat(m.getAttribute("y")) || 0);
			p = "";
			for (e = 0; e < n.childNodes.length; e++) p += n.childNodes[e].nodeValue;
			p = p.trim();
			e = n.getAttribute("compression");
			r = n.getAttribute("encoding");
			if (e && "gzip" !== e && "zlib" !== e) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
			switch (e) {
			case "gzip":
				k._tiles = cc.unzipBase64AsArray(p, 4);
				break;
			case "zlib":
				e = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(p, 1));
				k._tiles = cc.uint8ArrayToUint32Array(e.decompress());
				break;
			case null:
			case "":
				if ("base64" === r) k._tiles = cc.Codec.Base64.decodeAsArray(p, 4);
				else if ("csv" === r) {
					k._tiles = [];
					e = p.split(",");
					for (n = 0; n < e.length; n++) k._tiles.push(parseInt(e[n]))
				} else {
					e = n.getElementsByTagName("tile");
					k._tiles = [];
					for (n = 0; n < e.length; n++) k._tiles.push(parseInt(e[n].getAttribute("gid")))
				}
				break;
			default:
				this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
			}
			if (m = m.querySelectorAll("properties > property")) {
				n = {};
				for (e = 0; e < m.length; e++) n[m[e].getAttribute("name")] = m[e].getAttribute("value");
				k.properties = n
			}
			this.setLayers(k)
		}
		if (f = c.getElementsByTagName("objectgroup")) for (d = 0; d < f.length; d++) {
			m = f[d];
			k = new cc.TMXObjectGroup;
			k.groupName = m.getAttribute("name");
			k.setPositionOffset(cc.p(parseFloat(m.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(m.getAttribute("y")) * this.getTileSize().height || 0));
			if (n = m.querySelectorAll("objectgroup > properties > property")) for (e = 0; e < n.length; e++) p = {}, p[n[e].getAttribute("name")] = n[e].getAttribute("value"), k.properties = p;
			m = m.querySelectorAll("object");
			n = cc.director.getContentScaleFactor();
			if (m) for (e = 0; e < m.length; e++) {
				r = m[e];
				p = {};
				p.name = r.getAttribute("name") || "";
				p.type = r.getAttribute("type") || "";
				p.width = parseInt(r.getAttribute("width")) || 0;
				p.height = parseInt(r.getAttribute("height")) || 0;
				p.x = (((r.getAttribute("x") || 0) | 0) + k.getPositionOffset().x) / n;
				s = ((r.getAttribute("y") || 0) | 0) + k.getPositionOffset().y / n;
				p.y = (parseInt(this.getMapSize().height * this.getTileSize().height) - s - p.height) / cc.director.getContentScaleFactor();
				p.rotation = parseInt(r.getAttribute("rotation")) || 0;
				if (s = r.querySelectorAll("properties > property")) for (var u = 0; u < s.length; u++) p[s[u].getAttribute("name")] = s[u].getAttribute("value");
				if ((s = r.querySelectorAll("polygon")) && 0 < s.length)(s = s[0].getAttribute("points")) && (p.polygonPoints = this._parsePointsString(s));
				if ((r = r.querySelectorAll("polyline")) && 0 < r.length)(r = r[0].getAttribute("points")) && (p.polylinePoints = this._parsePointsString(r));
				k.setObjects(p)
			}
			this.setObjectGroups(k)
		}
		return c
	},
	_parsePointsString: function(a) {
		if (!a) return null;
		var b = [];
		a = a.split(" ");
		for (var c = 0; c < a.length; c++) {
			var d = a[c].split(",");
			b.push({
				x: d[0],
				y: d[1]
			})
		}
		return b
	},
	parseXMLString: function(a) {
		return this.parseXMLFile(a, !0)
	},
	getTileProperties: function() {
		return this._tileProperties
	},
	setTileProperties: function(a) {
		this._tileProperties.push(a)
	},
	getCurrentString: function() {
		return this.currentString
	},
	setCurrentString: function(a) {
		this.currentString = a
	},
	getTMXFileName: function() {
		return this.tmxFileName
	},
	setTMXFileName: function(a) {
		this.tmxFileName = a
	},
	_internalInit: function(a, b) {
		this._tilesets.length = 0;
		this._layers.length = 0;
		this.tmxFileName = a;
		b && (this._resources = b);
		this._objectGroups.length = 0;
		this.properties.length = 0;
		this._tileProperties.length = 0;
		this.currentString = "";
		this.storingCharacters = !1;
		this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
		this.parentElement = cc.TMX_PROPERTY_NONE;
		this._currentFirstGID = 0
	}
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(a, b) {
	return new cc.TMXMapInfo(a, b)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
	properties: null,
	groupName: "",
	_positionOffset: null,
	_objects: null,
	ctor: function() {
		this.groupName = "";
		this._positionOffset = cc.p(0, 0);
		this.properties = [];
		this._objects = []
	},
	getPositionOffset: function() {
		return cc.p(this._positionOffset)
	},
	setPositionOffset: function(a) {
		this._positionOffset.x = a.x;
		this._positionOffset.y = a.y
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(a) {
		this.properties.push(a)
	},
	getGroupName: function() {
		return this.groupName.toString()
	},
	setGroupName: function(a) {
		this.groupName = a
	},
	propertyNamed: function(a) {
		return this.properties[a]
	},
	objectNamed: function(a) {
		return this.getObject(a)
	},
	getObject: function(a) {
		if (this._objects && 0 < this._objects.length) for (var b = this._objects, c = 0, d = b.length; c < d; c++) {
			var e = b[c].name;
			if (e && e === a) return b[c]
		}
		return null
	},
	getObjects: function() {
		return this._objects
	},
	setObjects: function(a) {
		this._objects.push(a)
	}
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
	tiles: null,
	tileset: null,
	layerOrientation: null,
	properties: null,
	layerName: "",
	_layerSize: null,
	_mapTileSize: null,
	_opacity: 255,
	_minGID: null,
	_maxGID: null,
	_vertexZvalue: null,
	_useAutomaticVertexZ: null,
	_reusedTile: null,
	_atlasIndexArray: null,
	_contentScaleFactor: null,
	_className: "TMXLayer",
	ctor: function(a, b, c) {
		cc.SpriteBatchNode.prototype.ctor.call(this);
		this._descendants = [];
		this._layerSize = cc.size(0, 0);
		this._mapTileSize = cc.size(0, 0);
		void 0 !== c && this.initWithTilesetInfo(a, b, c)
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
	},
	setContentSize: function(a, b) {
		cc.Node.prototype.setContentSize.call(this, a, b);
		this._renderCmd._updateCacheContext(a, b)
	},
	getTexture: function() {
		return this._renderCmd.getTexture()
	},
	getLayerSize: function() {
		return cc.size(this._layerSize.width, this._layerSize.height)
	},
	setLayerSize: function(a) {
		this._layerSize.width = a.width;
		this._layerSize.height = a.height
	},
	_getLayerWidth: function() {
		return this._layerSize.width
	},
	_setLayerWidth: function(a) {
		this._layerSize.width = a
	},
	_getLayerHeight: function() {
		return this._layerSize.height
	},
	_setLayerHeight: function(a) {
		this._layerSize.height = a
	},
	getMapTileSize: function() {
		return cc.size(this._mapTileSize.width, this._mapTileSize.height)
	},
	setMapTileSize: function(a) {
		this._mapTileSize.width = a.width;
		this._mapTileSize.height = a.height
	},
	_getTileWidth: function() {
		return this._mapTileSize.width
	},
	_setTileWidth: function(a) {
		this._mapTileSize.width = a
	},
	_getTileHeight: function() {
		return this._mapTileSize.height
	},
	_setTileHeight: function(a) {
		this._mapTileSize.height = a
	},
	getTiles: function() {
		return this.tiles
	},
	setTiles: function(a) {
		this.tiles = a
	},
	getTileset: function() {
		return this.tileset
	},
	setTileset: function(a) {
		this.tileset = a
	},
	getLayerOrientation: function() {
		return this.layerOrientation
	},
	setLayerOrientation: function(a) {
		this.layerOrientation = a
	},
	getProperties: function() {
		return this.properties
	},
	setProperties: function(a) {
		this.properties = a
	},
	initWithTilesetInfo: function(a, b, c) {
		var d = b._layerSize,
			e = 0.35 * parseInt(d.width * d.height) + 1,
			f;
		a && (f = cc.textureCache.addImage(a.sourceImage));
		return this.initWithTexture(f, e) ? (this.layerName = b.name, this._layerSize = d, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation, a = this._calculateLayerOffset(b.offset), this.setPosition(cc.pointPixelsToPoints(a)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
	},
	releaseMap: function() {
		this.tiles && (this.tiles = null);
		this._atlasIndexArray && (this._atlasIndexArray = null)
	},
	getTileAt: function(a, b) {
		if (!a) throw Error("cc.TMXLayer.getTileAt(): pos should be non-null");
		void 0 !== b && (a = cc.p(a, b));
		if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileAt(): invalid position");
		if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
		var c = null,
			d = this.getTileGIDAt(a);
		if (0 === d) return c;
		var e = 0 | a.x + a.y * this._layerSize.width,
			c = this.getChildByTag(e);
		c || (d = this.tileset.rectForGID(d), d = cc.rectPixelsToPoints(d), c = new cc.Sprite, c.initWithTexture(this.texture, d), c.batchNode = this, c.setPosition(this.getPositionAt(a)), c.vertexZ = this._vertexZForPos(a), c.anchorX = 0, c.anchorY = 0, c.opacity = this._opacity, d = this._atlasIndexForExistantZ(e), this.addSpriteWithoutQuad(c, d, e));
		return c
	},
	getTileGIDAt: function(a, b) {
		if (null == a) throw Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
		void 0 !== b && (a = cc.p(a, b));
		if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileGIDAt(): invalid position");
		return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0
	},
	getTileFlagsAt: function(a, b) {
		if (!a) throw Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
		void 0 !== b && (a = cc.p(a, b));
		if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
		return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0
	},
	setTileGID: function(a, b, c, d) {
		if (!b) throw Error("cc.TMXLayer.setTileGID(): pos should be non-null");
		void 0 !== d ? b = cc.p(b, c) : d = c;
		if (b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y) throw Error("cc.TMXLayer.setTileGID(): invalid position");
		if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
		else if (0 !== a && a < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
		else {
			d = d || 0;
			this._setNodeDirtyForCache();
			c = this.getTileFlagsAt(b);
			var e = this.getTileGIDAt(b);
			if (e !== a || c !== d) if (c = (a | d) >>> 0, 0 === a) this.removeTileAt(b);
			else if (0 === e) this._insertTileForGID(c, b);
			else {
				var e = b.x + b.y * this._layerSize.width,
					f = this.getChildByTag(e);
				f ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a), f.setTextureRect(a, !1), null != d && this._setupTileSprite(f, b, c), this.tiles[e] = c) : this._updateTileForGID(c, b)
			}
		}
	},
	removeTileAt: function(a, b) {
		if (!a) throw Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
		void 0 !== b && (a = cc.p(a, b));
		if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.removeTileAt(): invalid position");
		if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
		else if (0 !== this.getTileGIDAt(a)) {
			cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
			var c = 0 | a.x + a.y * this._layerSize.width,
				d = this._atlasIndexForExistantZ(c);
			this.tiles[c] = 0;
			this._atlasIndexArray.splice(d, 1);
			if (c = this.getChildByTag(c)) cc.SpriteBatchNode.prototype.removeChild.call(this, c, !0);
			else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(d), this._children) for (var c = this._children, e = 0, f = c.length; e < f; e++) {
				var k = c[e];
				if (k) {
					var m = k.atlasIndex;
					m >= d && (k.atlasIndex = m - 1)
				}
			}
		}
	},
	getPositionAt: function(a, b) {
		void 0 !== b && (a = cc.p(a, b));
		var c = cc.p(0, 0);
		switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ORTHO:
			c = this._positionForOrthoAt(a);
			break;
		case cc.TMX_ORIENTATION_ISO:
			c = this._positionForIsoAt(a);
			break;
		case cc.TMX_ORIENTATION_HEX:
			c = this._positionForHexAt(a)
		}
		return cc.pointPixelsToPoints(c)
	},
	getProperty: function(a) {
		return this.properties[a]
	},
	setupTiles: function() {
		this._renderCmd.initImageSize();
		this._parseInternalProperties();
		cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
		for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; c < a; c++)
		for (var d = 0; d < b; d++) {
			var e = this.tiles[d + b * c];
			0 !== e && (this._appendTileForGID(e, cc.p(d, c)), this._minGID = Math.min(e, this._minGID), this._maxGID = Math.max(e, this._maxGID))
		}
		this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
	},
	addChild: function(a, b, c) {
		cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
	},
	removeChild: function(a, b) {
		if (a) if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
		else {
			cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
			var c = a.atlasIndex;
			this.tiles[this._atlasIndexArray[c]] = 0;
			this._atlasIndexArray.splice(c, 1);
			cc.SpriteBatchNode.prototype.removeChild.call(this, a, b);
			cc.renderer.childrenOrderDirty = !0
		}
	},
	getLayerName: function() {
		return this.layerName
	},
	setLayerName: function(a) {
		this.layerName = a
	},
	_positionForIsoAt: function(a) {
		return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
	},
	_positionForOrthoAt: function(a) {
		return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
	},
	_positionForHexAt: function(a) {
		return cc.p(3 * a.x * this._mapTileSize.width / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + (1 === a.x % 2 ? -this._mapTileSize.height / 2 : 0))
	},
	_calculateLayerOffset: function(a) {
		var b = cc.p(0, 0);
		switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ORTHO:
			b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
			break;
		case cc.TMX_ORIENTATION_ISO:
			b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
			break;
		case cc.TMX_ORIENTATION_HEX:
			(0 !== a.x || 0 !== a.y) && cc.log("offset for hexagonal map not implemented yet")
		}
		return b
	},
	_appendTileForGID: function(a, b) {
		var c = this.tileset.rectForGID(a),
			c = cc.rectPixelsToPoints(c),
			d = 0 | b.x + b.y * this._layerSize.width,
			c = this._renderCmd._reusedTileWithRect(c);
		this._setupTileSprite(c, b, a);
		var e = this._atlasIndexArray.length;
		this.insertQuadFromSprite(c, e);
		this._atlasIndexArray.splice(e, 0, d);
		return c
	},
	_insertTileForGID: function(a, b) {
		var c = this.tileset.rectForGID(a),
			c = cc.rectPixelsToPoints(c),
			d = 0 | b.x + b.y * this._layerSize.width,
			c = this._renderCmd._reusedTileWithRect(c);
		this._setupTileSprite(c, b, a);
		var e = this._atlasIndexForNewZ(d);
		this.insertQuadFromSprite(c, e);
		this._atlasIndexArray.splice(e, 0, d);
		if (this._children) for (var f = this._children, k = 0, m = f.length; k < m; k++) {
			var n = f[k];
			if (n) {
				var p = n.atlasIndex;
				p >= e && (n.atlasIndex = p + 1)
			}
		}
		this.tiles[d] = a;
		return c
	},
	_updateTileForGID: function(a, b) {
		var c = this.tileset.rectForGID(a),
			d = this._contentScaleFactor,
			c = cc.rect(c.x / d, c.y / d, c.width / d, c.height / d),
			d = b.x + b.y * this._layerSize.width,
			c = this._renderCmd._reusedTileWithRect(c);
		this._setupTileSprite(c, b, a);
		c.atlasIndex = this._atlasIndexForExistantZ(d);
		c.dirty = !0;
		c.updateTransform();
		this.tiles[d] = a;
		return c
	},
	_parseInternalProperties: function() {
		var a = this.getProperty("cc_vertexz");
		if (a) if ("automatic" === a) {
			this._useAutomaticVertexZ = !0;
			var b = this.getProperty("cc_alpha_func"),
				a = 0;
			b && (a = parseFloat(b));
			cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), b = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(b, a))
		} else this._vertexZvalue = parseInt(a, 10)
	},
	_setupTileSprite: function(a, b, c) {
		var d = b.x + b.y * this._layerSize.width;
		a.setPosition(this.getPositionAt(b));
		cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d;
		a.anchorX = 0;
		a.anchorY = 0;
		a.opacity = this._opacity;
		cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0);
		a.setFlippedX(!1);
		a.setFlippedY(!1);
		(c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, b === cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b === cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
	},
	_vertexZForPos: function(a) {
		var b = 0,
			c = 0;
		if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
		case cc.TMX_ORIENTATION_ISO:
			c = this._layerSize.width + this._layerSize.height;
			b = -(c - (a.x + a.y));
			break;
		case cc.TMX_ORIENTATION_ORTHO:
			b = -(this._layerSize.height - a.y);
			break;
		case cc.TMX_ORIENTATION_HEX:
			cc.log("TMX Hexa zOrder not supported");
			break;
		default:
			cc.log("TMX invalid value")
		} else b = this._vertexZvalue;
		return b
	},
	_atlasIndexForExistantZ: function(a) {
		var b;
		if (this._atlasIndexArray) for (var c = this._atlasIndexArray, d = 0, e = c.length; d < e && !(b = c[d], b === a); d++);
		cc.isNumber(b) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
		return d
	},
	_atlasIndexForNewZ: function(a) {
		for (var b = this._atlasIndexArray, c = 0, d = b.length; c < d && !(a < b[c]); c++);
		return c
	}
});
_p = cc.TMXLayer.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(a, b, c) {
	return new cc.TMXLayer(a, b, c)
};
(function() {
	cc.TMXLayer.CanvasRenderCmd = function(a) {
		cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
		this._needDraw = !0;
		this._realWorldTransform = {
			a: 1,
			b: 0,
			c: 0,
			d: 1,
			tx: 0,
			ty: 0
		};
		var c = cc._canvas;
		a = cc.newElement("canvas");
		a.width = c.width;
		a.height = c.height;
		this._cacheCanvas = a;
		this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
		c = new cc.Texture2D;
		c.initWithElement(a);
		c.handleLoadedTexture();
		this._cacheTexture = c;
		this._cacheDirty = !1
	};
	var a = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
	a.constructor = cc.TMXLayer.CanvasRenderCmd;
	a._setNodeDirtyForCache = function() {
		this._cacheDirty = !0
	};
	a._renderingChildToCache = function() {
		if (this._cacheDirty) {
			var a = this._cacheContext,
				c = a.getContext(),
				d = this._cacheCanvas;
			c.setTransform(1, 0, 0, 1, 0, 0);
			c.clearRect(0, 0, d.width, d.height);
			for (var c = this._node._children, d = 0, e = c.length; d < e; d++)
			if (c[d]) {
				var f = c[d]._renderCmd;
				f && (f.rendering(a, 1, 1), f._cacheDirty = !1)
			}
			this._cacheDirty = !1
		}
	};
	a.rendering = function(a, c, d) {
		var e = this._displayedOpacity / 255;
		if (!(0 >= e)) {
			var f = this._node;
			this._renderingChildToCache();
			var k = a || cc._renderContext;
			a = k.getContext();
			k.setGlobalAlpha(e);
			if ((e = this._cacheCanvas) && 0 !== e.width && 0 !== e.height) k.setTransform(this._realWorldTransform, c, d), k = e.height * d, f.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e, 0, 0, e.width, e.height, 0, -k + 0.5 * f._mapTileSize.height * d, e.width * c, k) : a.drawImage(e, 0, 0, e.width, e.height, 0, -k, e.width * c, k);
			cc.g_NumberOfDraws++
		}
	};
	a._updateCacheContext = function(a, c) {
		var d = this._node,
			e = d._contentSize,
			f = this._cacheCanvas,
			k = cc.contentScaleFactor();
		f.width = 0 | 1.5 * e.width * k;
		f.height = 0 | 1.5 * e.height * k;
		d.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.setOffset(0, 0.5 * -d._mapTileSize.height) : this._cacheContext.setOffset(0, 0);
		d = this._cacheTexture._contentSize;
		d.width = f.width;
		d.height = f.height
	};
	a.getTexture = function() {
		return this._cacheTexture
	};
	a.visit = function(a) {
		var c = this._node,
			d, e = c._children;
		if (c._visible && e && 0 !== e.length) {
			if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
			this._syncStatus(a);
			if (this._cacheDirty) {
				a = this._cacheContext;
				var f = this._cacheCanvas,
					k = a.getContext(),
					m = c.__instanceId,
					n = cc.renderer;
				n._turnToCacheMode(m);
				c.sortAllChildren();
				c = 0;
				for (d = e.length; c < d; c++)
				if (e[c]) {
					var p = e[c]._renderCmd;
					p && (p.visit(this), p._cacheDirty = !1)
				}
				k.setTransform(1, 0, 0, 1, 0, 0);
				k.clearRect(0, 0, f.width, f.height);
				n._renderingToCacheCanvas(a, m);
				this._cacheDirty = !1
			}
			cc.renderer.pushRenderCommand(this);
			this._dirtyFlag = 0
		}
	};
	a.transform = function(a, c) {
		var d = this.getNodeToParentTransform(),
			e = this._realWorldTransform;
		if (a) {
			var f = a._worldTransform;
			e.a = d.a * f.a + d.b * f.c;
			e.b = d.a * f.b + d.b * f.d;
			e.c = d.c * f.a + d.d * f.c;
			e.d = d.c * f.b + d.d * f.d;
			e.tx = f.a * d.tx + f.c * d.ty + f.tx;
			e.ty = f.d * d.ty + f.ty + f.b * d.tx
		} else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
		if (c && (d = this._node._children) && 0 !== d.length) {
			e = 0;
			for (f = d.length; e < f; e++) d[e]._renderCmd.transform(this, c)
		}
	};
	a.initImageSize = function() {
		this._node.tileset.imageSize = this._originalTexture.getContentSizeInPixels()
	};
	a._reusedTileWithRect = function(a) {
		var c = this._node;
		c._reusedTile = new cc.Sprite;
		c._reusedTile.initWithTexture(c._renderCmd._texture, a, !1);
		c._reusedTile.batchNode = c;
		c._reusedTile.parent = c;
		c._reusedTile._renderCmd._cachedParent = c._renderCmd;
		return c._reusedTile
	}
})();
(function() {
	cc.TMXLayer.WebGLRenderCmd = function(a) {
		cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
		this._needDraw = !0
	};
	var a = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
	a.constructor = cc.TMXLayer.WebGLRenderCmd;
	a._updateCacheContext = function() {};
	a.initImageSize = function() {
		this._node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels();
		this._textureAtlas.texture.setAliasTexParameters()
	};
	a._reusedTileWithRect = function(a) {
		var c = this._node;
		c._reusedTile ? (c._reusedTile.batchNode = null, c._reusedTile.setTextureRect(a, !1)) : (c._reusedTile = new cc.Sprite, c._reusedTile.initWithTexture(c.texture, a, !1));
		c._reusedTile.batchNode = c;
		return c._reusedTile
	}
})();
cc.PointObject = cc.Class.extend({
	_ratio: null,
	_offset: null,
	_child: null,
	ctor: function(a, b) {
		this.initWithCCPoint(a, b)
	},
	getRatio: function() {
		return this._ratio
	},
	setRatio: function(a) {
		this._ratio = a
	},
	getOffset: function() {
		return this._offset
	},
	setOffset: function(a) {
		this._offset = a
	},
	getChild: function() {
		return this._child
	},
	setChild: function(a) {
		this._child = a
	},
	initWithCCPoint: function(a, b) {
		this._ratio = a;
		this._offset = b;
		this._child = null;
		return !0
	}
});
cc.PointObject.create = function(a, b) {
	return new cc.PointObject(a, b)
};
cc.ParallaxNode = cc.Node.extend({
	parallaxArray: null,
	_lastPosition: null,
	_className: "ParallaxNode",
	getParallaxArray: function() {
		return this.parallaxArray
	},
	setParallaxArray: function(a) {
		this.parallaxArray = a
	},
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this.parallaxArray = [];
		this._lastPosition = cc.p(-100, -100)
	},
	addChild: function(a, b, c, d) {
		if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
		else {
			if (!a) throw Error("cc.ParallaxNode.addChild(): child should be non-null");
			var e = new cc.PointObject(c, d);
			e.setChild(a);
			this.parallaxArray.push(e);
			a.setPosition(this._position.x * c.x + d.x, this._position.y * c.y + d.y);
			cc.Node.prototype.addChild.call(this, a, b, a.tag)
		}
	},
	removeChild: function(a, b) {
		for (var c = this.parallaxArray, d = 0; d < c.length; d++)
		if (c[d].getChild() === a) {
			c.splice(d, 1);
			break
		}
		cc.Node.prototype.removeChild.call(this, a, b)
	},
	removeAllChildren: function(a) {
		this.parallaxArray.length = 0;
		cc.Node.prototype.removeAllChildren.call(this, a)
	},
	_updateParallaxPosition: function() {
		var a = this._absolutePosition();
		if (!cc.pointEqualToPoint(a, this._lastPosition)) {
			for (var b = this.parallaxArray, c = 0, d = b.length; c < d; c++) {
				var e = b[c];
				e.getChild().setPosition(-a.x + a.x * e.getRatio().x + e.getOffset().x, -a.y + a.y * e.getRatio().y + e.getOffset().y)
			}
			this._lastPosition = a
		}
	},
	_absolutePosition: function() {
		for (var a = this._position, b = this; null !== b.parent;) b = b.parent, a = cc.pAdd(a, b.getPosition());
		return a
	},
	_createRenderCmd: function() {
		return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
	}
});
cc.ParallaxNode.create = function() {
	return new cc.ParallaxNode
};
(function() {
	cc.ParallaxNode.CanvasRenderCmd = function(a) {
		cc.Node.CanvasRenderCmd.call(this, a);
		this._needDraw = !1
	};
	var a = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
	a.constructor = cc.ParallaxNode.CanvasRenderCmd;
	a.updateStatus = function() {
		this._node._updateParallaxPosition();
		cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
	};
	a._syncStatus = function(a) {
		this._node._updateParallaxPosition();
		cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, a)
	}
})();
(function() {
	if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
		cc.ParallaxNode.WebGLRenderCmd = function(a) {
			cc.Node.WebGLRenderCmd.call(this, a);
			this._needDraw = !1
		};
		var a = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
		a.constructor = cc.ParallaxNode.WebGLRenderCmd;
		a.updateStatus = function() {
			this._node._updateParallaxPosition();
			cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
		};
		a._syncStatus = function(a) {
			this._node._updateParallaxPosition();
			cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, a)
		}
	}
})();
(function() {
	var a = cc.sys,
		b = {
			common: {
				multichannel: !0,
				webAudio: cc.sys._supportWebAudio,
				auto: !0
			}
		};
	b[a.BROWSER_TYPE_IE] = {
		multichannel: !0,
		webAudio: cc.sys._supportWebAudio,
		auto: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_ANDROID] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1
	};
	b[a.BROWSER_TYPE_CHROME] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1
	};
	b[a.BROWSER_TYPE_FIREFOX] = {
		multichannel: !0,
		webAudio: !0,
		auto: !0,
		delay: !0
	};
	b[a.BROWSER_TYPE_UC] = {
		multichannel: !0,
		webAudio: !1,
		auto: !1
	};
	b[a.BROWSER_TYPE_QQ] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	b[a.BROWSER_TYPE_OUPENG] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_WECHAT] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_360] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	b[a.BROWSER_TYPE_MIUI] = {
		multichannel: !1,
		webAudio: !1,
		auto: !0
	};
	b[a.BROWSER_TYPE_LIEBAO] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_SOUGOU] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_BAIDU] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_BAIDU_APP] = {
		multichannel: !1,
		webAudio: !1,
		auto: !1,
		replay: !0,
		emptied: !0
	};
	b[a.BROWSER_TYPE_SAFARI] = {
		multichannel: !0,
		webAudio: !0,
		auto: !1,
		webAudioCallback: function(a) {
			document.createElement("audio").src = a
		}
	};
	var c, d;
	try {
		var e = navigator.userAgent.toLowerCase();
		switch (a.browserType) {
		case a.BROWSER_TYPE_IE:
			d = e.match(/(msie |rv:)([\d.]+)/);
			break;
		case a.BROWSER_TYPE_FIREFOX:
			d = e.match(/(firefox\/|rv:)([\d.]+)/);
			break;
		case a.BROWSER_TYPE_CHROME:
			d = e.match(/chrome\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_BAIDU:
			d = e.match(/baidubrowser\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_UC:
			d = e.match(/ucbrowser\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_QQ:
			d = e.match(/qqbrowser\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_OUPENG:
			d = e.match(/oupeng\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_WECHAT:
			d = e.match(/micromessenger\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_SAFARI:
			d = e.match(/safari\/([\d.]+)/);
			break;
		case a.BROWSER_TYPE_MIUI:
			d = e.match(/miuibrowser\/([\d.]+)/)
		}
		c = d ? d[1] : ""
	} catch (f) {
		console.log(f)
	}
	if (cc.sys.isMobile) cc.__audioSupport = cc.sys.os !== cc.sys.OS_IOS ? b[a.browserType] || b.common : b[a.BROWSER_TYPE_SAFARI];
	else switch (a.browserType) {
	case a.BROWSER_TYPE_IE:
		cc.__audioSupport = b[a.BROWSER_TYPE_IE];
		break;
	case a.BROWSER_TYPE_FIREFOX:
		cc.__audioSupport = b[a.BROWSER_TYPE_FIREFOX];
		break;
	default:
		cc.__audioSupport = b.common
	}
	if (c) switch (a.browserType) {
	case a.BROWSER_TYPE_CHROME:
		c = parseInt(c);
		30 > c ? cc.__audioSupport = {
			multichannel: !1,
			webAudio: !0,
			auto: !1
		} : 42 === c && (cc.__audioSupport.manualLoop = !0);
		break;
	case a.BROWSER_TYPE_MIUI:
		if (cc.sys.isMobile && (c = c.match(/\d+/g), 2 > c[0] || 2 === c[0] && 0 === c[1] && 1 >= c[2])) cc.__audioSupport.auto = !1
	}
})();
cc.Audio = cc.Class.extend({
	volume: 1,
	loop: !1,
	src: null,
	_touch: !1,
	_playing: !1,
	_AUDIO_TYPE: "AUDIO",
	_pause: !1,
	_buffer: null,
	_currentSource: null,
	_startTime: null,
	_currentTime: null,
	_context: null,
	_volume: null,
	_ignoreEnded: !1,
	_manualLoop: !1,
	_element: null,
	ctor: function(a, b, c) {
		a && (this._context = a);
		b && (this._volume = b);
		a && b && (this._AUDIO_TYPE = "WEBAUDIO");
		this.src = c
	},
	_setBufferCallback: null,
	setBuffer: function(a) {
		if (a) {
			var b = this._playing;
			this._AUDIO_TYPE = "WEBAUDIO";
			this._buffer && (this._buffer !== a && this.getPlaying()) && this.stop();
			this._buffer = a;
			b && this.play();
			this._volume.gain.value = this.volume;
			this._setBufferCallback && this._setBufferCallback(a)
		}
	},
	_setElementCallback: null,
	setElement: function(a) {
		if (a) {
			var b = this._playing;
			this._AUDIO_TYPE = "AUDIO";
			this._element && (this._element !== a && this.getPlaying()) && this.stop();
			this._element = a;
			b && this.play();
			a.volume = this.volume;
			a.loop = this.loop;
			this._setElementCallback && this._setElementCallback(a)
		}
	},
	play: function(a, b) {
		this._playing = !0;
		this.loop = void 0 === b ? this.loop : b;
		"AUDIO" === this._AUDIO_TYPE ? this._playOfAudio(a) : this._playOfWebAudio(a)
	},
	getPlaying: function() {
		if (!this._playing) return !1;
		if ("AUDIO" === this._AUDIO_TYPE) {
			var a = this._element;
			return !a || this._pause || a.ended ? this._playing = !1 : !0
		}
		a = this._currentSource;
		return !a || !a.playbackState ? !0 : this._currentTime + this._context.currentTime - this._startTime < a.buffer.duration
	},
	_playOfWebAudio: function(a) {
		var b = this._currentSource;
		if (this._buffer) {
			if (!this._pause && b) if (0 === this._context.currentTime || this._currentTime + this._context.currentTime - this._startTime > b.buffer.duration) this._stopOfWebAudio();
			else return;
			b = this._context.createBufferSource();
			b.buffer = this._buffer;
			b.connect(this._volume);
			b.loop = this._manualLoop ? !1 : this.loop;
			this._startTime = this._context.currentTime;
			this._currentTime = a || 0;
			this._ignoreEnded = !1;
			if (b.start) b.start(0, a || 0);
			else if (b.noteGrainOn) {
				var c = b.buffer.duration;
				this.loop ? b.noteGrainOn(0, a, c) : b.noteGrainOn(0, a, c - a)
			} else b.noteOn(0);
			this._currentSource = b;
			var d = this;
			b.onended = function() {
				d._manualLoop && d._playing && d.loop ? (d.stop(), d.play()) : d._ignoreEnded ? d._ignoreEnded = !1 : d._pause ? d._playing = !1 : d.stop()
			}
		}
	},
	_playOfAudio: function() {
		var a = this._element;
		a && (a.loop = this.loop, a.play())
	},
	stop: function() {
		this._playing = !1;
		"AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
	},
	_stopOfWebAudio: function() {
		var a = this._currentSource;
		this._ignoreEnded = !0;
		a && (a.stop(0), this._currentSource = null)
	},
	_stopOfAudio: function() {
		var a = this._element;
		a && (a.pause(), a.duration && Infinity !== a.duration && (a.currentTime = 0))
	},
	pause: function() {
		!1 !== this.getPlaying() && (this._playing = !1, this._pause = !0, "AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio())
	},
	_pauseOfWebAudio: function() {
		this._currentTime += this._context.currentTime - this._startTime;
		var a = this._currentSource;
		a && a.stop(0)
	},
	_pauseOfAudio: function() {
		var a = this._element;
		a && a.pause()
	},
	resume: function() {
		this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(), this._pause = !1, this._playing = !0)
	},
	_resumeOfWebAudio: function() {
		var a = this._currentSource;
		a && (this._startTime = this._context.currentTime, this._playOfWebAudio(this._currentTime % a.buffer.duration))
	},
	_resumeOfAudio: function() {
		var a = this._element;
		a && a.play()
	},
	setVolume: function(a) {
		1 < a && (a = 1);
		0 > a && (a = 0);
		this.volume = a;
		"AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = a) : this._volume && (this._volume.gain.value = a)
	},
	getVolume: function() {
		return this.volume
	},
	cloneNode: function() {
		var a, b;
		if ("AUDIO" === this._AUDIO_TYPE) {
			a = new cc.Audio;
			var c = document.createElement("audio");
			c.src = this.src;
			a.setElement(c)
		} else c = this._context.createGain(), c.gain.value = 1, c.connect(this._context.destination), a = new cc.Audio(this._context, c, this.src), this._buffer ? a.setBuffer(this._buffer) : (b = this, this._setBufferCallback = function(c) {
			a.setBuffer(c);
			b._setBufferCallback = null
		}), a._manualLoop = this._manualLoop;
		a._AUDIO_TYPE = this._AUDIO_TYPE;
		return a
	}
});
(function(a) {
	var b = a.webAudio,
		c = a.multichannel,
		d = a.auto,
		e = [];
	(function() {
		var a = document.createElement("audio");
		if (a.canPlayType) {
			var b = a.canPlayType('audio/ogg; codecs="vorbis"');
			b && "" !== b && e.push(".ogg");
			(b = a.canPlayType("audio/mpeg")) && "" !== b && e.push(".mp3");
			(b = a.canPlayType('audio/wav; codecs="1"')) && "" !== b && e.push(".wav");
			(b = a.canPlayType("audio/mp4")) && "" !== b && e.push(".mp4");
			(a = a.canPlayType("audio/x-m4a")) && "" !== a && e.push(".m4a")
		}
	})();
	try {
		if (b) {
			var f = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
			a.delay && setTimeout(function() {
				f = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
			}, 0)
		}
	} catch (k) {
		b = !1, cc.log("browser don't support webAudio")
	}
	var m = {
		cache: {},
		load: function(c, d, k, n) {
			if (0 === e.length) return n("can not support audio!");
			cc.loader.audioPath && (c = cc.path.join(cc.loader.audioPath, c));
			var t = cc.path.extname(c),
				w = [t];
			for (k = 0; k < e.length; k++) t !== e[k] && w.push(e[k]);
			var v;
			if (m.cache[d]) return n(null, m.cache[d]);
			if (b) try {
				var y = f.createGain();
				y.gain.value = 1;
				y.connect(f.destination);
				v = new cc.Audio(f, y, c);
				a.manualLoop && (v._manualLoop = !0)
			} catch (z) {
				b = !1, cc.log("browser don't support webAudio"), v = new cc.Audio(null, null, c)
			} else v = new cc.Audio(null, null, c);
			this.loadAudioFromExtList(c, w, v, n);
			m.cache[d] = v
		},
		loadAudioFromExtList: function(c, d, k, n) {
			if (0 === d.length) {
				var t = "can not found the resource of audio! Last match url is : ",
					t = t + c.replace(/\.(.*)?$/, "(");
				e.forEach(function(a) {
					t += a + "|"
				});
				t = t.replace(/\|$/, ")");
				return n({
					status: 520,
					errorMessage: t
				}, null)
			}
			c = cc.path.changeExtname(c, d.splice(0, 1));
			if (b) {
				a.webAudioCallback && a.webAudioCallback(c);
				var w = new XMLHttpRequest;
				w.open("GET", c, !0);
				w.responseType = "arraybuffer";
				w.onload = function() {
					f.decodeAudioData(w.response, function(a) {
						k.setBuffer(a);
						n(null, k)
					}, function() {
						m.loadAudioFromExtList(c, d, k, n)
					})
				};
				w.onerror = function() {
					n({
						status: 520,
						errorMessage: t
					}, null)
				};
				w.send()
			} else {
				var v = document.createElement("audio"),
					y = !1,
					z = !1,
					F = setTimeout(function() {
						0 === v.readyState ? A() : (z = !0, v.pause(), document.body.removeChild(v), n("audio load timeout : " + c, k))
					}, 1E4),
					E = function() {
						if (!y) {
							v.pause();
							try {
								v.currentTime = 0, v.volume = 1
							} catch (a) {}
							document.body.removeChild(v);
							k.setElement(v);
							v.removeEventListener("canplaythrough", E, !1);
							v.removeEventListener("error", C, !1);
							v.removeEventListener("emptied", A, !1);
							!z && n(null, k);
							y = !0;
							clearTimeout(F)
						}
					},
					C = function() {
						y && (v.pause(), document.body.removeChild(v), v.removeEventListener("canplaythrough", E, !1), v.removeEventListener("error", C, !1), v.removeEventListener("emptied", A, !1), !z && m.loadAudioFromExtList(c, d, k, n), y = !0, clearTimeout(F))
					},
					A = function() {
						z = !0;
						E();
						n(null, k)
					};
				cc._addEventListener(v, "canplaythrough", E, !1);
				cc._addEventListener(v, "error", C, !1);
				a.emptied && cc._addEventListener(v, "emptied", A, !1);
				v.src = c;
				document.body.appendChild(v);
				v.volume = 0;
				v.play()
			}
		}
	};
	cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], m);
	cc.audioEngine = {
		_currMusic: null,
		_musicVolume: 1,
		willPlayMusic: function() {
			return !1
		},
		playMusic: function(a, b) {
			var c = this._currMusic;
			c && (c.src !== a && c.getPlaying()) && c.stop();
			c = m.cache[a];
			c || (cc.loader.load(a), c = m.cache[a]);
			c.play(0, b);
			c.setVolume(this._musicVolume);
			this._currMusic = c
		},
		stopMusic: function(a) {
			var b = this._currMusic;
			b && (b.stop(), a && cc.loader.release(b.src))
		},
		pauseMusic: function() {
			var a = this._currMusic;
			a && a.pause()
		},
		resumeMusic: function() {
			var a = this._currMusic;
			a && a.resume()
		},
		rewindMusic: function() {
			var a = this._currMusic;
			a && (a.stop(), a.play())
		},
		getMusicVolume: function() {
			return this._musicVolume
		},
		setMusicVolume: function(a) {
			a -= 0;
			isNaN(a) && (a = 1);
			1 < a && (a = 1);
			0 > a && (a = 0);
			this._musicVolume = a;
			var b = this._currMusic;
			b && b.setVolume(a)
		},
		isMusicPlaying: function() {
			var a = this._currMusic;
			return a ? a.getPlaying() : !1
		},
		_audioPool: {},
		_maxAudioInstance: 5,
		_effectVolume: 1,
		playEffect: function(a, d) {
			if (!c) return null;
			var e = this._audioPool[a];
			e || (e = this._audioPool[a] = []);
			var f;
			for (f = 0; f < e.length && e[f].getPlaying(); f++);
			if (e[f]) k = e[f], k.setVolume(this._effectVolume), k.play(0, d);
			else if (!b && f > this._maxAudioInstance) cc.log("Error: %s greater than %d", a, this._maxAudioInstance);
			else {
				var k = m.cache[a];
				k || (cc.loader.load(a), k = m.cache[a]);
				k = k.cloneNode();
				k.setVolume(this._effectVolume);
				k.loop = d || !1;
				k.play();
				e.push(k)
			}
			return k
		},
		setEffectsVolume: function(a) {
			a -= 0;
			isNaN(a) && (a = 1);
			1 < a && (a = 1);
			0 > a && (a = 0);
			this._effectVolume = a;
			var b = this._audioPool,
				c;
			for (c in b) {
				var d = b[c];
				if (Array.isArray(d)) for (var e = 0; e < d.length; e++) d[e].setVolume(a)
			}
		},
		getEffectsVolume: function() {
			return this._effectVolume
		},
		pauseEffect: function(a) {
			a && a.pause()
		},
		pauseAllEffects: function() {
			var a = this._audioPool,
				b;
			for (b in a)
			for (var c = a[b], d = 0; d < a[b].length; d++) c[d].getPlaying() && c[d].pause()
		},
		resumeEffect: function(a) {
			a && a.resume()
		},
		resumeAllEffects: function() {
			var a = this._audioPool,
				b;
			for (b in a)
			for (var c = a[b], d = 0; d < a[b].length; d++) c[d].resume()
		},
		stopEffect: function(a) {
			a && a.stop()
		},
		stopAllEffects: function() {
			var a = this._audioPool,
				b;
			for (b in a)
			for (var c = a[b], d = 0; d < a[b].length; d++) c[d].stop()
		},
		unloadEffect: function(a) {
			if (a) {
				cc.loader.release(a);
				var b = this._audioPool[a];
				b && (b.length = 0);
				delete this._audioPool[a];
				delete m.cache[a]
			}
		},
		end: function() {
			this.stopMusic();
			this.stopAllEffects()
		},
		_pauseCache: [],
		_pausePlaying: function() {
			var a = this._currMusic;
			a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
			var a = this._audioPool,
				b;
			for (b in a)
			for (var c = a[b], d = 0; d < a[b].length; d++) c[d].getPlaying() && (c[d].pause(), this._pauseCache.push(c[d]))
		},
		_resumePlaying: function() {
			for (var a = this._pauseCache, b = 0; b < a.length; b++) a[b].resume();
			a.length = 0
		}
	};
	if (!d) {
		var n = function() {
				var b = cc.audioEngine._currMusic;
				b && (!1 === b._touch && b._playing && b.getPlaying()) && (b._touch = !0, b.play(0, b.loop), !a.replay && cc._canvas.removeEventListener("touchstart", n))
			};
		setTimeout(function() {
			cc._canvas && cc._canvas.addEventListener("touchstart", n, !1)
		}, 150)
	}
	cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
		cc.audioEngine._pausePlaying()
	});
	cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
		cc.audioEngine._resumePlaying()
	})
})(cc.__audioSupport);
PTM_RATIO = 32;
RADIAN_TO_DEGREE = 180 / Math.PI;
DEGREE_TO_RADIAN = Math.PI / 180;
IMAGE_TYPES = [".png", ".jpg", ".bmp", ".jpeg", ".gif"];
SOUND_TYPES = [".mp3", ".ogg", ".wav", ".mp4", ".m4a"];
DEFAULT_SOUNDS_FOLDER = "res/music/";
H_ALIGHS = ["left", "center", "right"];
RESET_FRAME_ON_RECYCLE = !0;
var TileValue = TileValue || {
	WALKABLE: 0,
	BLOCK1: 1,
	BLOCK2: 2,
	BLOCK3: 3,
	BLOCK4: 4,
	BLOCK5: 5
},
	flax = flax || {};
window.flax = flax;
flax.version = 2.4;
flax.gameVersion = 0;
flax.minToolVersion = 2;
flax.language = null;
flax.languageIndex = -1;
flax.languages = "zh en de fr it es tr pt ru".split(" ");
flax.landscape = !1;
flax.stageRect = null;
flax.designedStageSize = null;
flax.osVersion = "unknown";
flax.assetsManager = null;
flax.inputManager = null;
flax.mousePos = null;
flax.currentSceneName = null;
flax.currentScene = null;
flax.prevSceneName = null;
flax.buttonSound = null;
flax.frameInterval = 1 / 60;
flax.pointZero = {
	x: 0,
	y: 0
};
flax._scenesDict = {};
flax._soundEnabled = !0;
flax._inited = !1;
flax._orientationTip = null;
flax._languageDict = null;
flax._languageToLoad = null;
flax.onDeviceRotate = null;
flax.onScreenResize = null;
flax.onSceneExit = null;
flax.onSceneEnter = null;
flax._addResVersion = function(a) {
	return cc.sys.isNative || ("string" != typeof a || flax.isSoundFile(a)) || -1 < a.indexOf("?v=") ? a : a + "?v=" + (flax.gameVersion || cc.game.config.version)
};
flax._removeResVersion = function(a) {
	if (cc.sys.isNative || "string" != typeof a || flax.isSoundFile(a)) return a;
	var b = a.indexOf("?v="); - 1 < b && (a = a.substr(0, b));
	return a
};
flax.isDomainAllowed = function() {
	if (cc.sys.isNative) return !0;
	var a = document.domain,
		b = cc.game.config.domainAllowed;
	return flax.isLocalDebug() || null == b || 0 == b.length || -1 < b.indexOf(a)
};
flax.isLocalDebug = function() {
	if (cc.sys.isNative) return !1;
	var a = document.domain;
	return "localhost" == a || 0 == a.indexOf("192.168.")
};
if (!cc.sys.isNative && (flax.isLocalDebug() && (flax.gameVersion = 1 + Math.floor(999998 * Math.random())), setTimeout(function() {
	var a = document.body.style.backgroundColor;
	document.getElementById(cc.game.config.id).style.backgroundColor = a;
	a = a.replace("rgb(", "");
	a = a.replace(")", "");
	a = a.split(",");
	flax.bgColor = cc.color(parseInt(a[0]), parseInt(a[1]), parseInt(a[2]))
}, 0.01), cc.sys.isMobile)) {
	var __hideBottomBar = function() {
			document.body.scrollTop = 0
		},
		orientationEvent = "onorientationchange" in window ? "orientationchange" : "resize";
	window.addEventListener(orientationEvent, __hideBottomBar, !0);
	__hideBottomBar()
}
flax.init = function(a, b, c) {
	if (!flax._inited) {
		flax._inited = !0;
		cc.log("Flax inited, version: " + flax.version);
		null == a && (a = cc.sys.isMobile ? cc.ResolutionPolicy.NO_BORDER : cc.ResolutionPolicy.SHOW_ALL);
		flax.fetchUserData && flax.fetchUserData(b);
		flax._checkOSVersion();
		b = c ? c.width : cc.game.config.width;
		c = c ? c.height : cc.game.config.height;
		if (!b || !c) throw "Please set the game width and height in the project.json!";
		if (cc.sys.isNative) cc.view.setDesignResolutionSize(b, c, a);
		else {
			var d = document.getElementById(cc.game.config.id);
			d.width = b = b || d.width;
			d.height = c = c || d.height;
			cc.view.adjustViewPort(!0);
			cc.view.setDesignResolutionSize(b, c, a);
			cc.view.resizeWithBrowserSize(!0)
		}
		flax.designedStageSize = cc.size(b, c);
		flax.frameInterval = 1 / cc.game.config.frameRate;
		flax.assetsManager = flax.AssetsManager.create();
		a = cc.game.config.language;
		null == a || "" == a ? null == flax.language && (a = cc.sys.language, flax.updateLanguage(a)) : flax.updateLanguage(a);
		flax.stageRect = cc.rect(cc.visibleRect.bottomLeft.x, cc.visibleRect.bottomLeft.y, cc.visibleRect.width, cc.visibleRect.height);
		flax.onDeviceRotate = new signals.Signal;
		flax.onScreenResize = new signals.Signal;
		flax.onSceneExit = new signals.Signal;
		flax.onSceneEnter = new signals.Signal;
		cc.sys.isNative || window.addEventListener("resize", function() {
			flax.stageRect = cc.rect(cc.visibleRect.bottomLeft.x, cc.visibleRect.bottomLeft.y, cc.visibleRect.width, cc.visibleRect.height);
			flax.onScreenResize.dispatch()
		}, !1)
	}
};
flax.getLanguageStr = function(a, b) {
	if (null == flax._languageDict) return cc.log("Warning: there is no language defined: " + flax.language), null;
	var c = flax._languageDict[a];
	if (null == c) cc.log("Warning: there is no language string for key: " + a);
	else if (b) for (a in b) c = c.replace(RegExp("{" + a + "}", "g"), b[a]);
	return c
};
flax.updateLanguage = function(a) {
	null == a || ("" == a || a == flax.language) || (flax.language = a, cc.game.config.languages && cc.game.config.languages.length && (flax.languages = cc.game.config.languages), flax.languageIndex = flax.languages.indexOf(a), -1 == flax.languageIndex && cc.log("Invalid language: " + a), cc.game.config.languageJson && (flax._languageToLoad = flax._getLanguagePath(a)))
};
flax._getLanguagePath = function(a) {
	return "res/locale/" + (a || flax.language) + ".json"
};
flax.createDisplay = function(a, b, c, d, e) {
	return flax.assetsManager.createDisplay(a, b, c, d, e)
};
flax.addListener = function(a, b, c, d) {
	flax.inputManager.addListener(a, b, c, d)
};
flax.removeListener = function(a, b, c) {
	flax.inputManager.removeListener(a, b, c)
};
flax.addModule = function(a, b, c) {
	if (null == b) throw "Module can not be null!";
	for (var d in b)
	if (0 == d.indexOf("on")) {
		var e = "__" + d,
			f = e + "Num";
		void 0 === a.prototype[f] ? a.prototype[f] = 0 : a.prototype[f]++;
		a.prototype[e + a.prototype[f]] = b[d]
	} else if (!0 === c || !a.prototype[d])(e = b[d]) && ("function" === typeof e.get || "function" === typeof e.set) ? "function" === typeof e.clone ? a.prototype[d] = e.clone() : Object.defineProperty(a.prototype, d, e) : a.prototype[d] = e
};
flax.callModuleFunction = function(a, b, c) {
	b = "__" + b;
	var d = a[b + "Num"];
	if (void 0 !== d) for (; 0 <= d;) a[b + d](c), d--;
	else if (a[b]) a[b](c)
};
flax.callModuleOnEnter = function(a) {
	flax.callModuleFunction(a, "onEnter")
};
flax.callModuleOnExit = function(a) {
	flax.callModuleFunction(a, "onExit")
};
flax._checkOSVersion = function() {
	if (!cc.sys.isNative) {
		var a = navigator.userAgent,
			b;
		a.match(/iPad/i) || a.match(/iPhone/i) ? (b = a.indexOf("OS "), cc.sys.os = cc.sys.OS_IOS, -1 < b && (flax.osVersion = a.substr(b + 3, 3).replace("_", "."))) : a.match(/Android/i) && (b = a.indexOf("Android "), cc.sys.os = cc.sys.OS_ANDROID, -1 < b && (flax.osVersion = a.substr(b + 8, 3)))
	}
};
flax.registerScene = function(a, b, c) {
	c || (c = []);
	c instanceof Array || (c = [c]);
	flax._scenesDict[a] = {
		scene: b,
		res: c
	}
};
flax.replaceScene = function(a, b, c) {
	if (flax.isDomainAllowed()) {
		flax.currentSceneName && flax.onSceneExit.dispatch(flax.currentSceneName);
		flax.ObjectPool && flax.ObjectPool.release();
		flax.BulletCanvas && flax.BulletCanvas.release();
		cc.director.resume();
		flax.prevSceneName = flax.currentSceneName;
		flax.currentSceneName = a;
		flax.stopPhysicsWorld && flax.stopPhysicsWorld();
		flax.inputManager && flax.inputManager.removeFromParent();
		flax.clearDraw && flax.clearDraw(!0);
		var d = flax._scenesDict[a];
		if (null == d) throw "Please register the scene: " + a + " firstly!";
		flax._languageToLoad && -1 == d.res.indexOf(flax._languageToLoad) && d.res.push(flax._languageToLoad);
		if (flax._fontResources) for (var e in flax._fontResources) d.res.push({
			type: "font",
			name: e,
			srcs: flax._fontResources[e]
		});
		flax.preload(d.res, function() {
			if (flax._languageToLoad) {
				flax._languageDict = cc.loader.getRes(flax._getLanguagePath());
				var a = d.res.indexOf(flax._languageToLoad); - 1 < a && d.res.splice(a, 1);
				flax._languageToLoad = null
			}
			if (flax._fontResources) {
				for (a = d.res.length; a--;)"object" == typeof d.res[a] && d.res.splice(a, 1);
				flax._fontResources = null
			}
			flax.currentScene = new d.scene;
			a = !1;
			if (b) {
				if (!c || 0 > c) c = 0.5;
				var e = b.create(c, flax.currentScene);
				e && (a = !0, cc.director.runScene(e))
			}
			a || cc.director.runScene(flax.currentScene);
			flax.inputManager = new flax.InputManager;
			flax.currentScene.addChild(flax.inputManager, 999999);
			flax._checkDeviceOrientation();
			flax.onSceneEnter.dispatch(flax.currentSceneName)
		})
	}
};
flax.refreshScene = function() {
	flax.currentSceneName && flax.replaceScene(flax.currentSceneName)
};
flax._soundResources = {};
flax.preload = function(a, b, c, d) {
	if (!(null == a || 0 == a.length)) {
		"string" === typeof a && (a = [a]);
		for (var e = !1, f = [], k = a.length; k--;) {
			var m = a[k];
			if (null == m) throw "There is a null resource!";
			if (null == cc.loader.getRes(m) && null == flax._soundResources[m]) if ("string" == typeof m && ".flax" == cc.path.extname(m) && (cc.sys.isNative || !1 === cc.game.config.useFlaxRes)) {
				cc.sys.isNative && cc.log("***Warning: .flax is not support JSB for now, use .plist + .png insteadly!");
				var n = cc.path.changeBasename(m, ".plist"),
					m = cc.path.changeBasename(m, ".png");
				null == cc.loader.getRes(m) && (f.unshift(flax._addResVersion(n)), f.unshift(flax._addResVersion(m)), e = !0)
			} else e = !0, f.unshift(flax._addResVersion(m))
		}
		if (e) {
			var p = flax.nameToObject(cc.game.config.preloader || "flax.Preloader");
			!0 === c && (p = flax.ResPreloader);
			p = new p;
			p.initWithResources(f, function() {
				!0 === c && (flax.inputManager.removeMask(p), p.removeFromParent());
				if (!cc.sys.isNative) for (var a = f.length; a--;) {
					var e = f[a];
					flax.isSoundFile(e) && (flax._soundResources[e] = "loaded");
					var k = cc.loader.getRes(e);
					if (k) {
						var m = flax._removeResVersion(e);
						cc.loader.cache[m] = k;
						flax.isImageFile(m) && cc.sys.capabilities.opengl && cc.textureCache.handleLoadedTexture(m);
						cc.loader.release(e)
					}
				}
				b.apply(d)
			});
			!0 === c ? (flax.currentScene.addChild(p, 999999), flax.inputManager.addMask(p)) : cc.director.runScene(p);
			return p
		}
	}
	b.apply(d)
};
flax.setSoundEnabled = function(a) {
	if (flax._soundEnabled != a) {
		flax._soundEnabled = a;
		var b = cc.audioEngine;
		a ? (b.resumeMusic(), flax._lastMusic && (flax.playMusic(flax._lastMusic, !0), flax._lastMusic = null)) : (b.pauseMusic(), b.stopAllEffects())
	}
};
flax.getSoundEnabled = function() {
	return flax._soundEnabled
};
flax._lastMusic = null;
flax.playMusic = function(a, b, c) {
	var d = cc.audioEngine;
	d.stopMusic(!0 === c);
	flax._soundEnabled ? d.playMusic(a, b) : flax._lastMusic = a
};
flax.stopMusic = function(a) {
	cc.audioEngine.stopMusic(!0 === a)
};
flax.pauseMusic = function() {
	cc.audioEngine.pauseMusic()
};
flax.resumeMusic = function() {
	cc.audioEngine.resumeMusic()
};
flax.playEffect = function(a) {
	if (flax._soundEnabled) return cc.audioEngine.playEffect(a)
};
flax.stopEffect = function(a) {
	var b = cc.audioEngine;
	null != a ? b.stopEffect(a) : b.stopAllEffects()
};
flax.playSound = function(a) {
	return flax.playEffect(a)
};
flax._checkDeviceOrientation = function() {
	if (!cc.sys.isNative) {
		if (!flax._orientationTip && cc.sys.isMobile) {
			flax._orientationTip = cc.LayerColor.create(flax.bgColor, cc.visibleRect.width + 10, cc.visibleRect.height + 10);
			var a = new cc.Sprite("res/" + g.language + "/rotate.png");
			a.setPosition(cc.visibleRect.center);
			flax._orientationTip.__icon = a;
			flax._orientationTip.addChild(a);
			window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize", flax._showOrientaionTip, !0);
			flax._showOrientaionTip()
		}
		flax._orientationTip && (flax._orientationTip.removeFromParent(), flax.currentScene.addChild(flax._orientationTip, Number.MAX_VALUE))
	}
};
flax._oldGamePauseState = !1;
flax._showOrientaionTip = function() {
	var a = 90 == Math.abs(window.orientation),
		b = cc.game.config.landscape;
	flax._orientationTip && (flax._orientationTip.visible = b != a, flax._orientationTip.__icon.rotation = a ? -90 : 0, document.body.scrollTop = 0, flax._orientationTip.visible ? (flax.landscape != a && (flax._oldGamePauseState = cc.director.isPaused()), cc.director.pause()) : flax._oldGamePauseState || cc.director.resume(), flax.inputManager.enabled = !flax._orientationTip.visible);
	flax.landscape = a;
	flax.onDeviceRotate.dispatch(flax.landscape)
};
flax.getAngle = function(a, b, c) {
	var d = 0,
		e = 0;
	a && (d = a.x, e = a.y);
	return flax.getAngle1(b.x - d, b.y - e, c)
};
flax.getAngle1 = function(a, b, c) {
	void 0 === c && (c = !0);
	a = Math.atan2(a, b);
	0 > a && (a += 2 * Math.PI);
	c && (a *= RADIAN_TO_DEGREE);
	return a
};
flax.getDistance = function(a, b) {
	var c = b.x - (null == a ? 0 : a.x),
		d = b.y - (null == a ? 0 : a.y);
	return Math.sqrt(c * c + d * d)
};
flax.getPointOnCircle = function(a, b, c) {
	c = (90 - c) * DEGREE_TO_RADIAN;
	var d = a ? a.y : 0;
	return {
		x: (a ? a.x : 0) + b * Math.cos(c),
		y: d + b * Math.sin(c)
	}
};
flax.getPosition = function(a, b) {
	var c = a.getPosition();
	a.parent && (b && (c = a.parent.convertToWorldSpace(c)), b instanceof cc.Sprite && (c = b.convertToNodeSpace(c)));
	return c
};
flax.getRotation = function(a, b) {
	if (!1 == b) return a.rotation;
	for (var c = 0, d = a; d && !(c += d.rotation, d = d.parent, d === b););
	return c
};
flax.getScale = function(a, b) {
	if (!1 == b) return {
		x: a.scaleX,
		y: a.scaleY
	};
	for (var c = 1, d = 1, e = a; e && !(c *= e.scaleX, d *= e.scaleY, e = e.parent, e === b););
	return {
		x: c,
		y: d
	}
};
flax.getRect = function(a, b) {
	var c;
	if (a.getRect) return c = a.getRect(b);
	if ((a instanceof cc.Layer || a instanceof cc.Scene) && (!cc.EditBox || !(a instanceof cc.EditBox))) return flax.stageRect;
	null == b && (b = !0);
	c = a.getContentSize();
	var d = flax.getScale(a, b),
		e = a.getPosition();
	if (a.parent) if (b) b != a.parent && (e = a.parent.convertToWorldSpace(e), b instanceof cc.Node && (e = b.convertToNodeSpace(e)));
	else return c.width *= Math.abs(d.x), c.height *= Math.abs(d.y), cc.rect(0, 0, c.width, c.height);
	var f = a.getAnchorPoint();
	return c = cc.rect(e.x - c.width * d.x * f.x, e.y - c.height * d.y * f.y, c.width * Math.abs(d.x), c.height * Math.abs(d.y))
};
flax._strToRect = function(a) {
	a = a.split(",");
	return cc.rect(parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]))
};
flax.ifTouched = function(a, b) {
	if (null == a || !(a instanceof cc.Node)) return !1;
	if (a.mainCollider) return a.mainCollider.containsPoint(b);
	var c = flax.getRect(a, !0);
	return cc.rectContainsPoint(c, b)
};
flax.ifCollide = function(a, b) {
	return a.mainCollider.checkCollision(b.mainCollider)
};
flax.isFlaxDisplay = function(a) {
	return a instanceof flax.FlaxSprite || a instanceof flax.FlaxSpriteBatch || a instanceof flax.Image || flax.Scale9Image && a instanceof flax.Scale9Image
};
flax.isFlaxSprite = function(a) {
	return a instanceof flax.FlaxSprite || a instanceof flax.FlaxSpriteBatch
};
flax.isMovieClip = function(a) {
	return a instanceof flax.MovieClip || a instanceof flax.MovieClipBatch
};
flax.isButton = function(a) {
	return a instanceof flax.Button || a instanceof flax.SimpleButton
};
flax.isChildOf = function(a, b) {
	if (null == a || null == b || a == b) return !1;
	for (var c = a.parent; c;) {
		if (c == b) return !0;
		c = c.parent
	}
	return !1
};
flax.findParentWithClass = function(a, b) {
	for (var c = a; c;) {
		if (c instanceof b) return c;
		c = c.parent
	}
	return null
};
flax.findChildWithClass = function(a, b) {
	for (var c = a.children, d = c.length, e; d--;)
	if (e = c[d], e instanceof b || (e = flax.findChildWithClass(e, b))) return e;
	return null
};
flax.getUrlVars = function() {
	var a = {};
	if (cc.sys.isNative) return a;
	for (var b = window.location.search.substring(1).split("&"), c = 0; c < b.length; c++) {
		var d = b[c].split("=");
		a[d[0]] = decodeURIComponent(d[1])
	}
	return a
};
flax.nameToObject = function(a, b) {
	if (void 0 == a || "" == a) return null;
	b = b || "function";
	for (var c = a.split("."), d = window || this, e = 0, f = c.length; e < f; e++) try {
		d = d[c[e]]
	} catch (k) {
		break
	}
	return typeof d !== b ? null : d
};
flax.createBGLayer = function(a, b) {
	null == b && (b = cc.color(255, 255, 255, 255));
	var c = cc.LayerColor.create(b, cc.visibleRect.width, cc.visibleRect.height);
	a.addChild(c, 0);
	return c
};
flax.shuffleArray = function(a, b) {
	if (void 0 === b || 0 >= b || b > a.length) b = a.length;
	for (var c = b - 1; 0 <= c; c--) {
		var d = 0 | cc.rand() % (c + 1),
			e = a[c];
		a[c] = a[d];
		a[d] = e
	}
};
flax.restrictValue = function(a, b, c) {
	a = Math.max(b, a);
	return a = Math.min(c, a)
};
flax.numberSign = function(a) {
	return 0 == a ? 0 : 0 < a ? 1 : -1
};
flax.randInt = function(a, b) {
	return a + Math.floor(Math.random() * (b - a))
};
flax.getRandomInArray = function(a, b) {
	if (null == a) return null;
	if (null == b) {
		var c = flax.randInt(0, a.length);
		return a[c]
	}
	for (var d = Math.random(), e = 0, c = 0; c < b.length && (0 >= b[c] || !(e += b[c], d <= e)); c++);
	return a[c]
};
flax.isImageFile = function(a) {
	if ("string" != typeof a) return !1;
	a = cc.path.extname(a);
	return -1 < IMAGE_TYPES.indexOf(a)
};
flax.isSoundFile = function(a) {
	if ("string" != typeof a) return !1;
	a = cc.path.extname(a);
	return -1 < SOUND_TYPES.indexOf(a)
};
flax.copyProperties = function(a, b) {
	if (!(null == a || null == b)) for (var c in a) try {
		b[c] = a[c]
	} catch (d) {}
};
flax.createDInts = function(a, b) {
	isNaN(b) && (b = 0);
	for (var c = [], d = -1, e = b - 1, f = b; ++d < a;) 0 == d % 2 ? c.push(++e) : c.push(--f);
	return c
};
flax.utf8ToUnicode = function(a) {
	if (a) {
		for (var b = "", c = a.length, d = 0, e = c, f, k, m; d < c;)
		if (f = a.charCodeAt(d), 0 == (f & 128)) {
			if (1 > e) break;
			b += String.fromCharCode(f & 127);
			d++;
			e -= 1
		} else if (192 == (f & 224)) {
			k = a.charCodeAt(d + 1);
			if (2 > e || 128 != (k & 192)) break;
			b += String.fromCharCode((f & 63) << 6 | k & 63);
			d += 2;
			e -= 2
		} else if (224 == (f & 240)) {
			k = a.charCodeAt(d + 1);
			m = a.charCodeAt(d + 2);
			if (3 > e || 128 != (k & 192) || 128 != (m & 192)) break;
			b += String.fromCharCode((f & 15) << 12 | (k & 63) << 6 | m & 63);
			d += 3;
			e -= 3
		} else break;
		return 0 != e ? "" : b
	}
};
flax.formatTime = function(a, b) {
	if (1 >= b) return a + "";
	b || (b = 2);
	var c = 0;
	2 < b && (c = Math.floor(a / 3600));
	var d = Math.floor((a - 3600 * c) / 60),
		e = a - 3600 * c - 60 * d;
	10 > c && (c = "0" + c);
	10 > d && (d = "0" + d);
	10 > e && (e = "0" + e);
	return 2 < b ? c + ":" + d + ":" + e : d + ":" + e
};
flax.generateUid = function(a, b) {
	var c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
		d = [],
		e;
	b = b || c.length;
	if (a) for (e = 0; e < a; e++) d[e] = c[0 | Math.random() * b];
	else {
		var f;
		d[8] = d[13] = d[18] = d[23] = "-";
		d[14] = "4";
		for (e = 0; 36 > e; e++) d[e] || (f = 0 | 16 * Math.random(), d[e] = c[19 == e ? f & 3 | 8 : f])
	}
	return d.join("")
};
flax.homeUrl = "/";
flax.goHomeUrl = function() {
	var a = cc.game.config.homeUrl || flax.homeUrl;
	!cc.sys.isNative && a && window.open(a)
};

function SignalBinding(a, b, c, d, e) {
	this._listener = b;
	this._isOnce = c;
	this.context = d;
	this._signal = a;
	this._priority = e || 0
}
SignalBinding.prototype = {
	actived: !0,
	params: null,
	execute: function(a) {
		var b;
		this.actived && this._listener && (a = this.params ? this.params.concat(a) : a, b = this._listener.apply(this.context, a), this._isOnce && this.detach());
		return b
	},
	detach: function() {
		return this.isBound() ? this._signal.remove(this._listener, this.context) : null
	},
	isBound: function() {
		return !!this._signal && !! this._listener
	},
	isOnce: function() {
		return this._isOnce
	},
	getListener: function() {
		return this._listener
	},
	getSignal: function() {
		return this._signal
	},
	_destroy: function() {
		delete this._signal;
		delete this._listener;
		delete this.context
	},
	toString: function() {
		return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", actived:" + this.actived + "]"
	}
};

function validateListener(a, b) {
	if ("function" !== typeof a) throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
}

function Signal() {
	this._bindings = [];
	this._prevParams = null;
	var a = this;
	this.dispatch = function() {
		Signal.prototype.dispatch.apply(a, arguments)
	}
}
Signal.prototype = {
	VERSION: "::VERSION_NUMBER::",
	memorize: !1,
	_shouldPropagate: !0,
	actived: !0,
	_registerListener: function(a, b, c, d) {
		var e = this._indexOfListener(a, c);
		if (-1 !== e) {
			if (a = this._bindings[e], a.isOnce() !== b) throw Error("You cannot add" + (b ? "" : "Once") + "() then add" + (!b ? "" : "Once") + "() the same listener without removing the relationship first.");
		} else a = new SignalBinding(this, a, b, c, d), this._addBinding(a);
		this.memorize && this._prevParams && a.execute(this._prevParams);
		return a
	},
	_addBinding: function(a) {
		var b = this._bindings.length;
		do--b;
		while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
		this._bindings.splice(b + 1, 0, a)
	},
	_indexOfListener: function(a, b) {
		for (var c = this._bindings.length, d; c--;)
		if (d = this._bindings[c], d._listener === a && d.context === b) return c;
		return -1
	},
	has: function(a, b) {
		return -1 !== this._indexOfListener(a, b)
	},
	add: function(a, b, c) {
		validateListener(a, "add");
		return this._registerListener(a, !1, b, c)
	},
	addOnce: function(a, b, c) {
		validateListener(a, "addOnce");
		return this._registerListener(a, !0, b, c)
	},
	remove: function(a, b) {
		validateListener(a, "remove");
		var c = this._indexOfListener(a, b); - 1 !== c && (this._bindings[c]._destroy(), this._bindings.splice(c, 1));
		return a
	},
	removeAll: function() {
		for (var a = this._bindings.length; a--;) this._bindings[a]._destroy();
		this._bindings.length = 0
	},
	getNumListeners: function() {
		return this._bindings.length
	},
	halt: function() {
		this._shouldPropagate = !1
	},
	dispatch: function(a) {
		if (this.actived) {
			var b = Array.prototype.slice.call(arguments),
				c = this._bindings.length,
				d;
			this.memorize && (this._prevParams = b);
			if (c) {
				d = this._bindings.slice();
				this._shouldPropagate = !0;
				do c--;
				while (d[c] && this._shouldPropagate && !1 !== d[c].execute(b))
			}
		}
	},
	forget: function() {
		this._prevParams = null
	},
	dispose: function() {
		this.removeAll();
		delete this._bindings;
		delete this._prevParams
	},
	toString: function() {
		return "[Signal active:" + this.actived + " numListeners:" + this.getNumListeners() + "]"
	}
};
var signals = Signal;
signals.Signal = Signal;
(function(a) {
	"function" === typeof define && define.amd ? define(function() {
		return signals
	}) : "undefined" !== typeof module && module.exports ? module.exports = signals : a.signals = signals
})(this);
flax.__drawNode = null;
flax.createDrawNode = function(a, b) {
	if (!flax.__drawNode || !flax.__drawNode.parent || a) null == flax.__drawNode && (flax.__drawNode = cc.DrawNode.create()), flax.currentScene && (a || (a = flax.currentScene), flax.__drawNode.parent && flax.__drawNode.parent != a && (flax.__drawNode.removeFromParent(), flax.__drawNode.clear()), null == flax.__drawNode.parent && a.addChild(flax.__drawNode), flax.__drawNode.zIndex = b || 99999)
};
flax.clearDraw = function(a) {
	null != flax.__drawNode && (flax.__drawNode.clear(), !0 === a && (flax.__drawNode.removeFromParent(), flax.__drawNode = null))
};
flax.drawLine = function(a, b, c, d) {
	flax.createDrawNode();
	null == c && (c = 1);
	null == d && (d = cc.color(255, 0, 0, 255));
	flax.__drawNode.drawSegment(a, b, c, d)
};
flax.drawRay = function(a, b, c, d, e) {
	flax.drawLine(a, flax.getPointOnCircle(a, c, b), d, e)
};
flax.drawRect = function(a, b, c, d) {
	flax.createDrawNode();
	null == b && (b = 1);
	null == c && (c = cc.color(255, 0, 0, 255));
	var e = cc.pAdd(cc.p(a.x, a.y), cc.p(a.width, a.height));
	flax.__drawNode.drawRect(cc.p(a.x, a.y), e, d, b, c)
};
flax.drawStageRect = function() {
	var a = h = 2;
	flax.drawRect(cc.rect(flax.stageRect.x + a, flax.stageRect.y + h, flax.stageRect.width - 2 * a, flax.stageRect.height - 2 * h))
};
flax.drawCircle = function(a, b, c, d) {
	flax.createDrawNode();
	null == c && (c = 1);
	null == d && (d = cc.color(255, 0, 0, 255));
	flax.__drawNode.drawCircle(a, b, 360, 360, !1, c, d)
};
flax.drawDot = function(a, b, c) {
	flax.createDrawNode();
	null == b && (b = 3);
	null == c && (c = cc.color(255, 0, 0, 255));
	flax.__drawNode.drawDot(a, b, c)
};
var InputType = {
	press: "onPress",
	up: "onUp",
	click: "onClick",
	move: "onMouseMove",
	keyPress: "onKeyPress",
	keyUp: "onKeyUp"
};
flax.InputManager = cc.Node.extend({
	enabled: !0,
	inTouching: !1,
	inDragging: !1,
	justDragged: !1,
	justDragDist: 0,
	_masks: [],
	_callbacks: {},
	_keyboardCallbacks: {},
	_keyboardListener: null,
	_touchListeners: null,
	ctor: function() {
		cc.Node.prototype.ctor.call(this);
		this._masks = [];
		this.inTouching = !1;
		this._callbacks = {};
		this._keyboardCallbacks = {};
		this._keyboardListener = null;
		this._touchListeners = {}
	},
	onEnter: function() {
		this._super();
		var a = this;
		if (!cc.sys.isMobile) {
			var b = cc.EventListener.create({
				event: cc.EventListener.MOUSE,
				onMouseMove: function(b) {
					a.inDragging = 0 == b.getButton();
					if (a.justDragged = a.inDragging) a.justDragDist += cc.pLength(b.getDelta());
					a.inDragging || a._dispatchOne(a, b, {
						target: a,
						currentTarget: a
					}, InputType.move);
					flax.mousePos = b.getLocation()
				}
			});
			cc.eventManager.addListener(b, this)
		}
		b = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !1,
			onTouchBegan: function(b, d) {
				flax.mousePos = b.getLocation();
				if (!a.enabled) return !1;
				a.inDragging = !1;
				a.justDragged = !1;
				a.justDragDist = 0;
				a.inTouching = !0;
				a._dispatchOne(a, b, d, InputType.press);
				return !0
			},
			onTouchEnded: function(b, d) {
				a.inDragging = !1;
				a.inTouching = !1;
				a._dispatchOne(a, b, d, InputType.up);
				a._dispatchOne(a, b, d, InputType.click)
			},
			onTouchMoved: function(b, d) {
				flax.mousePos = b.getLocation();
				a.inDragging = !0;
				a.justDragged = !0;
				a.justDragDist += cc.pLength(b.getDelta());
				a._dispatchOne(a, b, d, InputType.move)
			}
		});
		cc.eventManager.addListener(b, this)
	},
	onExit: function() {
		this._super();
		this.removeAllTouchListeners();
		this.removeAllKeyboardListeners();
		this.removeAllMasks()
	},
	addMask: function(a) {
		-1 < this._masks.indexOf(a) || (this._masks.push(a), a.__isInputMask = !0)
	},
	removeMask: function(a) {
		var b = this._masks.indexOf(a); - 1 < b && (this._masks.splice(b, 1), a.__isInputMask = !1)
	},
	removeAllMasks: function() {
		for (var a = this._masks.length; a--;) this._masks[a].__isInputMask = !1, this._masks.splice(a, 1);
		this._masks.length = 0
	},
	_compareRealZIndex: function(a, b) {
		if (!a.parent || !b.parent) return 1;
		if (a.parent == b.parent) return this._childIsOnFront(a, b);
		for (var c = null, d = 0, e = [], f = a.parent; f;) e.push(f), f = f.parent;
		for (var k = [], f = b.parent; f;) {
			d = e.indexOf(f);
			if (-1 < d) {
				c = f;
				break
			}
			k.push(f);
			f = f.parent
		}
		e = e.slice(0, d);
		return this._childIsOnFront(e[e.length - 1] || a, k[k.length - 1] || b, c) ? 1 : -1
	},
	_childIsOnFront: function(a, b, c) {
		null == c && (c = a.parent);
		return c.children.indexOf(a) > c.children.indexOf(b)
	},
	addListener: function(a, b, c, d) {
		if (null == b) throw "Event callback can not be null!";
		var e = c == InputType.keyPress || c == InputType.keyUp;
		null == a && (a = this, e || cc.log("Listening target is null, make sure you want to listen to the full screen input!"));
		if (e) {
			e = this._keyboardCallbacks[c];
			null == e && (e = [], this._keyboardCallbacks[c] = e);
			for (var f = e.length; f--;)
			if (e[f].func == b) return;
			e.push({
				func: b,
				context: d || a
			});
			this._keyboardListener || this._createKeyboardListener()
		} else {
			c = null == c ? InputType.click : c;
			null == a.__instanceId && (a.__instanceId = ClassManager.getNewInstanceId());
			e = this._callbacks[a.__instanceId];
			null == e && (e = [], this._callbacks[a.__instanceId] = e, a != this && (f = this._createListener(a, !0), this._touchListeners[a.__instanceId] = f));
			for (f = e.length; f--;)
			if (e[f].type == c && e[f].func == b) return;
			e.push({
				type: c,
				func: b,
				context: d || a
			})
		}
	},
	removeListener: function(a, b, c) {
		null == a && (a = this);
		var d = this._callbacks[a.__instanceId];
		if (d && (null == c || c != InputType.keyPress && c != InputType.keyUp)) {
			var e = null,
				f = d.length;
			if (b || c) for (; f--;) e = d[f], (!c || e.type == c) && (!b || e.func == b) && d.splice(f, 1);
			if (0 == d.length || !b && !c) delete this._callbacks[a.__instanceId], this._touchListeners[a.__instanceId] && delete this._touchListeners[a.__instanceId]
		}
		if (b && (null == c || c == InputType.keyPress || c == InputType.keyUp)) if (null == c ? (d = this._keyboardCallbacks[InputType.keyPress] || [], d = d.concat(this._keyboardCallbacks[InputType.keyUp] || [])) : d = this._keyboardCallbacks[c], d && d.length) for (f = d.length; f--;) e = d[f], e.func == b && d.splice(f, 1)
	},
	removeAllTouchListeners: function() {
		this._callbacks = {};
		for (var a in this._touchListeners) cc.eventManager.removeListener(this._touchListeners[a]), delete this._touchListeners[a]
	},
	removeAllKeyboardListeners: function() {
		this._keyboardCallbacks = {};
		this._keyboardListener && (this._keyboardListener = null)
	},
	handleTouchBegan: function(a, b) {
		if (!this.enabled) return !1;
		var c = b.getCurrentTarget();
		if (this._ifTargetIgnore(c, a)) return !1;
		var d = a.getLocation();
		if (!this._ifNotMasked(c, d)) return !1;
		b.currentTarget = c;
		b.target = this._findRealTarget(c, d) || c;
		if ((c instanceof cc.Layer || c instanceof flax.MovieClip) && b.target == c) return !1;
		this._dispatch(c, a, b, InputType.press);
		return !0
	},
	handleTouchEnded: function(a, b) {
		var c = b.getCurrentTarget();
		b.currentTarget = c;
		b.target = this._findRealTarget(c, a.getLocation()) || c;
		this._dispatch(c, a, b, InputType.up);
		flax.ifTouched(c, a.getLocation()) && this._dispatch(c, a, b, InputType.click)
	},
	handleTouchMoved: function(a, b) {
		var c = b.getCurrentTarget();
		this._dispatch(c, a, b, InputType.move)
	},
	_createListener: function(a, b) {
		var c = this,
			d = cc.EventListener.create({
				event: cc.EventListener.TOUCH_ONE_BY_ONE,
				swallowTouches: b,
				onTouchBegan: function(a, b) {
					return c.handleTouchBegan(a, b)
				},
				onTouchEnded: function(a, b) {
					c.handleTouchEnded(a, b)
				},
				onTouchMoved: function(a, b) {
					c.handleTouchMoved(a, b)
				},
				onTouchCancelled: function(a, b) {
					c.handleTouchEnded(a, b)
				}
			});
		cc.eventManager.addListener(d, a);
		return d
	},
	_createKeyboardListener: function() {
		var a = this;
		this._keyboardListener = {
			event: cc.EventListener.KEYBOARD,
			onKeyPressed: function(b, c) {
				a._dispatchKeyboardEvent(b, InputType.keyPress)
			},
			onKeyReleased: function(b, c) {
				a._dispatchKeyboardEvent(b, InputType.keyUp)
			}
		};
		cc.eventManager.addListener(this._keyboardListener, this)
	},
	_ifNotMasked: function(a, b) {
		for (var c = this._masks.length, d = null, d = null; c--;)
		if (d = this._masks[c], !(a == d || flax.isChildOf(a, d) || flax.isChildOf(d, a)) && !this._ifTargetIgnore(d) && 1 == this._compareRealZIndex(d, a)) if (d = this._findRealTarget(d, b)) return !1;
		return !0
	},
	_findRealTarget: function(a, b) {
		a instanceof Array || (a = [a]);
		for (var c = null, d = a.length; d--;)
		if (c = a[d], !this._ifTargetIgnore(c)) {
			if (0 < c.children.length && (this._temp = this._findRealTarget(c.children, b))) return this._temp;
			if (flax.ifTouched(c, b)) return c
		}
		return null
	},
	_ifTargetIgnore: function(a, b) {
		return null == a || !(a instanceof cc.Scene) && !a.parent || !this._ifTargetVisible(a) || a.isMouseEnabled && !1 === a.isMouseEnabled() || b && !flax.ifTouched(a, b.getLocation()) ? !0 : !1
	},
	_ifTargetVisible: function(a) {
		for (; a;) {
			if (!a.visible) return !1;
			a = a.parent
		}
		return !0
	},
	_dispatch: function(a, b, c, d) {
		for (var e = []; a;) {
			var f = this._callbacks[a.__instanceId];
			f && f.length && e.push(a);
			a = a.parent
		}
		for (f = 0; f < e.length; f++) a = e[f], this._dispatchOne(a, b, c, d)
	},
	_dispatchOne: function(a, b, c, d) {
		var e = this._callbacks[a.__instanceId];
		if (e && e.length) {
			c.currentTarget = a;
			c.inputType = d;
			a = null;
			for (var f = [], k = e.length; k--;) a = e[k], a.type == d && f.push(a);
			for (k = f.length; k--;) a = f[k], a.func.apply(a.context, [b, c])
		}
	},
	_dispatchKeyboardEvent: function(a, b) {
		var c = this._keyboardCallbacks[b];
		if (c && c.length) {
			for (var d = this._getNativeKeyName(a), e = null, f = [], k = c.length; k--;) e = c[k], f.push(e);
			for (k = f.length; k--;) e = f[k], e.func.apply(e.context, [d])
		}
	},
	_getNativeKeyName: function(a) {
		var b = Object.getOwnPropertyNames(flax.KEY),
			c = "",
			d;
		for (d in b)
		if (flax.KEY[b[d]] == a) {
			c = b[d];
			break
		}
		return c
	}
});
flax.KEY = {
	none: 0,
	back: 6,
	menu: 18,
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	pause: 19,
	capslock: 20,
	escape: 27,
	space: 32,
	pageup: 33,
	pagedown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	select: 41,
	insert: 45,
	Delete: 46,
	"0": 48,
	1: 49,
	2: 50,
	3: 51,
	4: 52,
	5: 53,
	6: 54,
	7: 55,
	8: 56,
	9: 57,
	a: 65,
	b: 66,
	c: 67,
	d: 68,
	e: 69,
	f: 70,
	g: 71,
	h: 72,
	i: 73,
	j: 74,
	k: 75,
	l: 76,
	m: 77,
	n: 78,
	o: 79,
	p: 80,
	q: 81,
	r: 82,
	s: 83,
	t: 84,
	u: 85,
	v: 86,
	w: 87,
	x: 88,
	y: 89,
	z: 90,
	num0: 96,
	num1: 97,
	num2: 98,
	num3: 99,
	num4: 100,
	num5: 101,
	num6: 102,
	num7: 103,
	num8: 104,
	num9: 105,
	"*": 106,
	"+": 107,
	"-": 109,
	numdel: 110,
	"/": 111,
	f1: 112,
	f2: 113,
	f3: 114,
	f4: 115,
	f5: 116,
	f6: 117,
	f7: 118,
	f8: 119,
	f9: 120,
	f10: 121,
	f11: 122,
	f12: 123,
	numlock: 144,
	scrolllock: 145,
	";": 186,
	semicolon: 186,
	equal: 187,
	"=": 187,
	",": 188,
	comma: 188,
	dash: 189,
	".": 190,
	period: 190,
	forwardslash: 191,
	grave: 192,
	"[": 219,
	openbracket: 219,
	backslash: 220,
	"]": 221,
	closebracket: 221,
	quote: 222,
	dpadLeft: 1E3,
	dpadRight: 1001,
	dpadUp: 1003,
	dpadDown: 1004,
	dpadCenter: 1005
};
(function() {
	function a(a, b) {
		var c = a.split("."),
			d = k;
		!(c[0] in d) && d.execScript && d.execScript("var " + c[0]);
		for (var e; c.length && (e = c.shift());)!c.length && void 0 !== b ? d[e] = b : d = d[e] ? d[e] : d[e] = {}
	}

	function b(a) {
		var b = a.length,
			c = 0,
			d = Number.POSITIVE_INFINITY,
			e, f, k, n, p, r, s, t, u;
		for (t = 0; t < b; ++t) a[t] > c && (c = a[t]), a[t] < d && (d = a[t]);
		e = 1 << c;
		f = new(m ? Uint32Array : Array)(e);
		k = 1;
		n = 0;
		for (p = 2; k <= c;) {
			for (t = 0; t < b; ++t)
			if (a[t] === k) {
				r = 0;
				s = n;
				for (u = 0; u < k; ++u) r = r << 1 | s & 1, s >>= 1;
				s = k << 16 | t;
				for (u = r; u < e; u += p) f[u] = s;
				++n
			}++k;
			n <<= 1;
			p <<= 1
		}
		return [f, c, d]
	}

	function c(a, b) {
		this.g = [];
		this.h = 32768;
		this.c = this.f = this.d = this.k = 0;
		this.input = m ? new Uint8Array(a) : a;
		this.l = !1;
		this.i = p;
		this.q = !1;
		if (b || !(b = {})) b.index && (this.d = b.index), b.bufferSize && (this.h = b.bufferSize), b.bufferType && (this.i = b.bufferType), b.resize && (this.q = b.resize);
		switch (this.i) {
		case n:
			this.a = 32768;
			this.b = new(m ? Uint8Array : Array)(32768 + this.h + 258);
			break;
		case p:
			this.a = 0;
			this.b = new(m ? Uint8Array : Array)(this.h);
			this.e = this.v;
			this.m = this.s;
			this.j = this.t;
			break;
		default:
			throw Error("invalid inflate mode");
		}
	}

	function d(a, b) {
		for (var c = a.f, d = a.c, e = a.input, f = a.d, k = e.length; d < b;) {
			if (f >= k) throw Error("input buffer is broken");
			c |= e[f++] << d;
			d += 8
		}
		a.f = c >>> b;
		a.c = d - b;
		a.d = f;
		return c & (1 << b) - 1
	}

	function e(a, b) {
		for (var c = a.f, d = a.c, e = a.input, f = a.d, k = e.length, m = b[0], n = b[1]; d < n && !(f >= k);) c |= e[f++] << d, d += 8;
		e = m[c & (1 << n) - 1];
		k = e >>> 16;
		a.f = c >> k;
		a.c = d - k;
		a.d = f;
		return e & 65535
	}

	function f(a) {
		function c(a, b, f) {
			var k, m = this.p,
				n, p;
			for (p = 0; p < a;) switch (k = e(this, b), k) {
			case 16:
				for (n = 3 + d(this, 2); n--;) f[p++] = m;
				break;
			case 17:
				for (n = 3 + d(this, 3); n--;) f[p++] = 0;
				m = 0;
				break;
			case 18:
				for (n = 11 + d(this, 7); n--;) f[p++] = 0;
				m = 0;
				break;
			default:
				m = f[p++] = k
			}
			this.p = m;
			return f
		}
		var f = d(a, 5) + 257,
			k = d(a, 5) + 1,
			n = d(a, 4) + 4,
			p = new(m ? Uint8Array : Array)(s.length),
			r;
		for (r = 0; r < n; ++r) p[s[r]] = d(a, 3);
		if (!m) {
			r = n;
			for (n = p.length; r < n; ++r) p[s[r]] = 0
		}
		n = b(p);
		p = new(m ? Uint8Array : Array)(f);
		r = new(m ? Uint8Array : Array)(k);
		a.p = 0;
		a.j(b(c.call(a, f, n, p)), b(c.call(a, k, n, r)))
	}
	var k = this,
		m = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array && "undefined" !== typeof DataView,
		n = 0,
		p = 1;
	c.prototype.u = function() {
		for (; !this.l;) {
			var a = d(this, 3);
			a & 1 && (this.l = !0);
			a >>>= 1;

			switch (a) {
			case 0:
				var a = this.input,
					b = this.d,
					c = this.b,
					e = this.a,
					k = a.length,
					r = void 0,
					s = void 0,
					t = c.length,
					s = void 0;
				this.c = this.f = 0;
				if (b + 1 >= k) throw Error("invalid uncompressed block header: LEN");
				r = a[b++] | a[b++] << 8;
				if (b + 1 >= k) throw Error("invalid uncompressed block header: NLEN");
				s = a[b++] | a[b++] << 8;
				if (r === ~s) throw Error("invalid uncompressed block header: length verify");
				if (b + r > a.length) throw Error("input buffer is broken");
				switch (this.i) {
				case n:
					for (; e + r > c.length;) {
						s = t - e;
						r -= s;
						if (m) c.set(a.subarray(b, b + s), e), e += s, b += s;
						else for (; s--;) c[e++] = a[b++];
						this.a = e;
						c = this.e();
						e = this.a
					}
					break;
				case p:
					for (; e + r > c.length;) c = this.e({
						o: 2
					});
					break;
				default:
					throw Error("invalid inflate mode");
				}
				if (m) c.set(a.subarray(b, b + r), e), e += r, b += r;
				else for (; r--;) c[e++] = a[b++];
				this.d = b;
				this.a = e;
				this.b = c;
				break;
			case 1:
				this.j(F, E);
				break;
			case 2:
				f(this);
				break;
			default:
				throw Error("unknown BTYPE: " + a);
			}
		}
		return this.m()
	};
	var r = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
		s = m ? new Uint16Array(r) : r,
		r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
		u = m ? new Uint16Array(r) : r,
		r = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
		t = m ? new Uint8Array(r) : r,
		r = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
		w = m ? new Uint16Array(r) : r,
		r = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
		v = m ? new Uint8Array(r) : r,
		r = new(m ? Uint8Array : Array)(288),
		y, z;
	y = 0;
	for (z = r.length; y < z; ++y) r[y] = 143 >= y ? 8 : 255 >= y ? 9 : 279 >= y ? 7 : 8;
	var F = b(r),
		r = new(m ? Uint8Array : Array)(30);
	y = 0;
	for (z = r.length; y < z; ++y) r[y] = 5;
	var E = b(r);
	c.prototype.j = function(a, b) {
		var c = this.b,
			f = this.a;
		this.n = a;
		for (var k = c.length - 258, m, n, p; 256 !== (m = e(this, a));)
		if (256 > m) f >= k && (this.a = f, c = this.e(), f = this.a), c[f++] = m;
		else {
			m -= 257;
			p = u[m];
			0 < t[m] && (p += d(this, t[m]));
			m = e(this, b);
			n = w[m];
			0 < v[m] && (n += d(this, v[m]));
			for (f >= k && (this.a = f, c = this.e(), f = this.a); p--;) c[f] = c[f++-n]
		}
		for (; 8 <= this.c;) this.c -= 8, this.d--;
		this.a = f
	};
	c.prototype.t = function(a, b) {
		var c = this.b,
			f = this.a;
		this.n = a;
		for (var k = c.length, m, n, p; 256 !== (m = e(this, a));)
		if (256 > m) f >= k && (c = this.e(), k = c.length), c[f++] = m;
		else {
			m -= 257;
			p = u[m];
			0 < t[m] && (p += d(this, t[m]));
			m = e(this, b);
			n = w[m];
			0 < v[m] && (n += d(this, v[m]));
			for (f + p > k && (c = this.e(), k = c.length); p--;) c[f] = c[f++-n]
		}
		for (; 8 <= this.c;) this.c -= 8, this.d--;
		this.a = f
	};
	c.prototype.e = function() {
		var a = new(m ? Uint8Array : Array)(this.a - 32768),
			b = this.a - 32768,
			c, d, e = this.b;
		if (m) a.set(e.subarray(32768, a.length));
		else {
			c = 0;
			for (d = a.length; c < d; ++c) a[c] = e[c + 32768]
		}
		this.g.push(a);
		this.k += a.length;
		if (m) e.set(e.subarray(b, b + 32768));
		else for (c = 0; 32768 > c; ++c) e[c] = e[b + c];
		this.a = 32768;
		return e
	};
	c.prototype.v = function(a) {
		var b, c = this.input.length / this.d + 1 | 0,
			d, e, f, k = this.input,
			n = this.b;
		a && ("number" === typeof a.o && (c = a.o), "number" === typeof a.r && (c += a.r));
		2 > c ? (d = (k.length - this.d) / this.n[2], f = 258 * (d / 2) | 0, e = f < n.length ? n.length + f : n.length << 1) : e = n.length * c;
		m ? (b = new Uint8Array(e), b.set(n)) : b = n;
		return this.b = b
	};
	c.prototype.m = function() {
		var a = 0,
			b = this.b,
			c = this.g,
			d, e = new(m ? Uint8Array : Array)(this.k + (this.a - 32768)),
			f, k, n, p;
		if (0 === c.length) return m ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
		f = 0;
		for (k = c.length; f < k; ++f) {
			d = c[f];
			n = 0;
			for (p = d.length; n < p; ++n) e[a++] = d[n]
		}
		f = 32768;
		for (k = this.a; f < k; ++f) e[a++] = b[f];
		this.g = [];
		return this.buffer = e
	};
	c.prototype.s = function() {
		var a, b = this.a;
		m ? this.q ? (a = new Uint8Array(b), a.set(this.b.subarray(0, b))) : a = this.b.subarray(0, b) : (this.b.length > b && (this.b.length = b), a = this.b);
		return this.buffer = a
	};
	a("Zlib.RawInflate", c);
	a("Zlib.RawInflate.prototype.decompress", c.prototype.u);
	var r = {
		ADAPTIVE: p,
		BLOCK: n
	},
		C, A;
	if (Object.keys) y = Object.keys(r);
	else for (C in y = [], z = 0, r) y[z++] = C;
	z = 0;
	for (A = y.length; z < A; ++z) C = y[z], a("Zlib.RawInflate.BufferType." + C, r[C])
}).call(this);
flax._flaxLoader = {
	load: function(a, b, c, d) {
		cc.loader.loadBinary(a, function(b, c) {
			a = flax._removeResVersion(a);
			for (var k = (new Zlib.RawInflate(c)).decompress(), m = "", n = k.length, p = 0; p < n; p++) m += String.fromCharCode(k[p]);
			c = m.split("data:image/gif;base64,");
			m = cc.path.changeBasename(a, ".plist");
			k = cc.path.changeBasename(a, ".png");
			cc.loader.cache[m] = JSON.parse(c[0]);
			m = new Image;
			m.src = "data:image/gif;base64," + c[1];
			cc.loader.cache[k] = m;
			cc.textureCache.handleLoadedTexture(k);
			flax.assetsManager.addAssets(a);
			b ? d(b) : d(null, "Not reachable!");
			cc.loader.release(a);
			cc.loader.cache[a] = "loaded!"
		})
	}
};
cc.sys.isNative || cc.loader.register(["flax"], flax._flaxLoader);
flax._assetsClassMap = {
	btn: "flax.SimpleButton",
	button: "flax.SimpleButton",
	progress: "flax.ProgressBar",
	jpg: "flax.Image",
	png: "flax.Image",
	scrollPane: "flax.ScrollPane",
	gun: "flax.Gunner",
	soundBtn: "flax.SimpleSoundButton"
};
flax._assetsMcClassMap = {
	button: "flax.Button",
	scrollPane: "flax.MCScrollPane",
	gun: "flax.MCGunner",
	gun1: "flax.MCGunner",
	soundBtn: "flax.SoundButton"
};
flax.ASSET_NONE = 0;
flax.ASSET_ANIMATOR = 1;
flax.ASSET_MOVIE_CLIP = 2;
flax.ASSET_IMAGE = 3;
flax.registerClass = function(a, b) {
	flax._assetsClassMap[a] = b
};
flax.registerMcClass = function(a, b) {
	flax._assetsMcClassMap[a] = b
};
flax.AssetsManager = cc.Class.extend({
	framesCache: null,
	displaysCache: null,
	displayDefineCache: null,
	mcsCache: null,
	subAnimsCache: null,
	fontsCache: null,
	toolsVersion: null,
	init: function() {
		this.framesCache = {};
		this.displaysCache = {};
		this.displayDefineCache = {};
		this.mcsCache = {};
		this.subAnimsCache = {};
		this.fontsCache = {};
		this.toolsVersion = {}
	},
	getAssetType: function(a, b) {
		if (this.getMc(a, b)) return flax.ASSET_MOVIE_CLIP;
		var c = this.getDisplayDefine(a, b);
		return c ? "jpg" == c.type || "png" == c.type ? flax.ASSET_IMAGE : "share" == c.type ? this.getAssetType(this._getSharedPlist(a, c), b) : flax.ASSET_ANIMATOR : flax.ASSET_NONE
	},
	createDisplay: function(a, b, c, d, e) {
		if (null == a || null == b) throw "Please give me assetsFile and assetID!";
		null == e && c && (e = c["class"]);
		if (c && "string" === typeof c || e && "string" !== typeof e) throw "Params error: maybe you are using the old api, please use the latest!";
		this.addAssets(a);
		var f = this.getSubAnims(a, b);
		f.length && (b = b + "$" + f[0]);
		var k = this.getDisplayDefine(a, b);
		if (k && "share" == k.type) return this.createDisplay(this._getSharedPlist(a, k), b, c, d, e);
		f = null;
		if (e && (f = flax.nameToObject(e), null == f)) throw "The class: " + e + " doesn't exist!";
		if (null == f) {
			var m = !1;
			null == k && (k = this.getMc(a, b), m = !0);
			if (k) {
				e = k.type;
				"null" == e && ("jpg" != b && "png" != b) && (e = b);
				f = flax.nameToObject(e);
				if (null == f) {
					e = m ? flax._assetsMcClassMap[e] : flax._assetsClassMap[e];
					if ("flax.Image" == e && k.scale9 && (e = "flax.Scale9Image", null == flax.Scale9Image)) throw "Please add module of 'gui' into project.json if you want to use Scale9Image!";
					f = flax.nameToObject(e)
				}
				null == f && (f = m ? flax.MovieClip : flax.Animator, e = m ? "flax.MovieClip" : "flax.Animator", m && (c && !0 === c.batch) && (f = flax.MovieClipBatch, e = "flax.MovieClipBatch"))
			} else throw "There is no display with assetID: " + b + " in assets file: " + a + ", or make sure the display is not a BLANK symbol!";
		}
		null == c && (c = {});
		k = null;
		m = c.parent;
		delete c.parent;
		!0 === d ? k = flax.ObjectPool.get(a, e, b).fetch(b, m, c) : (k = f.create ? f.create(a, b) : new f(a, b), k.attr(c), m && m.addChild(k), k.clsName = e);
		return k
	},
	cloneDisplay: function(a, b, c) {
		if (!flax.isFlaxDisplay(a)) throw "cloneDisplay only support flax type display!";
		b = this.createDisplay(a.assetsFile, a.assetID, {
			parent: c ? a.parent : null
		}, b, a.clsName);
		c && b.setPosition(a.getPosition());
		b.setScale(a.getScale());
		b.setRotation(a.rotation);
		b.zIndex = a.zIndex;
		return b
	},
	removeAssets: function(a) {
		delete this.framesCache[a];
		delete this.displaysCache[a];
		delete this.displayDefineCache[a];
		delete this.mcsCache[a];
		delete this.subAnimsCache[a];
		delete this.fontsCache[a];
		var b = a;
		".flax" == cc.path.extname(a) && (b = cc.path.changeBasename(b, ".plist"));
		cc.spriteFrameCache.removeSpriteFramesFromFile(b);
		cc.loader.release(b);
		cc.loader.release(cc.path.changeBasename(b, ".png"))
	},
	removeAllAssets: function() {
		for (var a in this.framesCache) this.removeAssets(a)
	},
	addAssets: function(a) {
		if ("undefined" !== typeof this.framesCache[a]) return !1;
		var b = a;
		".flax" == cc.path.extname(a) && (b = cc.path.changeBasename(b, ".plist"));
		var c = cc.loader.getRes(b);
		if (null == c) throw "Make sure you have pre-loaded the resource: " + a;
		var d = c.metadata.flaxVersion;
		this.toolsVersion[a] = d || 0;
		if (!d || d < flax.minToolVersion) throw "The resource: " + a + " was exported with the old version of Flax, please do it with current version!";
		d = c.metadata.fps;
		cc.spriteFrameCache.addSpriteFrames(b);
		cc.loader.cache[b] = "loaded!";
		var b = [],
			e = c.frames,
			f;
		for (f in e) b.push(f);
		b.sort();
		this.framesCache[a] = b;
		c.displays && this._parseDisplays(a, c.displays, d);
		c.mcs && this._parseMovieClips(a, c.mcs, d);
		c.fonts && this._parseFonts(a, c.fonts);
		return !0
	},
	_parseDisplays: function(a, b, c) {
		var d = [],
			e = null,
			f;
		for (f in b) d.push(f), e = b[f], e.anchors && (e.anchors = this._parseFrames(e.anchors)), e.colliders && (e.colliders = this._parseFrames(e.colliders)), e.scale9 && (e.scale9 = flax._strToRect(e.scale9)), e.fps = c || cc.game.config.frameRate, this.displayDefineCache[a + f] = e, this._parseSubAnims(a, f);
		this.displaysCache[a] = d
	},
	_parseMovieClips: function(a, b, c) {
		for (var d in b) {
			var e = b[d];
			e.anchors && (e.anchors = this._parseFrames(e.anchors));
			e.colliders && (e.colliders = this._parseFrames(e.colliders));
			var f, k = e.children,
				m;
			for (m in k) f = k[m], f.frames = this._strToArray(f.frames);
			e.fps = c || cc.game.config.frameRate;
			this.mcsCache[a + d] = e;
			this._parseSubAnims(a, d)
		}
	},
	_parseFonts: function(a, b) {
		for (var c in b) this.fontsCache[a + c] = b[c]
	},
	_parseSubAnims: function(a, b) {
		var c = b.split("$"),
			d = c[0],
			c = c[1];
		if (d && c && "" != d && "" != c) {
			var d = a + d,
				e = this.subAnimsCache[d];
			null == e && (e = [], this.subAnimsCache[d] = e);
			e.push(c)
		}
	},
	_parseFrames: function(a) {
		var b = {},
			c;
		for (c in a) b[c] = this._strToArray(a[c]);
		return b
	},
	_strToArray: function(a) {
		a = a.split("|");
		for (var b = -1, c = []; ++b < a.length;) {
			var d = a[b];
			"null" === d ? c.push(null) : "" === d ? c.push(c[b - 1]) : c.push(d)
		}
		return c
	},
	_getSharedPlist: function(a, b) {
		return a.slice(0, a.indexOf("/")) + "/" + b.url + ".plist"
	},
	getFrameNames: function(a, b, c) {
		this.addAssets(a);
		a = this.framesCache[a];
		if (null == a) return []; - 1 == b && (b = 0); - 1 == c && (c = a.length - 1);
		return a.slice(parseInt(b), parseInt(c) + 1)
	},
	getFrameNamesOfDisplay: function(a, b) {
		var c = this.getDisplayDefine(a, b);
		if (null == c) throw "There is no display named: " + b + " in assetsFile: " + a;
		return this.getFrameNames(a, c.start, c.end)
	},
	getDisplayDefine: function(a, b) {
		this.addAssets(a);
		return this.displayDefineCache[a + b]
	},
	getDisplayNames: function(a) {
		this.addAssets(a);
		return this.displaysCache[a] || []
	},
	getRandomDisplayName: function(a) {
		a = this.getDisplayNames(a);
		var b = Math.floor(Math.random() * a.length);
		return a[b]
	},
	getMc: function(a, b) {
		this.addAssets(a);
		return this.mcsCache[a + b]
	},
	getSubAnims: function(a, b) {
		this.addAssets(a);
		return this.subAnimsCache[a + b] || []
	},
	getFont: function(a, b) {
		this.addAssets(a);
		return this.fontsCache[a + b]
	},
	getToolVersion: function(a) {
		return this.toolsVersion[a] || 0
	}
});
flax.AssetsManager.create = function() {
	var a = new flax.AssetsManager;
	a.init();
	return a
};
flax.ColliderType = {
	rect: "Rect",
	circle: "Circle",
	polygon: "Poly"
};
flax.Collider = cc.Class.extend({
	name: null,
	owner: null,
	type: flax.ColliderType.rect,
	physicsBody: null,
	physicsFixture: null,
	physicsContact: null,
	_center: null,
	_width: 0,
	_height: 0,
	_rotation: 0,
	_localRect: null,
	_polygons: null,
	ctor: function(a, b) {
		a = a.split(",");
		this.type = a[0];
		this._center = cc.p(parseFloat(a[1]), parseFloat(a[2]));
		this._width = parseFloat(a[3]);
		this._height = parseFloat(a[4]);
		this._rotation = parseFloat(a[5]);
		if (6 < a.length) {
			this._polygons = [];
			for (var c = a[6].split("'"), d = 0; d < c.length - 1; d += 2) {
				var e = {
					x: parseFloat(c[d]),
					y: parseFloat(c[d + 1])
				};
				this._polygons.push(e)
			}
		}!1 === b && (this._center.x += this._width / 2, this._center.y += this._height / 2);
		this._localRect = cc.rect(this._center.x - this._width / 2, this._center.y - this._height / 2, this._width, this._height)
	},
	setOwner: function(a) {
		this.owner != a && (this.owner = a, this.owner.retain())
	},
	createPhysics: function(a, b, c, d, e, f) {
		if (this.physicsFixture) return this.physicsFixture;
		var k = this.physicsBody = this.owner.physicsBody;
		if (null == k) throw "Please CreatePhysics in its owner firstly!";
		var m = this.getSize(),
			n = this.getCenter(),
			p = flax.getPosition(this.owner, !0),
			r = null;
		if (this.type == flax.ColliderType.circle) r = new Box2D.Collision.Shapes.b2CircleShape, r.SetRadius(0.5 * m.width * flax.getScale(this.owner, !0).x / PTM_RATIO), p = cc.pSub(n, p), r.SetLocalPosition(cc.pMult(p, 1 / PTM_RATIO));
		else if (this.type == flax.ColliderType.rect || this.type == flax.ColliderType.polygon) {
			if (this.type == flax.ColliderType.rect) {
				this._polygons = [cc.p(-0.5 * m.width, -0.5 * m.height), cc.p(0.5 * m.width, -0.5 * m.height), cc.p(0.5 * m.width, 0.5 * m.height), cc.p(-0.5 * m.width, 0.5 * m.height)];
				for (m = 0; m < this._polygons.length; m++) n = this._polygons[m], n.x += this._center.x, n.y += this._center.y
			}
			for (var r = new Box2D.Collision.Shapes.b2PolygonShape, s = [], m = 0; m < this._polygons.length; m++) n = cc.p(this._polygons[m]), n = this.owner.convertToWorldSpace(n), n.x -= p.x, n.y -= p.y, n.x /= PTM_RATIO, n.y /= PTM_RATIO, s.push(n);
			r.SetAsArray(s)
		} else throw "The physics type: " + this.type + " is not supported!";
		p = new Box2D.Dynamics.b2FixtureDef;
		p.shape = r;
		null == a && (a = 0);
		p.density = a;
		null == b && (b = 0.2);
		p.friction = b;
		null == c && (c = 0);
		p.restitution = c;
		p.isSensor = d;
		null == e && (e = 1);
		null == f && (f = 65535);
		p.filter.categoryBits = e;
		p.filter.maskBits = f;
		this.physicsFixture = k.CreateFixture(p);
		this.physicsFixture.SetUserData(this);
		return this.physicsFixture
	},
	destroyPhysics: function() {
		this.physicsFixture && (flax.removePhysicsFixture(this.physicsFixture), this.physicsBody = this.physicsFixture = null);
		this.owner && (this.owner.release(), this.owner = null)
	},
	checkCollision: function(a) {
		if (a.type == this.type && this.type == flax.ColliderType.rect) return cc.rectIntersectsRect(this.getRect(!0), a.getRect(!0));
		if (a.type == this.type && this.type == flax.ColliderType.circle) {
			var b = this.getCenter(!0),
				c = a.getCenter(!0);
			return cc.pDistance(b, c) <= (this.getSize().width + a.getSize().width) / 2
		}
		if (this.type == flax.ColliderType.rect) return this._ifRectCollidCircle(this.getRect(!0), a.getRect(!0));
		if (this.type == flax.ColliderType.circle) return this._ifRectCollidCircle(a.getRect(!0), this.getRect(!0))
	},
	containPoint: function(a) {
		return this.containsPoint(a)
	},
	containsPoint: function(a) {
		a = this.owner.convertToNodeSpace(a);
		return this.type == flax.ColliderType.rect ? cc.rectContainsPoint(this._localRect, a) : this.type == flax.ColliderType.polygon ? this._polyContainsPoint(a) : cc.pDistance(a, this._center) <= this._width / 2
	},
	_polyContainsPoint: function(a) {
		for (var b = !1, c = this._polygons.length, d = 0, e = c - 1; d < c; e = d++) {
			var f = this._polygons[d],
				e = this._polygons[e];
			(intersect = f.y > a.y !== e.y > a.y && a.x < (e.x - f.x) * (a.y - f.y) / (e.y - f.y) + f.x) && (b = !b)
		}
		return b
	},
	_ifRectCollidCircle: function(a, b) {
		var c = Math.abs(b.x + b.width / 2 - (a.x + a.width / 2)),
			d = Math.abs(b.y + b.height / 2 - (a.y + a.height / 2));
		if (c > a.width / 2 + b.width / 2 || d > a.height / 2 + b.width / 2) return !1;
		if (c <= a.width / 2 || d <= a.height / 2) return !0;
		c -= a.width / 2;
		d -= a.height / 2;
		return c * c + d * d <= b.width / 2 * b.width / 2
	},
	getRect: function(a) {
		null == a && (a = !0);
		if (!a) return this._localRect;
		var b = this.getCenter(a);
		a = this.getSize(a);
		return cc.rect(b.x - a.width / 2, b.y - a.height / 2, a.width, a.height)
	},
	getCenter: function(a) {
		var b = this.owner.convertToWorldSpace(this._center);
		this.owner.parent && (!1 === a ? b = this.owner.parent.convertToNodeSpace(b) : a instanceof cc.Node && (b = a.convertToNodeSpace(b)));
		return b
	},
	getSize: function(a) {
		var b = flax.getScale(this.owner, a);
		a = this._width * Math.abs(b.x);
		b = this._height * Math.abs(b.y);
		return {
			width: a,
			height: b
		}
	},
	debugDraw: function() {
		var a = this.getRect(!0);
		if (this.type == flax.ColliderType.rect) flax.drawRect(a);
		else {
			var b = cc.DrawNode.create();
			flax.currentScene && flax.currentScene.addChild(b, 99999);
			var c = cc.color(255, 0, 0, 255),
				d = cc.color(0, 255, 0, 122);
			if (this.type == flax.ColliderType.circle) b.drawCircle(this.getCenter(!0), a.width / 2, 0, 360, !1, 1, c, d);
			else {
				for (var e = a = null, f = null, k = 0; k < this._polygons.length - 1; k++) e = cc.p(this._polygons[k]), e = this.owner.convertToWorldSpace(e), 0 == k && (a = cc.p(e)), f = cc.p(this._polygons[k + 1]), f = this.owner.convertToWorldSpace(f), b.drawSegment(e, f, 1, c, d);
				b.drawSegment(f, a, 1, c, d)
			}
		}
	}
});
flax.onCollideStart = new signals.Signal;
flax.onCollideEnd = new signals.Signal;
flax.onCollidePre = new signals.Signal;
flax.onCollidePost = new signals.Signal;
flax._physicsWorld = null;
flax._physicsListener = null;
flax._physicsRunning = !1;
flax._physicsBodyToRemove = null;
flax._physicsFixtureToRemove = null;
flax.physicsTypeStatic = 0;
flax.physicsTypeKinematic = 1;
flax.physicsTypeDynamic = 2;
flax.physicsWorldPos = cc.p();
flax.createPhysicsWorld = function(a, b) {
	flax._physicsWorld && flax.destroyPhysicsWorld();
	var c = new Box2D.Dynamics.b2World(new Box2D.Common.Math.b2Vec2(a.x, a.y), !0 === b);
	c.SetContinuousPhysics(!0);
	flax.physicsWorldPos = cc.p();
	flax._physicsWorld = c;
	flax._physicsBodyToRemove = [];
	flax._physicsFixtureToRemove = [];
	return c
};
flax.getPhysicsWorld = function() {
	if (null == flax._physicsWorld) throw "Pleas use flax.createPhysicsWorld to create the world firstly!";
	return flax._physicsWorld
};
flax.startPhysicsWorld = function() {
	flax.getPhysicsWorld() && (flax.currentScene && !flax._physicsRunning) && (flax._createPhysicsListener(), flax.currentScene.schedule(flax._updatePhysicsWorld, 1 / cc.game.config.frameRate), flax._physicsRunning = !0)
};
flax.stopPhysicsWorld = function() {
	flax._physicsRunning && flax.currentScene && (flax.currentScene.unschedule(flax._updatePhysicsWorld), flax._physicsRunning = !1)
};
flax.destroyPhysicsWorld = function() {
	if (flax._physicsWorld) {
		flax.stopPhysicsWorld();
		for (var a = flax._physicsWorld.GetBodyList(); a; a = a.GetNext()) {
			var b = a.GetUserData();
			b && (b._physicsBody = null);
			flax._physicsWorld.DestroyBody(a)
		}
		flax.onCollideStart.removeAll();
		flax.onCollideEnd.removeAll();
		flax.onCollidePre.removeAll();
		flax.onCollidePost.removeAll();
		flax._physicsWorld = null;
		flax._physicsListener = null;
		flax._physicsBodyToRemove = null
	}
};
flax.removePhysicsBody = function(a) {
	-1 == flax._physicsBodyToRemove.indexOf(a) && flax._physicsBodyToRemove.push(a)
};
flax.removePhysicsFixture = function(a) {
	-1 == flax._physicsFixtureToRemove.indexOf(a) && flax._physicsFixtureToRemove.push(a)
};
flax.physicsRaycast = function(a, b, c, d) {
	flax.getPhysicsWorld().RayCast(function(e, f, k, m) {
		e = e.GetUserData();
		f = cc.pMult(f, PTM_RATIO);
		var n = cc.pSub(c, f);
		k = cc.pMult(k, cc.pDot(n, k));
		n = cc.pSub(c, cc.pMult(k, 2));
		k = flax.getAngle(f, n);
		d && 0 < d && (m = flax.getAngle(b, c), d /= Math.sin(Math.abs(k / 2 - m / 2) * Math.PI / 180), f = cc.pSub(f, flax.getPointOnCircle(cc.p(), d, m)), n = cc.pDistance(b, c), m = cc.pDistance(b, f) / n, n = flax.getPointOnCircle(f, n * (1 - m), k));
		a(e, f, n, m)
	}, cc.pMult(b, 1 / PTM_RATIO), cc.pMult(c, 1 / PTM_RATIO))
};
flax.physicsSimulate = function(a, b, c) {
	c || (c = flax.frameInterval);
	b = Math.round(b / c);
	for (var d = a.GetPosition(), e = a.GetAngle(), f = {}, k = 0, m = flax._physicsWorld.GetBodyList(); m; m = m.GetNext())
	if (m != a) {
		var n = m.GetType();
		n != flax.physicsTypeStatic && (m.m_type = flax.physicsTypeStatic, m.__tempKey = ++k, f[m.__tempKey] = n)
	}
	n = [];
	for (k = 0; k < b; k++) flax._physicsWorld.Step(c, velocityIterations, positionIterations), m = a.GetPosition(), n.push(cc.p(m.x * PTM_RATIO, m.y * PTM_RATIO));
	for (m = flax._physicsWorld.GetBodyList(); m; m = m.GetNext()) m.__tempKey && (m.SetType(f[m.__tempKey]), delete m.__tempKey);
	a.SetPositionAndAngle(d, e);
	return n
};
flax._createPhysicsListener = function() {
	flax._physicsListener || (flax._physicsListener = new Box2D.Dynamics.b2ContactListener, flax._physicsListener.BeginContact = function(a) {
		var b = a.GetFixtureA(),
			c = a.GetFixtureB(),
			b = b.GetUserData() || b,
			c = c.GetUserData() || c;
		!(b.owner && null == b.owner.parent) && !(c.owner && null == c.owner.parent) && (b.physicsContact = c.physicsContact = a, flax.onCollideStart.dispatch(b, c), b.physicsContact = c.physicsContact = null)
	}, flax._physicsListener.EndContact = function(a) {
		var b = a.GetFixtureA(),
			c = a.GetFixtureB(),
			b = b.GetUserData() || b,
			c = c.GetUserData() || c;
		!(b.owner && null == b.owner.parent) && !(c.owner && null == c.owner.parent) && (b.physicsContact = c.physicsContact = a, flax.onCollideEnd.dispatch(b, c), b.physicsContact = c.physicsContact = null)
	}, flax._physicsListener.PreSolve = function(a, b) {
		var c = a.GetFixtureA(),
			d = a.GetFixtureB(),
			c = c.GetUserData() || c,
			d = d.GetUserData() || d;
		!(c.owner && null == c.owner.parent) && !(d.owner && null == d.owner.parent) && (c.physicsContact = d.physicsContact = a, flax.onCollidePre.dispatch(c, d), c.physicsContact = d.physicsContact = null)
	}, flax._physicsListener.PostSolve = function(a, b) {
		var c = a.GetFixtureA(),
			d = a.GetFixtureB(),
			c = c.GetUserData() || c,
			d = d.GetUserData() || d;
		!(c.owner && null == c.owner.parent) && !(d.owner && null == d.owner.parent) && (c.physicsContact = d.physicsContact = a, flax.onCollidePost.dispatch(c, d), c.physicsContact = d.physicsContact = null)
	}, flax._physicsWorld.SetContactListener(flax._physicsListener))
};
flax.createPhysicalWalls = function(a, b) {
	if (null == a || 0 == a.length) a = [1, 1, 1, 1];
	var c = flax.getPhysicsWorld(),
		d = new Box2D.Dynamics.b2FixtureDef;
	d.density = 1;
	null == b && (b = 3);
	d.friction = b;
	var e = new Box2D.Dynamics.b2BodyDef,
		f = cc.director.getWinSize();
	e.type = Box2D.Dynamics.b2Body.b2_staticBody;
	d.shape = new Box2D.Collision.Shapes.b2PolygonShape;
	d.shape.SetAsBox(0.5 * f.width / PTM_RATIO, 0.5);
	a[0] && (e.position.Set(0.5 * f.width / PTM_RATIO, f.height / PTM_RATIO), c.CreateBody(e).CreateFixture(d));
	a[1] && (e.position.Set(0.5 * f.width / PTM_RATIO, 0), c.CreateBody(e).CreateFixture(d));
	d.shape.SetAsBox(0.5, 0.5 * f.height / PTM_RATIO);
	a[2] && (e.position.Set(0, 0.5 * f.height / PTM_RATIO), c.CreateBody(e).CreateFixture(d));
	a[3] && (e.position.Set(f.width / PTM_RATIO, 0.5 * f.height / PTM_RATIO), c.CreateBody(e).CreateFixture(d))
};
var velocityIterations = 8,
	positionIterations = 1;
flax._updatePhysicsWorld = function(a) {
	for (var b = flax._physicsFixtureToRemove.length; b--;) {
		var c = flax._physicsFixtureToRemove[b],
			d = c.GetBody();
		d && d.DestroyFixture(c);
		flax._physicsFixtureToRemove.splice(b, 1)
	}
	for (b = flax._physicsBodyToRemove.length; b--;) flax._physicsWorld.DestroyBody(flax._physicsBodyToRemove[b]), flax._physicsBodyToRemove.splice(b, 1);
	flax._physicsWorld.Step(a, velocityIterations, positionIterations);
	for (a = flax._physicsWorld.GetBodyList(); a; a = a.GetNext()) b = a.GetUserData(), null != b && (null != b && b.parent) && (c = cc.p(a.GetPosition()), c.x *= PTM_RATIO, c.y *= PTM_RATIO, c = cc.pAdd(c, flax.physicsWorldPos), c = b.parent.convertToNodeSpace(c), b.x = c.x, b.y = c.y, !0 !== b.ignoreBodyRotation && (b.rotation = -1 * RADIAN_TO_DEGREE * a.GetAngle(), b.rotation += a.__rotationOffset))
};
flax._debugBox2DNode = null;
flax.debugDrawPhysics = function() {
	null == flax._debugBox2DNode && (flax._debugBox2DNode = new flax.DebugBox2DNode(flax.getPhysicsWorld()), flax.currentScene.addChild(flax._debugBox2DNode, Number.MAX_VALUE))
};
flax.DebugBox2DNode = cc.Node.extend({
	_refWorld: null,
	ctor: function(a) {
		this._super();
		this._refWorld = a;
		a = Box2D.Dynamics.b2DebugDraw;
		var b = new a;
		b.SetSprite(document.getElementById("gameCanvas").getContext("2d"));
		var c = PTM_RATIO * cc.view.getViewPortRect().width / cc.view.getDesignResolutionSize().width;
		b.SetDrawScale(c);
		b.SetFillAlpha(0.5);
		b.SetLineThickness(1);
		b.SetFlags(a.e_shapeBit | a.e_jointBit | a.e_centerOfMassBit);
		this._refWorld.SetDebugDraw(b)
	},
	draw: function(a) {
		this._super();
		this._refWorld && (a.scale(1, -1), this._refWorld.DrawDebugData(), a.scale(1, 1), a.translate(0, 0))
	}
});
flax.TileMapModule = {
	tx: 0,
	ty: 0,
	autoUpdateTileWhenMove: !0,
	tileValue: TileValue.WALKABLE,
	_tileMap: null,
	_tileInited: !1,
	onEnter: function() {
		this._tileMap && !this._tileInited && this.updateTile(!0)
	},
	onExit: function() {
		this._tileMap && this._tileMap.removeObject(this);
		this._tileMap = null;
		this._tileInited = !1
	},
	onPosition: function() {
		this.autoUpdateTileWhenMove && this._tileMap && this.updateTile()
	},
	getTileMap: function() {
		return this._tileMap
	},
	setTileMap: function(a) {
		a && !(a instanceof flax.TileMap) && (a = flax.getTileMap(a));
		this._tileMap != a && (this._tileMap && this._tileMap.removeObject(this), this._tileMap = a, null != this._tileMap && this.parent && this.updateTile(!0))
	},
	updateTile: function(a) {
		if (this._tileMap) {
			var b = this.getPosition();
			this.parent && (b = this.parent.convertToWorldSpace(b));
			b = this._tileMap.getTileIndex(b);
			this.setTile(b.x, b.y, a)
		}
	},
	setTile: function(a, b, c) {
		if (!0 === c || a != this.tx || b != this.ty) {
			c = this.tx;
			var d = this.ty;
			this.tx = a;
			this.ty = b;
			this._tileMap && this.parent && (this._tileMap.removeObject(this, c, d), this.parent && (this._tileMap.addObject(this), this._tileInited = !0))
		}
	},
	snapToTile: function(a, b, c) {
		this._tileMap.snapToTile(this, a, b, c)
	}
};
var HLayoutType = {
	LEFT: 0,
	CENTER: 1,
	RIGHT: 2
},
	VLayoutType = {
		BOTTOM: 0,
		MIDDLE: 1,
		TOP: 2
	};
flax.getLayoutPosition = function(a, b, c) {
	var d = flax.getRect(a, !0),
		e = cc.visibleRect.center,
		f = a.getAnchorPointInPoints(),
		k = 0,
		m = 0;
	switch (b) {
	case HLayoutType.LEFT:
		k = 0;
		break;
	case HLayoutType.CENTER:
		k = e.x - d.width / 2;
		break;
	case HLayoutType.RIGHT:
		k = cc.visibleRect.right.x - d.width
	}
	switch (c) {
	case VLayoutType.BOTTOM:
		m = 0;
		break;
	case VLayoutType.MIDDLE:
		m = e.y - d.height / 2;
		break;
	case VLayoutType.TOP:
		m = cc.visibleRect.top.y - d.height
	}
	d = flax.getScale(a, !0);
	b = cc.p(k + (!b ? cc.visibleRect.bottomLeft.x : 0) + f.x * d.x, m + (!c ? cc.visibleRect.bottomLeft.y : 0) + f.y * d.y);
	a.parent && (b = a.parent.convertToNodeSpace(b));
	return b
};
flax.ScreenLayoutModule = {
	_isAutoLayout: !1,
	_hlayout: null,
	_vlayout: null,
	_offsetX: 0,
	_offsetY: 0,
	onEnter: function() {
		flax.onDeviceRotate.add(this._updateLayout, this);
		flax.onScreenResize.add(this._updateLayout, this)
	},
	onExit: function() {
		flax.onDeviceRotate.remove(this._updateLayout, this);
		flax.onScreenResize.remove(this._updateLayout, this)
	},
	setLayoutOffset: function(a, b) {
		this._offsetX = a;
		this._offsetY = b;
		this._updateLayout()
	},
	setLayout: function(a, b) {
		this._isAutoLayout = !1;
		this._hlayout = a;
		this._vlayout = b;
		var c = flax.getLayoutPosition(this, a, b);
		c.x += this._offsetX;
		c.y += this._offsetY;
		this.setPosition(c)
	},
	autoLayout: function() {
		if (cc.view.getResolutionPolicy() == cc.ResolutionPolicy.NO_BORDER) {
			this._isAutoLayout = !0;
			var a = flax.getRect(this, this.parent),
				b = cc.visibleRect.center,
				c = this.getAnchorPointInPoints(),
				d = 0,
				e = cc.visibleRect.width / flax.designedStageSize.width;
			if (1 != e) {
				var f = this.x - b.x;
				0 < f && (d = a.width);
				f = a.x + d - b.x;
				this.x = b.x + f * e + c.x * this.scaleX - d + this._offsetX
			}
			e = cc.visibleRect.height / flax.designedStageSize.height;
			1 != e && (f = this.y - b.y, d = 0, 0 < f && (d = a.height), f = a.y + d - b.y, this.y = b.y + f * e + c.y * this.scaleY - d + this._offsetY)
		}
	},
	_updateLayout: function(a) {
		this._isAutoLayout ? this.autoLayout() : null != this._hlayout && null != this._vlayout && this.setLayout(this._hlayout, this._vlayout)
	}
};
flax.PhysicsModule = {
	_physicsBody: null,
	_physicsToBeSet: null,
	_physicsBodyParam: null,
	_physicsColliders: null,
	onEnter: function() {
		null == this._physicsColliders && (this._physicsColliders = []);
		this._physicsBodyParam && this.createPhysics(this._physicsBodyParam.type, this._physicsBodyParam.fixedRotation, this._physicsBodyParam.bullet);
		if (this._physicsToBeSet) for (var a in this._physicsToBeSet) {
			var b = this.getCollider(a),
				c = this._physicsToBeSet[a];
			b.createPhysics(c.density, c.friction, c.restitution, c.isSensor, c.catBits, c.maskBits);
			delete this._physicsToBeSet[a]; - 1 == this._physicsColliders.indexOf(b) && this._physicsColliders.push(b)
		}
	},
	onExit: function() {
		for (var a = 0; a < this._physicsColliders.length; a++) this._physicsColliders[a].destroyPhysics();
		this._physicsColliders = [];
		this._physicsBody && (flax.removePhysicsBody(this._physicsBody), this._physicsBody = null);
		this._physicsBodyParam = null
	},
	getPhysicsBody: function() {
		return this._physicsBody
	},
	createPhysics: function(a, b, c) {
		null == a && (a = Box2D.Dynamics.b2Body.b2_dynamicBody);
		this._physicsBodyParam = {
			type: a,
			fixedRotation: b,
			bullet: c
		};
		if (!this.parent) return null;
		if (null == this._physicsBody) {
			var d = new Box2D.Dynamics.b2BodyDef;
			d.type = a;
			d.fixedRotation = b;
			d.bullet = c;
			d.userData = this;
			a = flax.getPosition(this, !0);
			d.position.Set(a.x / PTM_RATIO, a.y / PTM_RATIO);
			this._physicsBody = flax.getPhysicsWorld().CreateBody(d);
			this._physicsBody.__rotationOffset = this.rotation
		}
		return this._physicsBody
	},
	destroyPhysics: function() {
		this.removePhysicsShape()
	},
	addPhysicsShape: function(a, b, c, d, e, f, k) {
		if (null == this._physicsBody) throw "Please createPhysics firstly!";
		var m = this.getCollider(a);
		if (null == m) return cc.log("There is no collider named: " + a), null;
		if (m.physicsFixture) return m.physicsFixture;
		var n = {
			density: b,
			friction: c,
			restitution: d,
			isSensor: e,
			catBits: f,
			maskBits: k
		};
		if (this.parent) return m.setOwner(this), a = m.createPhysics(b, c, d, e, f, k), -1 == this._physicsColliders.indexOf(m) && this._physicsColliders.push(m), a;
		null == this._physicsToBeSet && (this._physicsToBeSet = {});
		null == this._physicsToBeSet[a] && (this._physicsToBeSet[a] = n);
		return null
	},
	removePhysicsShape: function(a) {
		for (var b = this._physicsColliders.length; b--;) {
			var c = this._physicsColliders[b];
			if (null == a || c.name == a) c.destroyPhysics(), this._physicsColliders.splice(b, 1)
		}
		0 == this._physicsColliders.length && (flax.removePhysicsBody(this._physicsBody), this._physicsBody = null)
	}
};
flax.MoveModule = {
	gravityOnMove: null,
	destroyWhenReach: !1,
	destroyWhenOutofStage: !1,
	moveSpeed: null,
	moveAcc: null,
	restrainRect: null,
	inRandom: !1,
	_moveSpeedLen: 0,
	_targetPos: null,
	_inMoving: !1,
	_callBack: null,
	_callContext: null,
	onEnter: function() {},
	onExit: function() {
		this.destroyWhenOutofStage = this.destroyWhenReach = !1;
		this.restrainRect = this.gravityOnMove = null;
		this._inMoving = this.inRandom = !1
	},
	moveTo: function(a, b, c, d) {
		this.inRandom = !1;
		this._targetPos = a;
		this._callBack = c;
		this._callContext = d;
		a = cc.pSub(a, this.getPosition());
		1 > cc.pLength(a) || !b || 0 >= b ? this.scheduleOnce(this._moveOver, 0.01) : (this.moveSpeed = cc.pMult(a, 1 / b), this._moveSpeedLen = cc.pLength(this.moveSpeed), this.resumeMove())
	},
	moveToBySpeed: function(a, b, c, d) {
		this.inRandom = !1;
		this._targetPos = a;
		this._callBack = c;
		this._callContext = d;
		a = cc.pSub(a, this.getPosition());
		c = cc.pLength(a);
		1 > c ? this.scheduleOnce(this._moveOver, 0.01) : (this.moveSpeed = cc.pMult(a, b / c), this._moveSpeedLen = cc.pLength(this.moveSpeed), this.resumeMove())
	},
	moveBySpeed: function(a, b) {
		this._callBack = this._targetPos = null;
		this.inRandom = !1;
		this.moveSpeed = "object" === typeof a ? a : flax.getPointOnCircle(cc.p(), a, b);
		this.resumeMove()
	},
	moveRandomly: function(a, b, c) {
		this.restrainRect = c || flax.stageRect;
		this.moveBySpeed(a, b || 360 * Math.random());
		this.inRandom = null == b
	},
	pauseMove: function() {
		this._inMoving && (this.unschedule(this._doMove), this._inMoving = !1)
	},
	resumeMove: function() {
		this._inMoving || (this._inMoving = !0, this.schedule(this._doMove, flax.frameInterval, cc.REPEAT_FOREVER))
	},
	stopMove: function() {
		this._inMoving && (this._targetPos = this.moveSpeed = null, this._inMoving = !1, this.restrainRect = this._callBack = null, this.inRandom = !1, this.unschedule(this._doMove))
	},
	_doMove: function(a) {
		var b = this.getPosition();
		if ((this._targetPos ? cc.pDistance(b, this._targetPos) : Number.maxValue) < this._moveSpeedLen * a || this.destroyWhenOutofStage && !cc.rectContainsRect(flax.stageRect, flax.getRect(this, !0))) this._moveOver(), this.stopMove();
		else {
			var c = flax.getRect(this, this.parent);
			if (this.restrainRect) {
				var d = 0,
					e = 0;
				c.x < this.restrainRect.x ? d = 1 : c.x > this.restrainRect.x + this.restrainRect.width - c.width && (d = -1);
				c.y < this.restrainRect.y ? e = 1 : c.y > this.restrainRect.y + this.restrainRect.height - c.height && (e = -1);
				this.inRandom && (d && (this.moveSpeed.x = d * Math.abs(this.moveSpeed.x)), e && (this.moveSpeed.y = e * Math.abs(this.moveSpeed.y)))
			}
			c = this.moveAcc;
			this.gravityOnMove && (c = cc.pAdd(c || cc.p(), this.gravityOnMove));
			c && (this.moveSpeed = cc.pAdd(this.moveSpeed, cc.pMult(c, a)));
			this.setPosition(cc.pAdd(b, cc.pMult(this.moveSpeed, a)))
		}
	},
	_moveOver: function() {
		this._targetPos && this.setPosition(this._targetPos);
		this._callBack && (this._callBack.apply(this._callContext || this), this._callBack = null);
		this.destroyWhenReach && this.destroy()
	}
};
flax.Anchor = cc.Class.extend({
	x: 0,
	y: 0,
	zIndex: 0,
	rotation: 0,
	scaleX: 1,
	scaleY: 1,
	ctor: function(a) {
		a = a.split(",");
		this.x = parseFloat(a[0]);
		this.y = parseFloat(a[1]);
		2 < a.length && (this.zIndex = parseInt(a[2]));
		3 < a.length && (this.rotation = parseFloat(a[3]));
		4 < a.length && (this.scaleX = parseFloat(a[4]));
		5 < a.length && (this.scaleY = parseFloat(a[5]));
		cc.log(this.scaleX + "," + a.length)
	}
});
flax._sprite = {
	__instanceId: null,
	onAnimationOver: null,
	onSequenceOver: null,
	onFrameChanged: null,
	onFrameLabel: null,
	autoDestroyWhenOver: !1,
	autoStopWhenOver: !1,
	autoHideWhenOver: !1,
	autoRecycle: !1,
	currentFrame: 0,
	currentAnim: null,
	totalFrames: 0,
	frameInterval: 0,
	ignoreBodyRotation: !1,
	define: null,
	name: null,
	assetsFile: null,
	assetID: null,
	clsName: "flax.FlaxSprite",
	playing: !1,
	_prevFrame: -1,
	_labelFrames: null,
	_labelSounds: null,
	_loopStart: 0,
	_loopEnd: 0,
	_isLanguageElement: !1,
	__isFlaxSprite: !0,
	__isInputMask: !1,
	_fps: 24,
	_colliders: null,
	_mainCollider: null,
	_definedMainCollider: !1,
	_anchorBindings: null,
	_inited: !1,
	_mouseEnabled: !0,
	_baseAssetID: null,
	_subAnims: null,
	_animSequence: null,
	_loopSequence: !1,
	_sequenceIndex: 0,
	_fpsForAnims: null,
	ctor: function(a, b) {
		if ("flax.FlaxSprite" == this.clsName) throw "flax.FlaxSprite is an abstract class, please use flax.Animator or flax.MovieClip!";
		this instanceof cc.SpriteBatchNode ? cc.SpriteBatchNode.prototype.ctor.call(this, cc.path.changeExtname(a, ".png")) : cc.Sprite.prototype.ctor.call(this);
		if (!a || !b) throw "Please set assetsFile and assetID to me!";
		this.__instanceId = ClassManager.getNewInstanceId();
		this._anchorBindings = [];
		this._animSequence = [];
		this._fpsForAnims = {};
		this.onAnimationOver = new signals.Signal;
		this.onSequenceOver = new signals.Signal;
		this.onFrameChanged = new signals.Signal;
		this.onFrameLabel = new signals.Signal;
		this.setSource(a, b)
	},
	setSource: function(a, b) {
		if (null == a || null == b) throw "assetsFile and assetID can not be null!";
		if (!(this.assetsFile == a && (this.assetID == b || this._baseAssetID == b))) {
			this.assetsFile = a;
			this.currentAnim = null;
			this.assetID = this._handleSumAnims(b);
			this.define = this.getDefine();
			var c = this.define.anchorX,
				d = this.define.anchorY;
			!isNaN(c) && !isNaN(d) && this.setAnchorPoint(c, d);
			0 == this.fps && (this.fps = this.define.fps);
			this.onNewSource();
			this.currentFrame = 0;
			this._initFrameLabels();
			this.renderFrame(this.currentFrame, !0);
			this._initColliders();
			this.parent && this._updateLaguage();
			null == this.__pool__id__ && (this.__pool__id__ = this.assetID);
			this.currentAnim && this.onFrameLabel.dispatch(this.currentAnim)
		}
	},
	_handleSumAnims: function(a) {
		a = a.split("$");
		this._baseAssetID = a[0];
		this._subAnims = flax.assetsManager.getSubAnims(this.assetsFile, this._baseAssetID);
		var b = a[1];
		null == b && this._subAnims && (b = this._subAnims[0]);
		a = this._baseAssetID;
		b && (a = this._baseAssetID + "$" + b, this.currentAnim = b);
		return a
	},
	_initFrameLabels: function() {
		this._labelFrames = [];
		this._frameSounds = {};
		var a = this.define.labels;
		if (a) {
			for (var b in a) {
				var c = a[b]; - 1 < b.indexOf("@") ? (null == this.define.sounds && (this.define.sounds = {}), this.define.sounds["" + c.start] = DEFAULT_SOUNDS_FOLDER + b.slice(0, b.indexOf("@")), delete a[b]) : this._labelFrames.push(c.start)
			}
			flax.copyProperties(this.define.sounds, this._frameSounds)
		}
	},
	setFpsForAnim: function(a, b) {
		this._fpsForAnims[a] = b
	},
	addFrameSound: function(a, b) {
		this._frameSounds["" + a] = b
	},
	removeFrameSound: function(a) {
		delete this._frameSounds["" + a]
	},
	getLabels: function(a) {
		return this.define.labels ? this.define.labels[a] : null
	},
	hasLabel: function(a) {
		return null != this.getLabels(a)
	},
	getMainCollider: function() {
		return this.getCollider("main") || this._mainCollider
	},
	getCollider: function(a) {
		var b = null;
		this._colliders && (a = this._colliders[a], null != a && (b = a[this.currentFrame]));
		return b
	},
	_initColliders: function() {
		this._mainCollider = null;
		this._colliders = {};
		var a = this.define.colliders;
		if (a) {
			var b = null,
				c;
			for (c in a) {
				this._colliders[c] = [];
				for (var d = a[c], e = -1; ++e < d.length;)
				if (null == d[e]) this._colliders[c][e] = null;
				else if (b = this._colliders[c][e] = new flax.Collider(d[e]), b.name = c, b.setOwner(this), "main" == c || "base" == c) this._mainCollider = b
			}
		}
		this._definedMainCollider = null != this._mainCollider;
		this._definedMainCollider || (this._mainCollider = new flax.Collider("Rect,0,0," + this.width + "," + this.height + ",0", !1), this._mainCollider.name = "main", this._mainCollider.setOwner(this))
	},
	getRect: function(a) {
		return this.getMainCollider().getRect(a)
	},
	debugDraw: function() {
		this.getMainCollider().debugDraw()
	},
	getCenter: function(a) {
		return this.getMainCollider().getCenter(a)
	},
	getAnchor: function(a) {
		if (this.define.anchors) {
			var b = this.define.anchors[a];
			if (null != b) return b instanceof flax.Anchor || (b = new flax.Anchor(b[this.currentFrame]), this.define.anchors[a] = b), b
		}
		return null
	},
	bindAnchor: function(a, b, c) {
		if (!this.define.anchors) return cc.log(this.assetID + ": there is no any anchor!"), !1;
		if (null == this.define.anchors[a]) return cc.log(this.assetID + ": there is no anchor named " + a), !1;
		if (null == b) throw "Node can't be null!";
		if (-1 < this._anchorBindings.indexOf(b)) return cc.log(this.assetID + ": anchor has been bound, " + a), !1;
		!1 !== c && this._anchorBindings.push(b);
		b.__anchor__ = a;
		this._updateAnchorNode(b, this.getAnchor(a));
		b.parent != this && (b.removeFromParent(!1), this.addChild(b));
		return !0
	},
	unbindAnchor: function(a, b) {
		for (var c = null, d = -1, e = this._anchorBindings.length; ++d < e;)
		if (c = this._anchorBindings[d], c === a || c.__anchor__ === a) {
			this._anchorBindings.splice(d, 1);
			delete c.__anchor__;
			b && (c.destroy ? c.destroy() : c.removeFromParent());
			break
		}
	},
	getCurrentLabel: function() {
		var a = this.define.labels;
		if (!a) return null;
		for (var b in a) {
			var c = a[b];
			if (this.currentFrame >= c.start && this.currentFrame <= c.end) return b
		}
		return null
	},
	nextFrame: function() {
		this.gotoAndStop(Math.min(++this.currentFrame, this.totalFrames - 1))
	},
	prevFrame: function() {
		this.gotoAndStop(Math.max(--this.currentFrame, 0))
	},
	play: function() {
		!this._isLanguageElement && !this.__isButton && (this._loopStart = 0, this._loopEnd = this.totalFrames - 1, this.updatePlaying(!0), this.currentAnim = null)
	},
	playSequence: function(a) {
		if (null == a) return !1;
		a instanceof Array || (a = Array.prototype.slice.call(arguments));
		if (0 == a.length) return !1;
		this._loopSequence = !1;
		this._sequenceIndex = 0;
		var b = this.gotoAndPlay(a[0]);
		this._animSequence = a;
		return b
	},
	playSequenceLoop: function(a) {
		a instanceof
		Array || (a = Array.prototype.slice.call(arguments));
		this.playSequence(a);
		this._loopSequence = !0
	},
	stopSequence: function() {
		this._loopSequence = !1;
		this._animSequence.length = 0
	},
	_setSubAnim: function(a, b) {
		if (!a || 0 == a.length) return !1;
		if (null == this._subAnims || -1 == this._subAnims.indexOf(a)) return this.__isButton || cc.log("There is no animation named: " + a), !1;
		this.setSource(this.assetsFile, this._baseAssetID + "$" + a);
		!1 === b ? this.gotoAndStop(0) : (this._fpsForAnims[a] && this.setFPS(this._fpsForAnims[a]), this.gotoAndPlay(0));
		this.currentAnim = a;
		this._animTime = 0;
		return !0
	},
	gotoAndPlay: function(a, b) {
		if (this._isLanguageElement || this.__isButton) return !1;
		if ("string" === typeof a) {
			if (this.playing && this.currentAnim == a && !0 !== b) return !0;
			var c = this.getLabels(a);
			if (null == c) return c = this._setSubAnim(a, !0), c || (cc.log("There is no animation named: " + a), this.play()), c;
			this._loopStart = c.start;
			this._loopEnd = c.end;
			this.currentFrame = this._loopStart;
			this.currentAnim = a;
			this._fpsForAnims[a] && this.setFPS(this._fpsForAnims[a])
		} else {
			if (!this.isValideFrame(a)) return cc.log("The frame: " + a + " is out of range!"), !1;
			this._loopStart = 0;
			this._loopEnd = this.totalFrames - 1;
			this.currentFrame = a;
			this.currentAnim = null
		}
		this.renderFrame(this.currentFrame);
		this.updatePlaying(!0);
		this._animTime = 0;
		return !0
	},
	stop: function() {
		this.updatePlaying(!1);
		this.currentAnim = null
	},
	gotoAndStop: function(a) {
		if (isNaN(a)) {
			var b = this.getLabels(a);
			if (null == b) return b = this._setSubAnim(a, !1), !b && !this.__isButton && cc.log("There is no animation named: " + a), b;
			a = b.start
		}
		this.currentAnim = null;
		if (!this.isValideFrame(a)) return cc.log("The frame: " + a + " is out of range!"), !1;
		this.updatePlaying(!1);
		this.currentFrame = a;
		this.renderFrame(a);
		return !0
	},
	setFPS: function(a) {
		this._fps != a && (this._fps = a, this.updateSchedule())
	},
	getFPS: function() {
		return this._fps
	},
	updatePlaying: function(a) {
		this.playing != a && (this.playing = a, this.updateSchedule())
	},
	updateSchedule: function() {
		this.playing ? 1 < this.totalFrames && this.schedule(this.onFrame, 1 / this._fps) : this.unschedule(this.onFrame)
	},
	_animTime: 0,
	onFrame: function(a) {
		if (this.visible) {
			this.currentFrame++;
			this._animTime += a;
			this.currentFrame > this._loopEnd && (this.currentFrame = this._loopEnd, (this.autoDestroyWhenOver || this.autoStopWhenOver || this.autoHideWhenOver) && this.updatePlaying(!1), this.onAnimationOver.getNumListeners() && this.onAnimationOver.dispatch(this), this.autoDestroyWhenOver ? this.destroy() : this.autoHideWhenOver ? this.visible = !1 : this._animSequence.length ? this._playNext() : this.autoStopWhenOver || (this.currentFrame = this._loopStart), this._animTime = 0);
			if (this.currentFrame > this._loopEnd || this.currentFrame > this.totalFrames - 1) this.currentFrame = this._loopStart;
			this.renderFrame(this.currentFrame)
		}
	},
	_playNext: function() {
		this._sequenceIndex++;
		if (this._sequenceIndex >= this._animSequence.length && (this._loopSequence ? this._sequenceIndex = 0 : (this.autoStopWhenOver || this.gotoAndPlay(this._animSequence[this._sequenceIndex - 1], !0), this._animSequence = []), this.onSequenceOver.getNumListeners() && this.onSequenceOver.dispatch(this), 0 != this._sequenceIndex)) return;
		var a = this._animSequence,
			b = a[this._sequenceIndex];
		if ("number" === typeof b) if (this._loopSequence && this._sequenceIndex == a.length - 1 ? this._sequenceIndex = 0 : this._sequenceIndex++, a.length > this._sequenceIndex && "string" === typeof a[this._sequenceIndex]) {
			var c = b,
				b = a[this._sequenceIndex];
			this.scheduleOnce(function() {
				this.gotoAndPlay(b)
			}, c - this._animTime);
			this.updatePlaying(!1)
		} else this._animSequence = [], this.currentFrame = this._loopStart;
		else this.gotoAndPlay(b)
	},
	isValideFrame: function(a) {
		return 0 <= a && a < this.totalFrames
	},
	renderFrame: function(a, b) {
		if (!(this._prevFrame == a && !0 != b)) {
			this._prevFrame != a && (this._prevFrame = a);
			this._handleAnchorBindings();
			this._updateCollider();
			this.doRenderFrame(a);
			this.onFrameChanged.getNumListeners() && this.onFrameChanged.dispatch(this.currentFrame); - 1 < this._labelFrames.indexOf(a) && this.onFrameLabel.dispatch(this.getCurrentLabel(a));
			var c = this._frameSounds["" + a];
			c && flax.playSound(c)
		}
	},
	doRenderFrame: function(a) {},
	_handleAnchorBindings: function() {
		for (var a = null, b = null, c = -1, d = this._anchorBindings.length; ++c < d;) a = this._anchorBindings[c], a.visible && (b = this.getAnchor(a.__anchor__), null != b && this._updateAnchorNode(a, b))
	},
	_updateAnchorNode: function(a, b) {
		null != b && (a.x = b.x, a.y = b.y, a.zIndex = b.zIndex, a.rotation = b.rotation, a.setScaleX(b.scaleX), a.setScaleY(b.scaleY))
	},
	onEnter: function() {
		this._super();
		this._destroyed = !1;
		this._updateCollider();
		this._updateLaguage();
		flax.callModuleOnEnter(this);
		this.__fromPool && (this.__fromPool = !1, this.release())
	},
	onExit: function() {
		this._super();
		this._destroyed = !0;
		this.onAnimationOver.removeAll();
		this.onSequenceOver.removeAll();
		this.onFrameChanged.removeAll();
		this.onFrameLabel.removeAll();
		flax.inputManager && (flax.inputManager.removeListener(this), this.__isInputMask && flax.inputManager.removeMask(this));
		for (var a = null, b = -1, c = this._anchorBindings.length; ++b < c;) a = this._anchorBindings[b], a.destroy ? a.destroy() : a.removeFromParent(!0), delete a.__anchor__;
		this._anchorBindings.length = 0;
		flax.callModuleOnExit(this)
	},
	_updateLaguage: function() {
		(this._isLanguageElement = -1 < flax.languageIndex && this.name && 0 == this.name.indexOf("label__")) && (this.gotoAndStop(flax.languageIndex) || this.gotoAndStop(0))
	},
	_updateCollider: function() {},
	setPosition: function(a, b) {
		var c = !1,
			c = this.getPositionX(),
			d = this.getPositionY();
		void 0 === b ? (c = a.x != c || a.y != d) && this._super(a) : (c = a != c || b != d) && this._super(a, b);
		c && this.parent && (flax.callModuleFunction(this, "onPosition"), this._updateCollider())
	},
	setPositionX: function(a) {
		this.setPosition(a, this.getPositionY())
	},
	setPositionY: function(a) {
		this.setPosition(this.getPositionX(), a)
	},
	_destroyed: !1,
	destroy: function() {
		this._destroyed || (this._destroyed = !0, this.autoRecycle && flax.ObjectPool.get(this.assetsFile, this.clsName, this.__pool__id__ || "").recycle(this), this.removeFromParent())
	},
	onRecycle: function() {
		this.autoRecycle = !1;
		this.setScale(1);
		this.opacity = 255;
		this.rotation = 0;
		this.ignoreBodyRotation = this.autoHideWhenOver = this.autoStopWhenOver = this.autoDestroyWhenOver = !1;
		RESET_FRAME_ON_RECYCLE && this.gotoAndStop(0);
		this.setPosition(0, 0);
		this._animSequence.length = 0;
		this._loopSequence = !1;
		this._sequenceIndex = 0;
		this.currentAnim = null;
		this.__isInputMask = !1
	},
	isMouseEnabled: function() {
		return this._mouseEnabled
	},
	setMouseEnabled: function(a) {
		this._mouseEnabled = a
	},
	getDefine: function() {
		return null
	},
	onNewSource: function() {}
};
flax.FlaxSprite = cc.Sprite.extend(flax._sprite);
flax.FlaxSprite.create = function(a, b) {
	var c = new flax.FlaxSprite(a, b);
	c.clsName = "flax.FlaxSprite";
	return c
};
flax.addModule(flax.FlaxSprite, flax.TileMapModule);
flax.addModule(flax.FlaxSprite, flax.MoveModule);
flax.addModule(flax.FlaxSprite, flax.ScreenLayoutModule);
flax.addModule(flax.FlaxSprite, flax.PhysicsModule);
window.flax.FlaxSprite = flax.FlaxSprite;
flax.FlaxSpriteBatch = cc.SpriteBatchNode.extend(flax._sprite);
flax.FlaxSpriteBatch.create = function(a, b) {
	var c = new flax.FlaxSpriteBatch(a, b);
	c.clsName = "flax.FlaxSpriteBatch";
	return c
};
flax.addModule(flax.FlaxSpriteBatch, flax.TileMapModule);
flax.addModule(flax.FlaxSpriteBatch, flax.MoveModule);
flax.addModule(flax.FlaxSpriteBatch, flax.ScreenLayoutModule);
flax.addModule(flax.FlaxSpriteBatch, flax.PhysicsModule);
window.flax.FlaxSpriteBatch = flax.FlaxSpriteBatch;
_p = flax.FlaxSprite.prototype;
cc.defineGetterSetter(_p, "mainCollider", _p.getMainCollider);
_p.getPhysicsBody && cc.defineGetterSetter(_p, "physicsBody", _p.getPhysicsBody);
cc.defineGetterSetter(_p, "center", _p.getCenter);
cc.defineGetterSetter(_p, "fps", _p.getFPS, _p.setFPS);
cc.defineGetterSetter(_p, "tileMap", _p.getTileMap, _p.setTileMap);
cc.defineGetterSetter(_p, "currentLabel", _p.getCurrentLabel);
cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
_p = flax.FlaxSpriteBatch.prototype;
cc.defineGetterSetter(_p, "mainCollider", _p.getMainCollider);
_p.getPhysicsBody && cc.defineGetterSetter(_p, "physicsBody", _p.getPhysicsBody);
cc.defineGetterSetter(_p, "center", _p.getCenter);
cc.defineGetterSetter(_p, "fps", _p.getFPS, _p.setFPS);
cc.defineGetterSetter(_p, "tileMap", _p.getTileMap, _p.setTileMap);
cc.defineGetterSetter(_p, "currentLabel", _p.getCurrentLabel);
cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
flax.Animator = flax.FlaxSprite.extend({
	frameNames: null,
	clsName: "flax.Animator",
	onNewSource: function() {
		this.frameNames = flax.assetsManager.getFrameNames(this.assetsFile, this.define.start, this.define.end);
		this.totalFrames = this.frameNames.length;
		0 == this.totalFrames && cc.log("There is no frame for display: " + this.assetID)
	},
	doRenderFrame: function(a) {
		this.setSpriteFrame(this.frameNames[a])
	},
	getDefine: function() {
		var a = flax.assetsManager.getDisplayDefine(this.assetsFile, this.assetID);
		if (null == a) throw "There is no Animator named: " + this.assetID + " in assets: " + this.assetsFile + ", or make sure this class extends from the proper class!";
		return a
	}
});
flax.Animator.create = function(a, b) {
	var c = new flax.Animator(a, b);
	c.clsName = "flax.Animator";
	return c
};
window.flax.Animator = flax.Animator;
flax._image = {
	define: null,
	name: null,
	assetsFile: null,
	assetID: null,
	clsName: "flax.Image",
	autoRecycle: !1,
	_anchorBindings: null,
	__instanceId: null,
	_imgFile: null,
	_sx: 1,
	_sy: 1,
	_imgSize: null,
	_destroyed: !1,
	ctor: function(a, b) {
		this instanceof cc.Sprite ? cc.Sprite.prototype.ctor.call(this) : (this.define = flax.assetsManager.getDisplayDefine(a, b), this._imgFile = a.slice(0, a.lastIndexOf("/")) + "/" + this.define.url, cc.Scale9Sprite.prototype.ctor.call(this, this._imgFile, cc.rect(), this.define.scale9), this.clsName = "flax.Scale9Image");
		if (!a || !b) throw "Please set assetsFile and assetID to me!";
		this.__instanceId = ClassManager.getNewInstanceId();
		this._anchorBindings = [];
		this.setSource(a, b)
	},
	setSource: function(a, b) {
		if (null == a || null == b) throw "assetsFile and assetID can not be null!";
		if (!(this.assetsFile == a && this.assetID == b)) {
			this.assetsFile = a;
			this.assetID = b;
			this.define = flax.assetsManager.getDisplayDefine(this.assetsFile, this.assetID);
			this._imgFile = this.assetsFile.slice(0, this.assetsFile.lastIndexOf("/")) + "/" + this.define.url;
			flax.Scale9Image && this instanceof flax.Scale9Image ? this.initWithFile(this._imgFile, cc.rect(), this.define.scale9) : this.initWithFile(this._imgFile);
			if (cc.sys.isNative) this.onImgLoaded();
			else this.addEventListener("load", this.onImgLoaded, this);
			var c = this.define.anchorX,
				d = this.define.anchorY;
			!isNaN(c) && !isNaN(d) && this.setAnchorPoint(c, d);
			this.onNewSource();
			null == this.__pool__id__ && (this.__pool__id__ = this.assetID)
		}
	},
	onImgLoaded: function() {
		this._imgSize = (new cc.Sprite(this._imgFile)).getContentSize();
		this.scheduleOnce(function() {
			this._updateSize(this._sx, this._sy)
		}, 0.01)
	},
	destroy: function() {
		this._destroyed || (this._destroyed = !0, this.autoRecycle && flax.ObjectPool.get(this.assetsFile, this.clsName, this.__pool__id__ || "").recycle(this), this.removeFromParent())
	},
	onEnter: function() {
		this._super();
		this._destroyed = !1
	},
	onExit: function() {
		this._super();
		flax.inputManager.removeListener(this);
		for (var a = null, b = -1, c = this._anchorBindings.length; ++b < c;) a = this._anchorBindings[b], a.destroy ? a.destroy() : a.removeFromParent(!0), delete a.__anchor__;
		this._anchorBindings.length = 0
	},
	onRecycle: function() {
		this.autoRecycle = !1;
		this.setScale(1);
		this.opacity = 255;
		this.rotation = 0;
		this.setPosition(0, 0)
	},
	getAnchor: function(a) {
		return this.define.anchors && (a = this.define.anchors[a], null != a) ? new flax.Anchor(a[0]) : null
	},
	bindAnchor: function(a, b, c) {
		if (!this.define.anchors) return cc.log(this.assetID + ": there is no any anchor!"), !1;
		if (null == this.define.anchors[a]) return cc.log(this.assetID + ": there is no anchor named " + a), !1;
		if (null == b) throw "Node can't be null!";
		if (-1 < this._anchorBindings.indexOf(b)) return cc.log(this.assetID + ": anchor has been bound, " + a), !1;
		!1 !== c && this._anchorBindings.push(b);
		b.__anchor__ = a;
		this._updateAnchorNode(b, this.getAnchor(a));
		b.parent != this && (b.removeFromParent(!1), this.addChild(b));
		return !0
	},
	_updateAnchorNode: function(a, b) {
		null != b && (a.x = b.x, a.y = b.y, a.zIndex = b.zIndex, a.rotation = b.rotation)
	},
	setScaleX: function(a) {
		flax.Scale9Image && this instanceof flax.Scale9Image ? (this._sx = a, this._updateSize(a, this._sy)) : cc.Node.prototype.setScaleX.call(this, a)
	},
	setScaleY: function(a) {
		flax.Scale9Image && this instanceof
		flax.Scale9Image ? (this._sy = a, this._updateSize(this._sx, a)) : cc.Node.prototype.setScaleY.call(this, a)
	},
	_updateSize: function(a, b) {
		null != this._imgSize && (this.width = this._imgSize.width * a, this.height = this._imgSize.height * b)
	},
	onNewSource: function() {}
};
flax.Image = cc.Sprite.extend(flax._image);
cc.Scale9Sprite && (flax.Scale9Image = cc.Scale9Sprite.extend(flax._image), _p = flax.Image.prototype, cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX), cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY), _p = flax.Scale9Image.prototype, cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX), cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY), window.flax.Image = flax.Image, window.flax.Scale9Image = flax.Scale9Image);
flax.Image.create = function(a, b) {
	if (flax.assetsManager.getDisplayDefine(a, b).scale9) {
		if (null == flax.Scale9Image) throw "Please add module of 'gui' into project.json if you want to use Scale9Image!";
		var c = new flax.Scale9Image(a, b)
	} else c = new flax.Image(a, b);
	return c
};
flax.FrameData = cc.Class.extend({
	x: 0,
	y: 0,
	rotation: 0,
	scaleX: 1,
	scaleY: 1,
	opacity: 255,
	zIndex: -1,
	skewX: 0,
	skewY: 0,
	font: null,
	fontSize: 12,
	fontColor: "",
	textAlign: "",
	textWidth: 40,
	textHeight: 20,
	_isText: !1,
	_data: null,
	_hasSkew: !1,
	ctor: function(a) {
		this._data = a;
		this.x = parseFloat(a[0]);
		this.y = parseFloat(a[1]);
		this.rotation = parseFloat(a[2]);
		this.scaleX = parseFloat(a[3]);
		this.scaleY = parseFloat(a[4]);
		this.opacity = Math.round(255 * parseFloat(a[5]));
		6 < a.length && (this.zIndex = parseInt(a[6]));
		7 < a.length && (this.skewX = parseFloat(a[7]));
		8 < a.length && (this.skewY = parseFloat(a[8]));
		this._hasSkew = 7 < a.length;
		9 < a.length && (this._isText = !0, this.font = a[9], this.fontSize = parseInt(a[10]), this.fontColor = cc.hexToColor(a[11]), this.textAlign = H_ALIGHS.indexOf(a[12]), this.textWidth = parseFloat(a[13]), this.textHeight = parseFloat(a[14]))
	},
	setForChild: function(a) {
		this._hasSkew || a.setRotation(this.rotation);
		a.setScaleX(this.scaleX);
		a.setScaleY(this.scaleY);
		this._hasSkew && (a.setRotationX(this.skewX), a.setRotationY(this.skewY));
		a.setOpacity && a.setOpacity(this.opacity);
		var b = this.x,
			c = this.y;
		this.font && a instanceof cc.LabelTTF && (a.setFontName(this.font), a.setFontFillColor(this.fontColor), a.setHorizontalAlignment(this.textAlign), a.setDimensions({
			width: this.textWidth,
			height: this.textHeight
		}), a.setFontSize(this.fontSize - 1), a.setFontSize(this.fontSize), b += this.textWidth / 2, c -= this.textHeight / 2);
		a.setPositionX(b);
		a.setPositionY(c)
	},
	clone: function() {
		return new flax.FrameData(this._data)
	}
});
flax._movieClip = {
	clsName: "flax.MovieClip",
	sameFpsForChildren: !0,
	createChildFromPool: !0,
	_autoPlayChildren: !1,
	namedChildren: null,
	_theRect: null,
	_frameDatas: null,
	__isMovieClip: !0,
	replaceChild: function(a, b, c) {
		var d = this.define.children[a];
		if (null == d) cc.log("There is no child with named: " + a + "  in MovieClip: " + this.assetID);
		else {
			var e = this.namedChildren[a];
			if (e) {
				c || (c = this.assetsFile);
				d = flax.assetsManager.getAssetType(c, b);
				if (!d) throw "There is no display with assetID: " + b + " in assets: " + c;
				flax.assetsManager.getAssetType(e.assetsFile, e.assetID) == d ? e.setSource(c, b) : (d = e._autoPlayChildren, e.destroy(), e = flax.assetsManager.createDisplay(c, b, null, this.createChildFromPool), e.name = a, this.namedChildren[a] = e, !0 === e.__isMovieClip && !d && (e.autoPlayChildren = this._autoPlayChildren), this._autoPlayChildren && !0 === e.__isFlaxSprite && (this.playing ? e.gotoAndPlay(0) : e.gotoAndStop(0)), this[a] = e, this.addChild(e))
			} else d["class"] = b, d.assetsFile = c
		}
	},
	getFrameData: function(a, b) {
		return null == this._frameDatas[a] ? null : this._frameDatas[a][b]
	},
	setOpacity: function(a) {
		cc.Node.prototype.setOpacity.call(this, a);
		for (var b in this.namedChildren) {
			var c = this.namedChildren[b];
			c.setOpacity && c.setOpacity(a)
		}
	},
	setColor: function(a) {
		cc.Node.prototype.setColor.call(this, a);
		for (var b in this.namedChildren) {
			var c = this.namedChildren[b];
			c.setColor && c.setColor(a)
		}
	},
	onNewSource: function() {
		for (var a in this.namedChildren) this.namedChildren[a].destroy(), delete this.namedChildren[a], delete this[a];
		this.namedChildren = {};
		this.totalFrames = this.define.totalFrames;
		this._theRect = flax._strToRect(this.define.rect);
		this.setContentSize(this._theRect.width, this._theRect.height);
		this._initFrameDatas()
	},
	_initFrameDatas: function() {
		this._frameDatas = {};
		for (var a in this.define.children) {
			for (var b = [], c = this.define.children[a].frames, d = -1; ++d < c.length;) {
				var e = c[d];
				e && (e = e.split(","), b[d] = new flax.FrameData(e))
			}
			this._frameDatas[a] = b
		}
	},
	onEnter: function() {
		this._super();
		this.setContentSize(this._theRect.width, this._theRect.height)
	},
	doRenderFrame: function(a) {
		var b, c, d, e;
		for (e in this.define.children) c = this.define.children[e], d = this._frameDatas[e][a], b = this.namedChildren[e], d ? (null == b && (b = null != c.text ? flax.Label.create(this.assetsFile, d, c) : flax.assetsManager.createDisplay(c.assetsFile || this.assetsFile, c["class"], null, this.createChildFromPool), b.name = e, this.namedChildren[e] = b, this[e] = b, this.onNewChild(b)), d.setForChild(b), this.sameFpsForChildren && (b.fps = this.fps), c = -1 == d.zIndex ? c.zIndex : d.zIndex, b.parent != this ? (b.removeFromParent(!1), this.addChild(b, c)) : b.zIndex != c && (b.zIndex = c)) : b && (b.destroy ? b.destroy() : b.removeFromParent(!0), delete this.namedChildren[e], delete this[e])
	},
	stop: function() {
		this._super();
		if (this._autoPlayChildren) for (var a in this.namedChildren) {
			var b = this.namedChildren[a];
			!0 === b.__isFlaxSprite && b.stop()
		}
	},
	play: function() {
		this._super();
		if (this._autoPlayChildren) for (var a in this.namedChildren) {
			var b = this.namedChildren[a];
			!0 === b.__isFlaxSprite && b.play()
		}
	},
	getAutoPlayChildren: function() {
		return this._autoPlayChildren
	},
	setAutoPlayChildren: function(a) {
		if (this._autoPlayChildren != a) {
			this._autoPlayChildren = a;
			for (var b in this.namedChildren) {
				var c = this.namedChildren[b];
				!0 === c.__isMovieClip && (c.setAutoPlayChildren(a), a ? c.play() : c.stop())
			}
		}
	},
	onNewChild: function(a) {
		!0 === a.__isMovieClip && (a.autoPlayChildren = this._autoPlayChildren);
		this._autoPlayChildren && !0 === a.__isFlaxSprite && (this.playing ? a.gotoAndPlay(0) : a.gotoAndStop(0))
	},
	getDefine: function() {
		var a = flax.assetsManager.getMc(this.assetsFile, this.assetID);
		if (null == a) throw "There is no MovieClip named: " + this.assetID + " in assets: " + this.assetsFile + ", or make sure this class extends from the proper class!";
		return a
	},
	getChild: function(a, b) {
		void 0 === b && (b = !0);
		var c = this.namedChildren[a];
		if (c) return c;
		if (!b) return null;
		for (var d in this.namedChildren)
		if (c = this.namedChildren[d], c.getChild && (c = c.getChild(a, b))) return c;
		return null
	},
	getChildByAssetID: function(a) {
		var b = null,
			c;
		for (c in this.namedChildren)
		if (b = this.namedChildren[c], b.assetID == a) return b;
		return null
	},
	getLabelText: function(a, b) {
		var c = this.getChild(a, void 0 === b ? !0 : b);
		return c && (c instanceof flax.Label || c instanceof cc.LabelTTF) ? c.getString() : null
	},
	setLabelText: function(a, b, c) {
		return (a = this.getChild(a, void 0 === c ? !0 : c)) && (a instanceof flax.Label || a instanceof cc.LabelTTF) ? (a.setString(b), a) : null
	},
	setFPS: function(a) {
		if (this._fps != a && (this._fps = a, this.updateSchedule(), this.sameFpsForChildren)) {
			a = null;
			for (var b in this.namedChildren) a = this.namedChildren[b], a.fps = this._fps
		}
	},
	onRecycle: function() {
		this._super();
		this._autoPlayChildren = !1;
		if (RESET_FRAME_ON_RECYCLE) for (var a in this.namedChildren) {
			var b = this.namedChildren[a];
			!0 === b.__isFlaxSprite && b.gotoAndStop(0)
		}
	}
};
flax.MovieClip = flax.FlaxSprite.extend(flax._movieClip);
flax.MovieClip.create = function(a, b) {
	var c = new flax.MovieClip(a, b);
	c.clsName = "flax.MovieClip";
	return c
};
_p = flax.MovieClip.prototype;
cc.defineGetterSetter(_p, "autoPlayChildren", _p.getAutoPlayChildren, _p.setAutoPlayChildren);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
window.flax.MovieClip = flax.MovieClip;
flax.MovieClipBatch = flax.FlaxSpriteBatch.extend(flax._movieClip);
flax.MovieClipBatch.create = function(a, b) {
	var c = new flax.MovieClipBatch(a, b);
	c.clsName = "flax.MovieClipBatch";
	return c
};
_p = flax.MovieClipBatch.prototype;
cc.defineGetterSetter(_p, "autoPlayChildren", _p.getAutoPlayChildren, _p.setAutoPlayChildren);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
window.flax.MovieClipBatch = flax.MovieClipBatch;
flax.ProgressBarType = {
	HORIZONTAL: "horizontal",
	VERTICAL: "vertical",
	RADIAL: "radial"
};
flax.ProgressBar = flax.Animator.extend({
	pBar: null,
	_type: flax.ProgressBarType.HORIZONTAL,
	_reversed: !1,
	_tween: null,
	onEnter: function() {
		this._super()
	},
	getPercentage: function() {
		return this.pBar ? this.pBar.percentage : 0
	},
	setPercentage: function(a) {
		this.pBar && (this.pBar.percentage = a)
	},
	getType: function() {
		return this._type
	},
	setType: function(a) {
		this._type != a && (this._type = a, this._updatePBar())
	},
	getReversed: function() {
		return this._reversed
	},
	setReversed: function(a) {
		this._reversed != a && (this._reversed = a, this._updatePBar(), this.percentage += 0.1, this.percentage -= 0.1)
	},
	tween: function(a, b, c) {
		null != this.pBar && (this._tween && (this.pBar.stopAction(this._tween), this._tween.release()), this._tween = cc.progressFromTo(c, a, b), this._tween.retain(), this.pBar.runAction(this._tween))
	},
	stopTween: function() {
		this._tween && this.pBar && (this.pBar.stopAction(this._tween), this._tween.release(), this._tween = null)
	},
	doRenderFrame: function(a) {
		if (a = cc.spriteFrameCache.getSpriteFrame(this.frameNames[a])) a = new cc.Sprite(a), null == this.pBar ? (this.width = a.width, this.height = a.height, this.pBar = cc.ProgressTimer.create(a), this._updatePBar(), this.pBar.setAnchorPoint(this.getAnchorPoint()), this.pBar.setPosition(this.getAnchorPointInPoints()), this.addChild(this.pBar)) : this.pBar.setSprite(a)
	},
	_updatePBar: function() {
		if (null != this.pBar) if (this._type == flax.ProgressBarType.RADIAL) this.pBar.type = 0, this.pBar.setReverseDirection(this._reversed), this.pBar.midPoint = cc.p(0.5, 0.5);
		else {
			this.pBar.type = 1;
			var a = this._type == flax.ProgressBarType.HORIZONTAL,
				b = cc.p(0, 0),
				c = cc.p(a ? 1 : 0, a ? 0 : 1);
			this._reversed && (a ? b.x = 1 : b.y = 1);
			this.pBar.midPoint = b;
			this.pBar.barChangeRate = c
		}
	}
});
flax.ProgressBar.create = function(a, b) {
	var c = new flax.ProgressBar(a, b);
	c.clsName = "flax.ProgressBar";
	return c
};
window.flax.ProgressBar = flax.ProgressBar;
_p = flax.ProgressBar.prototype;
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "reversed", _p.getReversed, _p.setReversed);
flax.Label = cc.Sprite.extend({
	mlWidth: 0,
	mlHeight: 0,
	fontName: null,
	fontSize: 20,
	frames: [],
	chars: [],
	assetsFile: null,
	name: null,
	params: null,
	_str: null,
	_gap: 0,
	_spaceGap: 10,
	_charCanvas: null,
	_fontDefine: null,
	getString: function() {
		return this._str
	},
	setString: function(a) {
		a !== this._str && (this._str = "" + a, this._updateStr())
	},
	getSpaceGap: function() {
		return this._spaceGap
	},
	setSpaceGap: function(a) {
		this._spaceGap != a && (this._spaceGap = a, this._str && -1 < this._str.indexOf(" ") && this._updateStr())
	},
	getGap: function() {
		return this._gap
	},
	setGap: function(a) {
		a != this._gap && (this._gap = a, this._str && this._updateStr())
	},
	setFontName: function(a) {
		if (null != a && !(null != this.fontName && this.fontName == a)) {
			this.fontName = a;
			this._fontDefine = flax.assetsManager.getFont(this.assetsFile, this.fontName);
			if (null == this._fontDefine) throw "Can't find the font named: " + this.fontName;
			this.frames = flax.assetsManager.getFrameNames(this.assetsFile, parseInt(this._fontDefine.start), parseInt(this._fontDefine.end));
			this.chars = this._fontDefine.chars;
			this.fontSize = parseInt(this._fontDefine.size)
		}
	},
	tweenInt: function(a, b, c) {
		this.setString(a);
		var d = flax.numberSign(b - a);
		if (0 != d) {
			var e = Math.abs(b - a),
				f = Math.max(c / e, flax.frameInterval),
				e = Math.round(c / f),
				d = d * Math.round(Math.abs(b - a) / e);
			this.schedule(function(a) {
				a = parseInt(this._str);
				var c = a + d;
				0 < d && c > b ? c = b : 0 > d && c < b && (c = b);
				c != a && this.setString(c)
			}, f, e + 10)
		}
	},
	_updateStr: function() {
		if (null == this._charCanvas) {
			var a = cc.path.changeBasename(this.assetsFile, ".png");
			this._charCanvas = new cc.SpriteBatchNode(a, this._str.length);
			this.addChild(this._charCanvas)
		}
		this._charCanvas.removeAllChildren();
		for (i = this.mlHeight = this.mlWidth = 0; i < this._str.length; i++)
		if (a = this._str[i], "\n" != a) if (" " == a) this.mlWidth += this._spaceGap;
		else {
			for (var b = -1, c = 0; c < this.chars.length; c++)
			if (this.chars[c] == a) {
				b = c;
				break
			} - 1 == b ? cc.log("Not found the char: " + a + " in the fonts: " + this.fontName) : (sprite = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame(this.frames[b])), sprite.anchorX = this._fontDefine.anchorX, sprite.anchorY = this._fontDefine.anchorY, a = sprite.getContentSize(), sprite.x = this.mlWidth, sprite.y = 0, this.mlWidth += a.width, i != this._str.length - 1 && (this.mlWidth += this._gap), this.mlHeight = a.height > this.mlHeight ? a.height : this.mlHeight, this._charCanvas.addChild(sprite))
		}
		if (this.params) {
			b = Math.max(this.mlWidth / this.params.textWidth, this.mlHeight / this.params.textHeight);
			a = 0;
			1 < b && (c = 1 / b, this._charCanvas.scale = c, a = this.mlHeight * (1 - 1 / b) * b, this.mlWidth *= c, this.mlHeight *= c);
			b = (this.params.textWidth - this.mlWidth) / 2;
			for (i = this._charCanvas.childrenCount; i--;) charChild = this._charCanvas.children[i], "center" == H_ALIGHS[this.params.textAlign] ? charChild.x += b : "right" == H_ALIGHS[this.params.textAlign] && (charChild.x += 2 * b), charChild.y -= a
		}
		this._charCanvas.setContentSize(this.mlWidth, this.mlHeight);
		this.setContentSize(this.mlWidth, this.mlHeight)
	},
	getRect: function(a) {
		null == a && (a = !0);
		var b = cc.rect(0.5 * this.width / this._str.length, -this.params.textHeight, this.width, this.height + 2);
		b.y += (this.params.textHeight - this.height) / 2 - 1;
		if (!a) return b;
		var c = b.width,
			d = b.height,
			b = cc.p(b.x, b.y),
			b = this.convertToWorldSpace(b);
		a instanceof cc.Node && (b = a.convertToNodeSpace(b));
		return cc.rect(b.x, b.y, c, d)
	},
	destroy: function() {
		this.removeFromParent()
	}
});
_p = flax.Label.prototype;
cc.defineGetterSetter(_p, "gap", _p.getGap, _p.setGap);
cc.defineGetterSetter(_p, "spaceGap", _p.getSpaceGap, _p.setSpaceGap);
cc.defineGetterSetter(_p, "text", _p.getString, _p.setString);
_p = cc.LabelTTF.prototype;
cc.defineGetterSetter(_p, "text", _p.getString, _p.setString);
flax.Label.create = function(a, b, c) {
	if (!1 === b._isText) throw "The assetsFile: " + a + " was exported with old version of Flax tool, re-export it to fix the Text issue!";
	cc.sys.isNative || (c.text = c.text.split("\\").join(""));
	var d = null,
		e = c["class"],
		f = flax.assetsManager.getFont(a, e);
	if (!0 == c.input) {
		if (null == cc.EditBox) throw "If you want to use input text, please add module of 'editbox' into project.json!";
		d = flax.assetsManager.getFrameNamesOfDisplay(a, e);
		d = new cc.EditBox(cc.size(b.textWidth, b.textHeight), new cc.Scale9Sprite(d[0]), d[1] ? new cc.Scale9Sprite(d[1]) : null, d[2] ? new cc.Scale9Sprite(d[2]) : null);
		d.setFontColor(b.fontColor);
		d.setFontName(b.font);
		d.setFontSize(b.fontSize);
		d.setPlaceHolder(c.text);
		d.setPlaceholderFontName(b.font);
		d.setPlaceholderFontSize(b.fontSize);
		b = flax.assetsManager.getDisplayDefine(a, e);
		d.setAnchorPoint(b.anchorX, b.anchorY)
	} else b.font && null == f ? (a = new cc.FontDefinition, a.fontName = b.font, a.fontSize = b.fontSize, a.textAlign = b.textAlign, a.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_CENTER, a.fillStyle = b.fontColor, a.fontDimensions = !0, a.boundingWidth = b.textWidth, a.boundingHeight = b.textHeight, "null" == e ? d = new cc.LabelTTF(c.text, a) : flax.getLanguageStr && (d = new cc.LabelTTF(flax.getLanguageStr(e) || c.text, a))) : (d = new flax.Label, flax.assetsManager.addAssets(a), d.assetsFile = a, d.params = b, d.setFontName(e), d.setAnchorPoint(0, 0), d.setString(c.text));
	return d
};
flax._fontResources = null;
flax.registerFont = function(a, b) {
	a && b && ("string" == typeof b && (b = [b]), null == flax._fontResources && (flax._fontResources = {}), flax._fontResources[a] = b)
};
var ButtonState = {
	UP: "up",
	OVER: "over",
	DOWN: "down",
	SELECTED: "selected",
	SELECTED_OVER: "selected_over",
	SELECTED_DOWN: "selected_down",
	DISABLED: "disabled",
	LOCKED: "locked"
};
MOUSE_DOWN_SCALE = 0.95;
flax._buttonDefine = {
	clickSound: null,
	group: null,
	_playChildrenOnState: !1,
	_state: null,
	_initScaleX: 1,
	_initScaleY: 1,
	_inScaleDown: !1,
	_inDisabledGray: !0,
	__isButton: !0,
	onEnter: function() {
		this._super();
		this._initScaleX = this.scaleX;
		this._initScaleY = this.scaleY;
		flax.inputManager.addListener(this, this._onPress, InputType.press);
		flax.inputManager.addListener(this, this._onClick, InputType.click);
		flax.inputManager.addListener(this, this._onMove, InputType.move);
		if (!cc.sys.isMobile) {
			var a = this,
				b = cc.EventListener.create({
					event: cc.EventListener.MOUSE,
					onMouseMove: function(b) {
						if (0 != b.getButton()) {
							var d = {
								target: a,
								currentTarget: a
							};
							a.isMouseEnabled() && a._onMove(b, d)
						}
					}
				});
			cc.eventManager.addListener(b, this)
		}
	},
	onExit: function() {
		this.group && (this.group.removeButton(this), this.group = null);
		cc.eventManager.removeListener(this);
		this._super()
	},
	onRecycle: function() {
		this._super();
		this._playChildrenOnState = !1;
		this._state = null;
		this._inScaleDown = !1;
		this.disabledCover && (this.disabledCover.visible = !0);
		this._inDisabledGray = !0
	},
	setState: function(a) {
		var b = this.isSelected();
		this._state = a;
		this.gotoAndStop(this._state) || (a = this.isSelected() ? ButtonState.SELECTED : ButtonState.UP, this.gotoAndStop(a) || (this.gotoAndStop(0), -1 < this._state.indexOf("down") && (this._inScaleDown = !0, this.setScale(this._initScaleX * MOUSE_DOWN_SCALE, this._initScaleY * MOUSE_DOWN_SCALE)), this._state == ButtonState.DISABLED && (this._inDisabledGray = !0, this.disabledCover && (this.disabledCover.visible = !0)))); - 1 == this._state.indexOf("down") && this._inScaleDown && this.setScale(this._initScaleX, this._initScaleY);
		this._state != ButtonState.DISABLED && this._inDisabledGray && (this._inDisabledGray = !1, this.disabledCover && (this.disabledCover.visible = !1));
		this._playOrPauseChildren();
		this.isSelected() && (!b && this.group) && this.group.updateButtons(this);
		this.handleStateChange()
	},
	handleStateChange: function() {},
	getState: function() {
		return this._state
	},
	isSelected: function() {
		return this._state && 0 == this._state.indexOf("selected")
	},
	setSelected: function(a) {
		this.isSelected() == a || (!this.isSelectable() || !this.isMouseEnabled() || this.isLocked()) || this.setState(a ? ButtonState.SELECTED : ButtonState.UP)
	},
	isSelectable: function() {
		return this.hasLabel(ButtonState.SELECTED)
	},
	setMouseEnabled: function(a) {
		this.setState(a ? ButtonState.UP : ButtonState.DISABLED);
		return !0
	},
	isMouseEnabled: function() {
		return this._state != ButtonState.DISABLED
	},
	setLocked: function(a) {
		this.setState(a ? ButtonState.LOCKED : ButtonState.UP)
	},
	isLocked: function() {
		return this._state == ButtonState.LOCKED
	},
	setPlayChildrenOnState: function(a) {
		this._playChildrenOnState != a && (this._playChildrenOnState = a, this._playOrPauseChildren())
	},
	getPlayChildrenOnState: function() {
		return this._playChildrenOnState
	},
	_onPress: function(a, b) {
		if (!(this._state == ButtonState.LOCKED || this._state == ButtonState.DISABLED)) {
			var c = this.clickSound || flax.buttonSound;
			c && flax.playSound(c);
			this._toSetState(ButtonState.DOWN)
		}
	},
	_onClick: function(a, b) {
		this._state == ButtonState.LOCKED || this._state == ButtonState.DISABLED || (this.isSelectable() ? !this.isSelected() || this.group ? this.setState(ButtonState.SELECTED) : this.setState(ButtonState.UP) : this.setState(ButtonState.UP))
	},
	_onMove: function(a, b) {
		this._state == ButtonState.DISABLED || this._state == ButtonState.LOCKED || (flax.ifTouched(this, a.getLocation()) ? this._toSetState(cc.sys.isMobile ? ButtonState.DOWN : ButtonState.OVER) : this._toSetState(ButtonState.UP))

	},
	_toSetState: function(a) {
		this.isSelectable() && this.isSelected() && (a = a == ButtonState.UP ? ButtonState.SELECTED : "selected_" + a);
		this.setState(a)
	},
	_playOrPauseChildren: function() {
		for (var a = this.childrenCount; a--;) {
			var b = this.children[a];
			flax.isFlaxSprite(b) && (this._playChildrenOnState ? (b.autoPlayChildren = !0, b.play()) : (b.autoPlayChildren = !1, b.stop()))
		}
	}
};
flax.SimpleButton = flax.Animator.extend(flax._buttonDefine);
flax.SimpleButton.create = function(a, b) {
	var c = new flax.SimpleButton(a, b);
	c.clsName = "flax.SimpleButton";
	c.setState(ButtonState.UP);
	return c
};
window.flax.SimpleButton = flax.SimpleButton;
_p = flax.SimpleButton.prototype;
cc.defineGetterSetter(_p, "state", _p.getState, _p.setState);
cc.defineGetterSetter(_p, "playChildrenOnState", _p.getPlayChildrenOnState, _p.setPlayChildrenOnState);
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
flax.Button = flax.MovieClip.extend(flax._buttonDefine);
flax.Button.create = function(a, b) {
	var c = new flax.Button(a, b);
	c.clsName = "flax.Button";
	c.setState(ButtonState.UP);
	return c
};
window.flax.Button = flax.Button;
_p = flax.Button.prototype;
cc.defineGetterSetter(_p, "state", _p.getState, _p.setState);
cc.defineGetterSetter(_p, "playChildrenOnState", _p.getPlayChildrenOnState, _p.setPlayChildrenOnState);
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
flax.ButtonGroup = cc.Class.extend({
	buttons: null,
	selectedButton: null,
	onSelected: null,
	ctor: function() {
		this.buttons = [];
		this.onSelected = new signals.Signal
	},
	addButton: function(a) {
		a instanceof Array || (a = Array.prototype.slice.call(arguments));
		for (var b = 0; b < a.length; b++) {
			var c = a[b],
				c = a[b];
			flax.isButton(c) && !(-1 < this.buttons.indexOf(c)) && (this.buttons.push(c), c.group = this)
		}
	},
	removeButton: function(a) {
		var b = this.buttons.indexOf(a); - 1 < b && (this.buttons.splice(b, 1), a.group = null);
		0 == this.buttons.length && (this.onSelected.removeAll(), this.onSelected = null)
	},
	updateButtons: function(a) {
		for (var b = 0; b < this.buttons.length; b++) {
			var c = this.buttons[b];
			c != a && (c.isMouseEnabled() && !c.isLocked()) && c.setState(ButtonState.UP)
		}
		this.selectedButton = a;
		b = flax.mousePos && flax.ifTouched(a, flax.mousePos);
		this.onSelected.dispatch(a, b)
	}
});
flax._preloader = {
	resources: null,
	_label: null,
	_logo: null,
	_inited: !1,
	initWithResources: function(a, b) {
		this.init();
		"string" == typeof a && (a = [a]);
		this.resources = a || [];
		this.cb = b
	},
	init: function() {
		if (!this._inited) {
			this._inited = !0;
			var a = this,
				b = cc.director.getWinSize();
			if (this instanceof cc.Layer) {
				var c = new cc.LayerColor(cc.color(0, 0, 0, 100));
				this.addChild(c, 0)
			}
			var d = cc.p(b.width / 2, b.height / 2),
				e = "res/" + String(g.language) + "/logo.png";
			cc.log(g.language);
			e && flax.isImageFile(e) ? cc.loader.load(e, function() {
				a._logo = new cc.Sprite(e);
				a._logo.setPosition(d);
				a.addChild(a._logo, 10);
				if (!cc.sys.isNative) {
					var b = 16 * (1 + a._logo.width / 200);
					a.createLabel(cc.pSub(d, cc.p(0, a._logo.height / 2 + 0.6 * b)), b);
					a.logoClick()
				}
			}) : a.createLabel(d)
		}
	},
	createLabel: function(a, b) {
		var c = this._label = new cc.LabelTTF("Loading...", "Arial", b || 18);
		c.enableStroke(cc.color(51, 51, 51), 2);
		c.setColor(cc.color(255, 255, 255));
		c.setPosition(a);
		this.addChild(c, 10)
	},
	logoClick: function() {
		var a = this._logo,
			b = cc.EventListener.create({
				event: cc.EventListener.TOUCH_ONE_BY_ONE,
				swallowTouches: !1,
				onTouchBegan: function(b, d) {
					return cc.rectContainsPoint(flax.getRect(a, !0), b.getLocation()) ? (flax.goHomeUrl(), !0) : !1
				}
			});
		cc.eventManager.addListener(b, this._logo)
	},
	onEnter: function() {
		cc.Node.prototype.onEnter.call(this);
		this.resources && this.schedule(this._startLoading, 0.3)
	},
	_startLoading: function() {
		var a = this;
		a.unschedule(a._startLoading);
		cc.loader.load(a.resources, function(b, c, d) {
			null != a._label && a._showProgress("Loading: ", c, d)
		}, function() {
			a.cb && a.cb()
		})
	},
	_showProgress: function(a, b, c) {
		this._label && (null != c ? this._label.setString(a + (c + 1) + "/" + b) : this._label.setString(a + b + "%"))
	}
};
flax.Preloader = cc.Scene.extend(flax._preloader);
flax.ResPreloader = cc.Layer.extend(flax._preloader);
window.flax.Preloader = flax.Preloader;
window.flax.ResPreloader = flax.ResPreloader;
ALL_DIRECTONS = "UP DOWN LEFT RIGHT LEFT_UP RIGHT_UP RIGHT_DOWN LEFT_DOWN".split(" ");
ALL_DIRECTONS0 = "UP DOWN LEFT RIGHT LEFT_UP LEFT_DOWN".split(" ");
ALL_DIRECTONS1 = "UP DOWN LEFT RIGHT RIGHT_UP RIGHT_DOWN".split(" ");
EIGHT_DIRECTIONS_VALUE = {
	UP: [0, 1],
	DOWN: [0, -1],
	LEFT: [-1, 0],
	RIGHT: [1, 0],
	LEFT_UP: [-1, 1],
	RIGHT_UP: [1, 1],
	RIGHT_DOWN: [1, -1],
	LEFT_DOWN: [-1, -1]
};
MAX_IN_TILE = 10;
flax.TileMap = cc.Node.extend({
	isHexagon: !1,
	autoLayout: !1,
	_allTilesIndex: null,
	_gridCanvas: null,
	_tileWidth: 0,
	_tileHeight: 0,
	_mapWidth: 0,
	_mapHeight: 0,
	_objectsMap: null,
	_objectsArr: null,
	_inUpdate: !1,
	_offset: null,
	ctor: function() {
		this._super();
		this.setAnchorPoint(0, 0);
		this._offset = cc.p()
	},
	init: function(a, b, c, d, e) {
		if (!a || !b) throw "Please set tileWdith and tileHeight!";
		this._tileWidth = a;
		this._tileHeight = b;
		c && d && this.setMapSize(c, d, e)
	},
	update: function(a) {
		for (a = this._objectsArr ? this._objectsArr.length : 0; a--;) {
			var b = this._objectsArr[a];
			b.autoUpdateTileWhenMove && b.updateTile()
		}
	},
	getTileSize: function() {
		return {
			width: this._tileWidth,
			height: this._tileHeight
		}
	},
	getMapSizePixel: function() {
		var a = cc.size(this._tileWidth * this._mapWidth, this._tileHeight * this._mapHeight);
		this.isHexagon && (a.width += 0.5 * this._tileWidth);
		return a
	},
	setMapSize: function(a, b, c) {
		!0 == c && (a = Math.ceil(a / this._tileWidth), b = Math.ceil(b / this._tileHeight));
		c = [
			[],
			[]
		];
		if (this._mapWidth == a && this._mapHeight == b) return c;
		null == this._objectsArr && (this._objectsArr = []);
		null == this._objectsMap && (this._objectsMap = []);
		for (var d = this._mapWidth, e = this._mapHeight, f = -1, k = -1, m = Math.max(a, d), n = Math.max(b, e); ++f < m;) {
			null == this._objectsMap[f] && (this._objectsMap[f] = []);
			for (k = -1; ++k < n;) f >= a || k >= b ? (c[0] = c[0].concat(this._objectsMap[f][k]), this.removeObjects(f, k), delete this._objectsMap[f][k]) : f < d && k < e || (this._objectsMap[f][k] = [], c[1].push([f, k]));
			0 == this._objectsMap[f].length && delete this._objectsMap[f]
		}
		this._mapWidth = a;
		this._mapHeight = b;
		this.setContentSize(this.getMapSizePixel());
		return c
	},
	getMapSize: function() {
		return {
			width: this._mapWidth,
			height: this._mapHeight
		}
	},
	showDebugGrid: function() {
		this.showGrid()
	},
	showGrid: function(a, b) {
		this._gridCanvas ? this._gridCanvas.clear() : (this._gridCanvas = cc.DrawNode.create(), this.addChild(this._gridCanvas));
		a || (a = 1);
		b || (b = cc.color(255, 0, 0, 255));
		for (var c = 0; c <= this._mapWidth; c++) this._gridCanvas.drawSegment(cc.p(c * this._tileWidth, 0), cc.p(c * this._tileWidth, this._tileHeight * this._mapHeight), a, b);
		for (c = 0; c <= this._mapHeight; c++) this._gridCanvas.drawSegment(cc.p(0, c * this._tileHeight), cc.p(this._tileWidth * this._mapWidth, c * this._tileHeight), a, b)
	},
	hideGrid: function() {
		this._gridCanvas && this._gridCanvas.clear()
	},
	showDebugTile: function(a, b, c) {
		a = this.getTiledPosition(a, b);
		null == c && (c = cc.color(0, 255, 0, 128));
		b = flax.getScale(this, !0);
		flax.drawRect(cc.rect(a.x - this._tileWidth * b.x / 2, a.y - this._tileHeight * b.y / 2, this._tileWidth * b.x, this._tileHeight * b.y), 1, c, c)
	},
	clear: function(a) {
		if (0 != this._objectsArr.length) {
			void 0 === a && (a = !0);
			for (var b, c = 0; c < this._mapWidth; c++)
			for (var d = 0; d < this._mapHeight; d++) {
				if (a) {
					b = this._objectsMap[c][d];
					for (var e in b) {
						var f = b[e];
						f instanceof cc.Node && f.destroy()
					}
				}
				this._objectsMap[c][d] = []
			}
			this._objectsArr.length = 0
		}
	},
	getTileIndex: function(a, b) {
		var c, d;
		null == b ? (c = a.x, d = a.y) : (c = a, d = b);
		var e = this._offset;
		e.x = this.getPositionX();
		e.y = this.getPositionY();
		this.parent && (e = this.parent.convertToWorldSpace(e));
		var f = flax.getScale(this, !0),
			k = Math.abs(f.x),
			m = Math.abs(f.y),
			f = Math.floor((c - e.x) / (this._tileWidth * k));
		d = Math.floor((d - e.y) / (this._tileHeight * m));
		this.isHexagon && 0 != d % 2 && (f = Math.floor((c - e.x - 0.5 * this._tileWidth * k) / (this._tileWidth * k)));
		return {
			x: f,
			y: d
		}
	},
	getTiledPosition: function(a, b) {
		var c = this._offset;
		c.x = this.getPositionX();
		c.y = this.getPositionY();
		this.parent && (c = this.parent.convertToWorldSpace(c));
		var d = flax.getScale(this, !0),
			e = Math.abs(d.x),
			f = Math.abs(d.y),
			d = (a + 0.5) * this._tileWidth * e + c.x,
			c = (b + 0.5) * this._tileHeight * f + c.y;
		this.isHexagon && 0 != b % 2 && (d += 0.5 * this._tileWidth * e);
		return {
			x: d,
			y: c
		}
	},
	getCoveredTiles: function(a, b) {
		var c = flax.getRect(a, !0);
		return this.getCoveredTiles1(c, b)
	},
	getCoveredTiles1: function(a, b) {
		b = !0 === b;
		for (var c = this.getTileIndex(a.x, a.y), d = c.x, e = c.y, c = this.getTileIndex(a.x + a.width, a.y + a.height), f = c.x, c = c.y, k = [], d = d - 1, m = 0; ++d <= f;)
		for (m = e - 1; ++m <= c;) b ? k = k.concat(this.getObjects(d, m)) : k.push({
			x: d,
			y: m
		});
		return k
	},
	isValideTile: function(a, b) {
		return 0 <= a && a < this._mapWidth && 0 <= b && b < this._mapHeight
	},
	snapToTile: function(a, b, c, d) {
		if (a instanceof cc.Node) {
			var e = null;
			if (null == b || null == c) e = a.getPosition(), a.parent && (e = a.parent.convertToWorldSpace(e)), c = this.getTileIndex(e), b = c.x, c = c.y;
			e = this.getTiledPosition(b, c);
			a.parent && (e = a.parent.convertToNodeSpace(e));
			a.setPosition(e);
			!0 === d && a.setTileMap(this)
		}
	},
	snapAll: function() {
		for (var a = this._objectsArr.length, b = -1, c = null; ++b < a;) c = this._objectsArr[b], this.snapToTile(c)
	},
	addObject: function(a, b, c) {
		void 0 === b && (b = a.tx);
		void 0 === c && (c = a.ty);
		a.tx = b;
		a.ty = c;
		if (this.isValideTile(b, c) && !(-1 < this._objectsArr.indexOf(a))) {
			this._objectsArr.push(a);
			var d = this._objectsMap[b][c];
			!this._inUpdate && cc.sys.isNative && (this._inUpdate = !0, cc.director.getScheduler().scheduleUpdateForTarget(this));
			if (!(a instanceof cc.Node) || !this.autoLayout) d.push(a);
			else {
				b = (b + (this._mapHeight - 1 - c) * this._mapWidth) * MAX_IN_TILE;
				c = null;
				for (var e = 0, f = !1, k = 0; k < d.length; k++) c = d[k], c instanceof cc.Node && (!f && c.y <= a.y && (d.splice(k, 0, a), a.zIndex = Math.min(e, MAX_IN_TILE) + b, f = !0, e++, k++), c.zIndex = Math.min(e, MAX_IN_TILE) + b, e++);
				f || (d.push(a), a.zOrder = Math.min(e, MAX_IN_TILE) + b)
			}
		}
	},
	updateLayout: function(a, b) {
		if (this.isValideTile(a, b)) {
			var c = this._objectsMap[a][b];
			if (0 != c.length) {
				c.sort(this._sortByY);
				for (var d = (a + (this._mapHeight - 1 - b) * this._mapWidth) * MAX_IN_TILE, e = null, f = 0, k = 0; k < c.length; k++) e = c[k], e instanceof cc.Node && (e.zIndex = Math.min(f, MAX_IN_TILE) + d, f++)
			}
		}
	},
	removeObject: function(a, b, c) {
		void 0 === b && (b = a.tx);
		void 0 === c && (c = a.ty);
		this.isValideTile(b, c) && (b = this._objectsMap[b][c], c = b.indexOf(a), -1 < c && b.splice(c, 1), c = this._objectsArr.indexOf(a), -1 < c && this._objectsArr.splice(c, 1));
		this._inUpdate && (cc.sys.isNative && 0 == this._objectsArr.length) && (this._inUpdate = !1, cc.director.getScheduler().unscheduleUpdateForTarget(this))
	},
	removeObjects: function(a, b) {
		if (this.isValideTile(a, b)) for (var c = this._objectsMap[a][b], d = null, d = -1; c.length;) d = c[0], d.tx = d.ty = -1, d = this._objectsArr.indexOf(d), -1 < d && this._objectsArr.splice(d, 1), c.splice(0, 1)
	},
	getObjects: function(a, b) {
		return this.isValideTile(a, b) ? this._objectsMap[a][b] : []
	},
	getObjects1: function(a, b) {
		var c = this.getTileIndex(a, b);
		return this.getObjects(c.x, c.y)
	},
	getAllObjects: function() {
		return this._objectsArr
	},
	getTiles: function(a) {
		for (var b = [], c = -1, d = -1; ++c < this._mapWidth;)
		for (d = -1; ++d < this._mapHeight;)(null == a || !1 !== a(this, c, d)) && b.push({
			x: c,
			y: d
		});
		return b
	},
	getRow: function(a, b) {
		for (var c = -1, d = []; ++c < this._mapHeight;) d = !0 === b ? d.concat(this.getObjects(a, c)) : d.push({
			x: a,
			y: c
		});
		return d
	},
	getCol: function(a, b) {
		for (var c = -1, d = []; ++c < this._mapWidth;) d = !0 === b ? d.concat(this.getObjects(c, a)) : d.push({
			x: c,
			y: a
		});
		return d
	},
	__tilesSearched: null,
	__nonRecursive: !1,
	findConnectedObjects: function(a, b, c) {
		this.__tilesSearched = {};
		b = this.findNeighbors(a, b, c, null, !1);
		a = b.indexOf(a); - 1 < a && b.splice(a, 1);
		this.__tilesSearched = null;
		return b
	},
	findNeighbors: function(a, b, c, d, e) {
		for (var f = this._getAllDirections(a, c, d), k = !this.__nonRecursive && null != this.__tilesSearched, m = [], n = f.length; n--;) {
			var p = EIGHT_DIRECTIONS_VALUE[f[n]],
				r = a.tx + p[0],
				p = a.ty + p[1];
			if (this.__tilesSearched) {
				var s = r + "-" + p;
				if (!0 === this.__tilesSearched[s]) continue;
				this.__tilesSearched[s] = !0
			}
			if (e) m.push({
				x: r,
				y: p
			});
			else for (var r = this.getObjects(r, p), p = null, s = !1, u = 0; u < r.length; u++)
			if (p = r[u], null == b || 0 == b.length || p[b] === a[b]) m.push(p), !s && k && (m = m.concat(this.findNeighbors(p, b, c, d, e)), s = !0)
		}
		return m
	},
	findSeparatedGroups: function() {
		var a = [],
			b = null;
		this.__tilesSearched = {};
		var c = this.getAllObjects(),
			d = [],
			e = c.length;
		for (i = 0; i < e; i++) nb = c[i], -1 < d.indexOf(nb) || (b = this.findNeighbors(nb), !b.length && !0 !== this.__tilesSearched[nb.tx + "-" + nb.ty] && (b = [nb], this.__tilesSearched[nb.tx + "-" + nb.ty] = !0), a.push(b), d = d.concat(b));
		this.__tilesSearched = null;
		return a
	},
	findSurroundings: function(a, b, c, d) {
		if (null == b || 1 > b) b = 1;
		a = [a];
		var e = [];
		this.__tilesSearched = {};
		for (this.__nonRecursive = !0; b--;) {
			for (var f = [], k = 0; k < a.length; k++) {
				var m = a[k];
				void 0 === m.tx && (m = {
					tx: m.x,
					ty: m.y
				});
				f = f.concat(this.findNeighbors(m, null, !0, null, c && d ? !c : !0))
			}
			a = f;
			if (c && !d) {
				for (var n = [], k = 0; k < f.length; k++) m = f[k], n = n.concat(this.getObjects(m.x, m.y));
				e.push(n)
			} else e.push(f)
		}
		this.__tilesSearched = null;
		this.__nonRecursive = !1;
		return e
	},
	_getAllDirections: function(a, b, c) {
		var d = ALL_DIRECTONS;
		this.isHexagon ? d = 0 == a.ty % 2 ? ALL_DIRECTONS0 : ALL_DIRECTONS1 : b || (d = d.slice(0, 4));
		a = ALL_DIRECTONS.indexOf(c);
		if (-1 == a || 3 < a) return d;
		b = [];
		var e = null;
		for (a = 0; a < d.length; a++) e = d[a], -1 < e.indexOf(c) && b.push(e);
		this.isHexagon && 1 == b.length && b.push("UP", "DOWN");
		return b
	},
	isEmptyTile: function(a, b) {
		if (!this.isValideTile(a, b)) return !1;
		var c = this.getObjects(a, b);
		return c ? 0 == c.length : !1
	},
	tileToIndex: function(a, b) {
		return b * this._mapWidth + a
	},
	indexToTile: function(a) {
		var b = a % this._mapWidth;
		return {
			x: b,
			y: Math.floor((a - b) / this._mapWidth)
		}
	},
	getAllTilesIndex: function() {
		if (!this._allTilesIndex) {
			this._allTilesIndex = [];
			for (var a = 0; a < this._mapWidth * this._mapHeight; a++) this._allTilesIndex.push(a)
		}
		return this._allTilesIndex
	},
	findEmptyTilesIndex: function() {
		for (var a = this.getAllTilesIndex().concat(), b = this._objectsArr, c = b.length, d = 0; d < c && a.length; d++)
		for (var e = this.getCoveredTiles(b[d]), f = e.length, k = 0; k < f; k++) {
			var m = e[k],
				m = a.indexOf(this.tileToIndex(m.x, m.y)); - 1 < m && a.splice(m, 1)
		}
		return a
	},
	_sortByY: function(a, b) {
		if (a.y > b.y) return -1;
		if (a.y < b.y) return 1
	}
});
flax.TileMap.create = function(a) {
	return new flax.TileMap(a)
};
_p = flax.TileMap.prototype;
cc.defineGetterSetter(_p, "tileSize", _p.getTileSize);
cc.defineGetterSetter(_p, "mapSize", _p.getMapSize);
flax._tileMaps = {};
flax.getTileMap = function(a) {
	if ("undefined" !== typeof flax._tileMaps[a]) return flax._tileMaps[a];
	cc.log("The tileMap: " + a + " hasn't been defined, pls use flax.registerTileMap to define it firstly!");
	return null
};
flax.registerTileMap = function(a) {
	flax._tileMaps[a.id] = a
};
flax.userData = {};
flax.fetchUserData = function(a) {
	a && (flax.userData = a);
	a = null;
	try {
		(a = cc.sys.localStorage.getItem(cc.game.config.gameId)) && (a = JSON.parse(a))
	} catch (b) {
		cc.log("Fetch UserData Error: " + b.name)
	}
	a && flax.copyProperties(a, flax.userData);
	flax.userData || (flax.userData = {})
};
flax.saveUserData = function() {
	flax.userData || (flax.userData = {});
	try {
		cc.sys.localStorage.setItem(cc.game.config.gameId, JSON.stringify(flax.userData))
	} catch (a) {
		cc.log("Save UserData Error: " + a.name)
	}
};
flax.ObjectPool = cc.Class.extend({
	maxCount: 100,
	_clsName: null,
	_cls: null,
	_assetsFile: null,
	_pool: null,
	_extraID: "",
	init: function(a, b, c) {
		if (this._assetsFile && this._cls) return cc.log("The pool has been inited with cls: " + this._cls), !1;
		this._clsName = b;
		this._cls = flax.nameToObject(b);
		if (null == this._cls) return cc.log("There is no class named: " + b), !1;
		this._assetsFile = a;
		this._pool = [];
		void 0 !== c && (this.maxCount = c);
		return !0
	},
	fetch: function(a, b, c) {
		if (null == a) return cc.log("Please give me a assetID to fetch a object!"), null;
		var d = null;
		0 < this._pool.length ? (d = this._pool.shift(), d.__fromPool = !0, d.setSource(this._assetsFile, a)) : d = this._cls.create ? this._cls.create(this._assetsFile, a) : new this._cls(this._assetsFile, a);
		d.__pool__id__ = this._extraID;
		d.clsName = this._clsName;
		d._destroyed = !1;
		d.autoRecycle = !0;
		d.visible = !0;
		c ? "undefined" === typeof c.zIndex && (c.zIndex = 0) : c = {
			zIndex: 0
		};
		d.attr(c);
		b && b.addChild(d);
		return d
	},
	recycle: function(a) {
		a instanceof this._cls ? this._pool.length < this.maxCount && (a.onRecycle && a.onRecycle(), a.retain && a.retain(), this._pool.push(a)) : cc.log("The object to recycle is not the same type with this pool: " + this._clsName)
	},
	release: function() {
		for (var a = this._pool.length; a--;) this._pool[a].release && this._pool[a].release();
		this._pool.length = 0
	}
});
flax.ObjectPool.all = {};
flax.ObjectPool.create = function(a, b, c) {
	var d = new flax.ObjectPool;
	return d.init(a, b, c) ? d : null
};
flax.ObjectPool.get = function(a, b, c) {
	null == b && (b = "flax.Animator");
	null == c && (c = "");
	var d = a + b + c,
		e = flax.ObjectPool.all[d];
	null == e && (e = flax.ObjectPool.create(a, b), e._extraID = c, flax.ObjectPool.all[d] = e);
	return e
};
flax.ObjectPool.release = function() {
	for (var a in flax.ObjectPool.all) flax.ObjectPool.all[a].release(), delete flax.ObjectPool.all[a]
};
flax.HealthModule = {
	maxHealth: 100,
	health: 100,
	hurtable: !0,
	dead: !1,
	ownerBody: null,
	onEnter: function() {
		this.health = this.maxHealth;
		this.dead = !1
	},
	onExit: function() {},
	onHit: function(a) {
		if (!this.hurtable) return !1;
		if (this.dead) return !0;
		this.health -= a.damage;
		return 0 >= this.health ? (this.dead = !0, this.health = 0, this.onDie(), !0) : !1
	},
	onDie: function() {
		this.ownerBody ? this.ownerBody.destroy() : this.destroy()
	}
};
flax.EnemyWaveModule = {
	waveAssetJson: null,
	waves: null,
	onWaveBegin: null,
	onEnemyIn: null,
	onWaveOver: null,
	batchCanvas: null,
	currentWave: -1,
	totalWaves: 0,
	wavePaused: !0,
	waveOver: !1,
	_waveDefine: null,
	_enemyCount: 0,
	_firstRun: !0,
	onEnter: function() {
		this.totalWaves = this.waves.length;
		this.onWaveBegin = new signals.Signal;
		this.onEnemyIn = new signals.Signal;
		this.onWaveOver = new signals.Signal;
		this.wavePaused || this.nextWave()
	},
	onExit: function() {
		this.onWaveBegin.removeAll();
		this.onEnemyIn.removeAll();
		this.onWaveOver.removeAll()
	},
	startWave: function() {
		this.wavePaused && (this.wavePaused = !1, this._firstRun ? this.nextWave() : this._createWaveEnemy(), this._firstRun = !1)
	},
	stopWave: function() {
		this.wavePaused || (this.wavePaused = !0)
	},
	nextWave: function() {
		!this.waveOver && !this.wavePaused && (this._enemyCount = 0, this.currentWave++, this._waveDefine = this.waves[this.currentWave], this._createWaveEnemy(), this.onWaveBegin.dispatch())
	},
	_createWaveEnemy: function() {
		if (!this.waveOver && !this.wavePaused) {
			var a = flax.getRandomInArray(this._waveDefine.types),
				a = this._doCreateEnemy(a);
			this.onEnemyIn.dispatch(a);
			++this._enemyCount < this._waveDefine.count ? (a = flax.randInt(parseInt(this._waveDefine.interval[0]), parseInt(this._waveDefine.interval[1])), this.scheduleOnce(function() {
				this._createWaveEnemy()
			}, a)) : this.currentWave == this.totalWaves - 1 ? (this.waveOver = !0, this.onWaveOver.dispatch()) : this.nextWave()
		}
	},
	_doCreateEnemy: function(a) {
		this.waveAssetJson && flax.assetsManager.createDisplay(this.waveAssetJson, a, {
			parent: this.batchCanvas,
			x: this.x,
			y: this.y
		}, !0)
	}
};
flax._soundButton = {
	onEnter: function() {
		this._super();
		this.setState(flax.getSoundEnabled() ? ButtonState.UP : ButtonState.SELECTED)
	},
	_onClick: function(a, b) {
		this._super(a, b);
		flax.setSoundEnabled(!this.isSelected())
	}
};
flax.SimpleSoundButton = flax.SimpleButton.extend(flax._soundButton);
flax.SoundButton = flax.Button.extend(flax._soundButton);
flax.GunParam = cc.Class.extend({
	bulletAssets: null,
	bulletID: null,
	targetMap: null,
	selfMap: null,
	damage: 1,
	damageRadius: 0,
	speed: 600,
	interval: 0.15,
	count: 1,
	angleGap: 5,
	angleOffset: 0,
	waveInterval: 0,
	countInWave: 6,
	gravityX: 0,
	gravityY: 0,
	fireSound: null,
	fireEffectID: null,
	hitEffectID: null,
	alwaysLive: !1,
	bulletPlayOnce: !1,
	fps: 0,
	isMissle: !1
});
flax.GunParam.create = function(a) {
	var b = new flax.GunParam;
	0 == a.speed && (a.speed = 0.0010);
	flax.copyProperties(a, b);
	return b
};
flax.Gun = cc.Node.extend({
	owner: null,
	param: null,
	aimTarget: null,
	_firing: !1,
	_targetMap: null,
	_canvas: null,
	start: function() {
		this._firing || (this._firing = !0, this._canvas = flax.BulletCanvas.fetch(this.param.bulletAssets), 0 >= this.param.waveInterval || 1 > this.param.countInWave ? (this.schedule(this.shootOnce, this.param.interval), this.shootOnce()) : this._waveFire())
	},
	end: function() {
		this._firing && (this._firing = !1, this.unschedule(this.shootOnce), this.unschedule(this._createWave))
	},
	updateParam: function(a) {
		null != a && (flax.copyProperties(a, this.param), this.end(), this.start())
	},
	isFiring: function() {
		return this._firing
	},
	_waveFire: function() {
		this._firing && (this._createWave(), this.schedule(this._createWave, this.param.interval * this.param.countInWave + this.param.waveInterval, cc.REPEAT_FOREVER))
	},
	shootOnce: function() {
		if (null != this.parent) {
			var a = this.parent.convertToWorldSpace(this.getPosition());
			if (this.aimTarget && this.aimTarget.parent && this.aimTarget.visible) {
				var b = flax.getAngle(flax.getPosition(this, !0), this.aimTarget.center);
				this.owner.onAimingTarget(b);
				this.rotation = b - this.param.angleOffset - this.parent.rotation
			}
			for (var a = this._canvas.convertToNodeSpace(a), b = flax.getRotation(this, !0), c = -1, d = 0, e = 0, f = flax.createDInts(this.param.count); ++c < this.param.count;) e = f[c], d = b + e * this.param.angleGap, this._canvas.addBullet(d, a, this.param, this.owner);
			this._showFireEffect(a, d);
			this.param.fireSound && flax.playSound(this.param.fireSound)
		}
	},
	_createWave: function() {
		1 < this.param.countInWave ? this.schedule(this.shootOnce, this.param.interval, this.param.countInWave - 1) : this.shootOnce()
	},
	_showFireEffect: function(a, b) {
		if (!(null == this.param.fireEffectID || "" == this.param.fireEffectID)) {
			var c = flax.assetsManager.createDisplay(this.param.bulletAssets, this.param.fireEffectID, {
				parent: this._canvas
			}, !0);
			c.zIndex = 999;
			c.autoDestroyWhenOver = !0;
			c.setPosition(a);
			c.setRotation(b);
			c.gotoAndPlay(0)
		}
	}
});
flax.BulletCanvas = cc.SpriteBatchNode.extend({
	assetsFile: null,
	onBulletHit: null,
	onBulletOut: null,
	_bullets: null,
	onEnter: function() {
		this._super();
		this._bullets = [];
		this.onBulletHit = new signals.Signal;
		this.onBulletOut = new signals.Signal;
		this.scheduleUpdate()
	},
	onExit: function() {
		this._super();
		this.onBulletHit.removeAll();
		this.onBulletOut.removeAll()
	},
	addBullet: function(a, b, c, d) {
		if (null == this.parent) cc.log("Please create a bullet canvas: flax.BulletCanvas.create('" + this.assetsFile + "', container, zIndex);");
		else {
			c instanceof flax.GunParam || (c = flax.GunParam.create(c));
			var e = flax.assetsManager.createDisplay(c.bulletAssets, c.bulletID, {
				parent: this
			}, !0);
			e.owner = d;
			e.param = c;
			d && d.targets && (e.targets = d.targets);
			c.targetMap && (e.targetMap = flax.getTileMap(c.targetMap));
			c.fps && (e.fps = c.fps);
			e.__physicalShooted = !1;
			if (e instanceof flax.MovieClip) {
				e.__isMovieClip = !0;
				e.autoPlayChildren = !0;
				e.autoDestroyWhenOver = !0;
				d = e.children.length;
				for (var f; d--;) f = e.children[d], c.selfMap && f.setTileMap(c.selfMap), f.__isBullet = !0, f.__canvas = this, f.__body = e
			} else c.selfMap && (e.setTileMap(c.selfMap), e.__isBullet = !0, e.__canvas = this, e.__body = e);
			e.play();
			e.autoStopWhenOver = c.bulletPlayOnce;
			e.setPosition(b);
			e.setRotation(a);
			b = c.damage;
			b instanceof Array && (1 == b.length ? b = b[0] : 2 <= b.length && (b = flax.randInt(b[0], b[1])));
			e.damage = b;
			a = DEGREE_TO_RADIAN * (90 - (a + c.angleOffset));
			e.__vx = c.speed * Math.cos(a);
			e.__vy = c.speed * Math.sin(a);
			this._bullets.push(e);
			return e
		}
	},
	destroyBullet: function(a, b, c) {
		void 0 === b && (b = this._bullets.indexOf(a));
		0 > b || (!1 !== c && a.destroy(), this._bullets.splice(b, 1))
	},
	update: function(a) {
		var b = this._bullets.length;
		if (0 != b) for (var c = null, d = null, d = null, e = !1, e = null; b--;) {
			c = this._bullets[b];
			c.physicsBody ? c.__physicalShooted || (c.physicsBody.SetLinearVelocity({
				x: c.__vx / PTM_RATIO,
				y: c.__vy / PTM_RATIO
			}), c.__physicalShooted = !0) : (c.__vx += c.param.gravityX * a, c.__vy += c.param.gravityY * a, c.x += c.__vx * a, c.y += c.__vy * a, c.rotation = flax.getAngle1(c.__vx, c.__vy, !0) - c.param.angleOffset);
			var d = flax.getRect(c, !0),
				e = !1,
				f = !cc.rectIntersectsRect(flax.stageRect, d);
			if (!f && (d = this._checkHittedTarget(c, d, !1)) && d.length) e = flax.getPosition(c, !0), d = c.param.damageRadius, 0 < d && (d = cc.rect(e.x - d / 2, e.y - d / 2, d, d), this._checkHittedTarget(c, d, !0)), e = !0;
			f ? (this.onBulletOut.dispatch(c), this.destroyBullet(c, b)) : e && (this.onBulletHit.dispatch(c), c.param.alwaysLive || this.destroyBullet(c, b))
		}
	},
	_checkHittedTarget: function(a, b, c) {
		var d = [],
			e = null;
		a.targets ? e = a.targets : a.targetMap && (e = a.targetMap.getCoveredTiles1(b, !0));
		if (!e || !e.length) return d;
		b = flax.getRotation(a, !0);
		for (var f = -1; ++f < e.length;)
		if ((target = e[f]) && (target.parent && target.visible) && (!a.owner || !(target == a.owner || flax.isChildOf(a.owner, target) || !0 === target.dead || null != a.owner.camp && target.camp == a.owner.camp))) if (a.__isMovieClip) for (var k = a.children, m = k.length; m--;) {
			var n = k[m];
			b = flax.getRotation(n, !0);
			if (n.mainCollider.checkCollision(target.mainCollider)) {
				flax.callModuleFunction(target, "onHit", a);
				!1 !== target.hurtable && this._showHitEffect(a, b, a.convertToWorldSpace(n.getPosition()));
				target.__isBullet && (n = target.__canvas._bullets.indexOf(target), -1 < n && target.__canvas._bullets.splice(n, 1), target.__body.destroy());
				if (!c) return [target];
				d.push(target)
			}
		} else if (a.mainCollider.checkCollision(target.mainCollider)) {
			flax.callModuleFunction(target, "onHit", a);
			!1 !== target.hurtable && this._showHitEffect(a, b, a.getPosition());
			target.__isBullet && (n = target.__canvas._bullets.indexOf(target), -1 < n && target.__canvas._bullets.splice(n, 1), target.__body.destroy());
			if (!c) return [target];
			d.push(target)
		}
		return d
	},
	_showHitEffect: function(a, b, c) {
		if (!(null == a.param.hitEffectID || "" == a.param.hitEffectID)) {
			var d = flax.assetsManager.createDisplay(a.param.bulletAssets, a.param.hitEffectID, {
				parent: this
			}, !0);
			d.zIndex = 999;
			d.autoDestroyWhenOver = !0;
			d.setPosition(c || a.getPosition());
			d.setRotation(b);
			d.gotoAndPlay(0)
		}
	}
});
flax.BulletCanvas.create = function(a, b, c) {
	a = flax.BulletCanvas.fetch(a);
	a.parent != b && (a.removeFromParent(), b.addChild(a, c || 999))
};
flax.BulletCanvas.fetch = function(a) {
	if (flax._bulletCanvases[a]) return flax._bulletCanvases[a];
	var b = cc.path.changeBasename(a, ".png"),
		b = new flax.BulletCanvas(b, 100);
	b.assetsFile = a;
	return flax._bulletCanvases[a] = b
};
flax._bulletCanvases = {};
flax.BulletCanvas.release = function() {
	flax._bulletCanvases = {}
};
flax.Gun.create = function(a) {
	if (null == a) return cc.log("Please give me a param defiled like: flax.GunParam!"), null;
	a = flax.GunParam.create(a);
	var b = new flax.Gun;
	b.param = a;
	b.init();
	return b
};
flax._gunnerDefine = {
	camp: null,
	_gunParam: null,
	targets: null,
	alwaysBind: !0,
	_guns: null,
	_autoShooting: !1,
	_waitingShoot: !1,
	_auto: !1,
	onEnter: function() {
		this._super();
		this._guns = [];
		this._gunParam && this.setGunParam(this._gunParam)
	},
	onRecycle: function() {
		this._super();
		this._guns = this.targets = this._gunParam = this.camp = null;
		this._autoShooting = this._waitingShoot = this._auto = !1;
		this.stopShoot()
	},
	getGunParam: function() {
		return this._gunParam
	},
	setGunParam: function(a, b) {
		this._gunParam = a;
		if (null != this.parent) if (b || (b = a.gunAnchors), null == b) cc.log("Please set the gunAnchors param!");
		else {
			for (var c = -1, d = b.length, e = null, f = null; ++c < d;) e = b[c], f = flax.Gun.create(this._gunParam), this.bindAnchor(e, f, this.alwaysBind) && (f.owner = this, f.name = e, this[e] = f, this._guns.push(f));
			this._waitingShoot && this.scheduleOnce(this.autoShoot, 0.1)
		}
	},
	shoot: function() {
		this._auto = !1;
		this._doBeginShoot()
	},
	autoShoot: function(a) {
		this._auto = !0;
		null == this.parent || null == this._guns || 0 == this._guns.length ? this._waitingShoot = !0 : (0 < a ? this.scheduleOnce(this._doBeginShoot, a) : this._doBeginShoot(), this._autoShooting = !0, this._waitingShoot = !1)
	},
	aimToTarget: function(a) {
		if (a && a.parent && a.visible) {
			null == this.targets ? this.targets = [a] : -1 == this.targets.indexOf(a) && this.targets.push(a);
			for (var b = -1, c = this._guns.length, d = null; ++b < c;) d = this._guns[b], d.aimTarget = a
		}
	},
	onAimingTarget: function(a) {},
	_doBeginShoot: function() {
		for (var a = -1, b = this._guns.length; ++a < b;) this._auto ? this._guns[a].start() : this._guns[a].shootOnce()
	},
	stopShoot: function() {
		this._autoShooting = !1;
		if (!(null == this._guns || 0 == this._guns.length)) for (var a = -1, b = this._guns.length; ++a < b;) this._guns[a].end()
	},
	upgradeGun: function(a, b) {
		var c = this._deltaGunParam(a);
		!isNaN(b) && 0 < b ? this.scheduleOnce(function() {
			this._deltaGunParam(c)
		}, b) : this._deltaGunParam(c)
	},
	_deltaGunParam: function(a) {
		if (0 != this._guns.length) {
			var b = {},
				c = 0,
				d;
			for (d in a) c = this._guns[0].param[d] + a[d], 0 >= c ? delete a[d] : (b[d] = -a[d], a[d] = c);
			c = this._guns.length;
			for (d = null; c--;) d = this._guns[c], d.updateParam(a);
			return b
		}
	},
	onDie: function() {
		this.stopShoot();
		flax.callModuleFunction(this, "onDie");
		this.ownerBody ? this.ownerBody.destroy() : this.destroy()
	}
};
flax.Gunner = flax.Animator.extend(flax._gunnerDefine);
window.flax.Gunner = flax.Gunner;
flax.MCGunner = flax.MovieClip.extend(flax._gunnerDefine);
window.flax.MCGunner = flax.MCGunner;
flax.addModule(flax.Gunner, flax.HealthModule, !1);
flax.addModule(flax.MCGunner, flax.HealthModule, !1);
_p = flax.Gunner.prototype;
cc.defineGetterSetter(_p, "gunParam", _p.getGunParam, _p.setGunParam);
_p = flax.MCGunner.prototype;
cc.defineGetterSetter(_p, "gunParam", _p.getGunParam, _p.setGunParam);
flax.Gunner.create = function(a, b) {
	var c = new flax.Gunner(a, b);
	c.clsName = "flax.Gunner";
	return c
};
flax.MCGunner.create = function(a, b) {
	var c = new flax.MCGunner(a, b);
	c.clsName = "flax.MCGunner";
	return c
};
flax.ScrollingBG = cc.Node.extend({
	name: null,
	onScrolledOver: null,
	_loop: !0,
	_bg0: null,
	_bg1: null,
	_sources: null,
	_scrollingIndex: 0,
	_scrolling: !1,
	_paused: !1,
	_speedX: 0,
	_speedY: 0,
	_d: 1,
	_size: null,
	_x0: 0,
	_y0: 0,
	ctor: function(a, b, c) {
		this._super();
		this._sources = [];
		this.onScrolledOver = new signals.Signal;
		a && this.addSource(a, b, c)
	},
	onExit: function() {
		this._super();
		this.onScrolledOver.removeAll()
	},
	addSource: function(a, b, c) {
		this._sources.push({
			source: a,
			assetID: b,
			isTile: c
		});
		null == this._bg0 && (this._bg0 = this._createNextBG())
	},
	_createNextBG: function() {
		this._scrollingIndex > this._sources.length - 1 && (this._scrollingIndex = 0);
		var a = this._sources[this._scrollingIndex];
		this._scrollingIndex++;
		var b = null;
		if (null != a.assetID) b = !0 !== a.isTile ? flax.assetsManager.createDisplay(a.source, a.assetID, null, !0) : new flax.TiledImage(a.source, a.assetID);
		else if (a.source) if (flax.isFlaxDisplay(a.source)) a.source.parent && a.source.parent.addChild(this, a.source.zIndex), this.name = a.source.name, this.parent && (this.parent[this.name] = this), this.setPosition(a.source.getPosition()), b = flax.assetsManager.cloneDisplay(a.source), a.source.removeFromParent();
		else if (flax.isImageFile(a.source)) b = new cc.Sprite(a.source);
		else throw "Not supported source type!";
		else throw "Arguments is not valid!";
		b.setAnchorPoint(0, 0);
		this.addChild(b);
		null == this._size && (this._size = b.getContentSize(), this.setContentSize(this._size));
		return b
	},
	reset: function() {
		this._paused = !1;
		this._scrolling && (this._scrolling = !1, this._speedX = this._speedY = 0, this._bg0.destroy ? this._bg0.destroy() : this._bg0.removeFromParent(), this._bg0 = null, this._bg1.destroy ? this._bg1.destroy() : this._bg1.removeFromParent(), this._bg1 = null, this._scrollingIndex = 0, null == this._bg0 && (this._bg0 = this._createNextBG()), this._bg0.setPosition(this._x0, this._y0), this.unscheduleUpdate())
	},
	startXScroll: function(a, b) {
		if (!(0 == a || null == this._bg0) && !this._scrolling) this._scrolling = !0, this._loop = !1 !== b, this._speedX = a, this._speedY = 0, this._d = 0 < this._speedX ? 1 : -1, this._resetScroll(), this.scheduleUpdate()
	},
	startYScroll: function(a, b) {
		if (!(0 == a || null == this._bg0) && !this._scrolling) this._scrolling = !0, this._loop = !1 !== b, this._speedY = a, this._speedX = 0, this._d = 0 < this._speedY ? 1 : -1, this._resetScroll(), this.scheduleUpdate()
	},
	pauseScroll: function() {
		this._scrolling && !this._paused && (this._paused = !0, this.unscheduleUpdate())
	},
	resumeScroll: function() {
		this._scrolling && this._paused && (this._paused = !1, this.scheduleUpdate())
	},
	_resetScroll: function() {
		this._bg0.setPosition(this._x0, this._y0);
		null == this._bg1 && (this._bg1 = this._createNextBG());
		0 != this._speedX ? this._bg1.x = -this._d * (this._size.width - 1) : this._bg1.y = -this._d * (this._size.height - 1)
	},
	update: function(a) {
		if (0 == this._size.width * this._size.height) this._size = this._bg0.getContentSize(), 0 != this._size.width * this._size.height && (this.setContentSize(this._size), this._resetScroll());
		else {
			var b = !1;
			0 != this._speedX ? (a *= this._speedX, this._bg0.x += a, this._bg1.x += a, a = this._size.width - this._bg0.x * this._d, 0 >= a && (this._bg0.x += this._d * a, this._bg1.x += this._d * a, b = !0)) : 0 != this._speedY && (a *= this._speedY, this._bg0.y += a, this._bg1.y += a, a = this._size.height - this._bg0.y * this._d, 0 >= a && (this._bg0.y += this._d * a, this._bg1.y += this._d * a, b = !0));
			b && (!this._loop && this._scrollingIndex > this._sources.length - 1 ? (this.onScrolledOver.dispatch(), this.pauseScroll()) : (this._bg0.destroy ? this._bg0.destroy() : this._bg0.removeFromParent(), this._bg0 = this._bg1, this._bg1 = this._createNextBG(), this._resetScroll()))
		}
	},
	getRect: function() {
		0 == this._size.width * this._size.height && (this._size = this._bg0.getContentSize(), 0 != this._size.width * this._size.height && this.setContentSize(this._size));
		return cc.rect(0, 0, this._size.width, this._size.height)
	}
});
flax.ScrollingBG.create = function(a, b, c) {
	return new flax.ScrollingBG(a, b, c)
};
flax._scrollPaneDefine = {
	_viewRect: null,
	onEnter: function() {
		this._super();
		(this._viewRect = this.getCollider("view").getRect(!0)) ? flax.inputManager.addListener(null, this._startDrag, InputType.press, this) : cc.log("If you want me scrollable, please set collider__view for me!")
	},
	scrollToCenter: function(a, b) {
		var c = cc.visibleRect.center,
			c = this.parent.convertToNodeSpace(c),
			d = this.convertToWorldSpace(a.getPosition ? a.getPosition() : a),
			d = this.parent.convertToNodeSpace(d),
			c = cc.pSub(c, d),
			c = this._validatePos(this.x + c.x, this.y + c.y);
		0 < b ? this.runAction(cc.MoveTo.create(b, c)) : this.setPosition(c)
	},
	_startDrag: function(a, b) {
		this.scheduleOnce(function() {
			flax.inputManager.addListener(null, this._drag, InputType.move, this);
			flax.inputManager.addListener(null, this._stopDrag, InputType.up, this)
		}, 0.01)
	},
	_drag: function(a, b) {
		var c = a.getDelta();
		this._viewRect.width >= this.width && (c.x = 0);
		this._viewRect.height >= this.height && (c.y = 0);
		c = this._validatePos(this.x + c.x, this.y + c.y);
		this.x = c.x;
		this.y = c.y
	},
	_stopDrag: function(a, b) {
		flax.inputManager.removeListener(null, this._drag, InputType.move);
		flax.inputManager.removeListener(null, this._stopDrag, InputType.up)
	},
	_validatePos: function(a, b) {
		a = Math.max(this._viewRect.x + this._viewRect.width - this.width, a);
		a = Math.min(this._viewRect.x, a);
		b = Math.max(this._viewRect.y + this._viewRect.height - this.height, b);
		b = Math.min(this._viewRect.y, b);
		return cc.p(a, b)
	}
};
flax.ScrollPane = flax.Animator.extend(flax._scrollPaneDefine);
flax.ScrollPane.create = function(a, b) {
	return new flax.ScrollPane(a, b)
};
window.flax.ScrollPane = flax.ScrollPane;
flax.MCScrollPane = flax.MovieClip.extend(flax._scrollPaneDefine);
flax.MCScrollPane.create = function(a, b) {
	return new flax.MCScrollPane(a, b)
};
window.flax.MCScrollPane = flax.MCScrollPane;
flax.TiledImage = cc.SpriteBatchNode.extend({
	tileMap: null,
	tileWidthOffset: 0,
	tileHeightOffset: 0,
	assetsFile: null,
	assetID: null,
	_mapWidth: 0,
	_mapHeight: 0,
	ctor: function(a, b, c, d) {
		var e = cc.path.changeBasename(a, ".png");
		cc.SpriteBatchNode.prototype.ctor.call(this, e);
		this.tileMap = new flax.TileMap;
		this.setTileSource(a, b);
		c || (c = cc.visibleRect.width);
		d || (d = cc.visibleRect.height);
		this.setSize(c, d)
	},
	setTileSource: function(a, b) {
		if (!(this.assetsFile == a && this.assetID == b)) {
			this.assetsFile = a;
			this.assetID = b;
			var c = flax.assetsManager.createDisplay(this.assetsFile, this.assetID).getContentSize();
			this.tileMap.init(c.width + this.tileWidthOffset, c.height + this.tileHeightOffset);
			0 < this._mapWidth * this._mapHeight && (0 < this.getChildrenCount() && this._updateTileImg(), this._updateSize())
		}
	},
	setSize: function(a, b) {
		a == this._mapWidth && b == this._mapHeight || (this._mapWidth = a, this._mapHeight = b, this.assetsFile && this._updateSize())
	},
	_updateTileImg: function() {
		for (var a = null, b = this.getChildrenCount(), c = -1; ++c < b;) a = this.children[c], a.setSource(this.assetsFile, this.assetID), this.tileMap.snapToTile(a, a.tx, a.ty)
	},
	_updateSize: function() {
		var a = this.tileMap.setMapSize(this._mapWidth, this._mapHeight, !0),
			b, c = a[0].length;
		if (0 < c) {
			var d;
			for (b = -1; ++b < c;) d = a[0][b], d.destroy ? d.destroy() : d.removeFromParent()
		}
		c = a[1].length;
		if (0 < c) for (b = -1; ++b < c;) this._createTile(a[1][b][0], a[1][b][1]);
		this.setContentSize(this.tileMap.getMapSizePixel())
	},
	_createTile: function(a, b) {
		var c = flax.assetsManager.createDisplay(this.assetsFile, this.assetID, {
			parent: this
		}, !0);
		c.setAnchorPoint(0.5, 0.5);
		this.tileMap.snapToTile(c, a, b, !0);
		return c
	}
});
EIGHT_DIRECT_VALUE = [
	[0, 1],
	[0, -1],
	[-1, 0],
	[1, 0],
	[-1, 1],
	[1, 1],
	[1, -1],
	[-1, -1]
];
var LinkFinder = {};
window.LinkFinder = LinkFinder;
LinkFinder.map = null;
LinkFinder.blocks = null;
LinkFinder.findLink = function(a, b, c, d) {
	var e = null,
		e = a == c || b == d ? LinkFinder._checkDirectLink(a, b, c, d) : LinkFinder._checkOneLink(a, b, c, d);
	null == e && (e = LinkFinder._checkTwoLink(a, b, c, d));
	return e
};
LinkFinder.shuffle = function(a) {
	var b = this.map.getAllObjects(),
		c = b.concat(),
		d = -1;
	if (this.blocks && this.blocks.length) for (c = []; ++d < b.length;) {
		var e = b[d]; - 1 == this.blocks.indexOf(e) && c.push(e)
	}
	flax.shuffleArray(c);
	d = -1;
	for (b = c.length / 2; ++d < b;) {
		var e = c[d],
			f = c[d + b],
			k = e.getPosition();
		!1 !== a ? (e.runAction(cc.MoveTo.create(0.2, f.getPosition())), f.runAction(cc.MoveTo.create(0.2, k))) : (e.setPosition(f.getPosition()), f.setPosition(k))
	}
};
LinkFinder.findAvailableLink = function(a) {
	var b = this.map.getAllObjects(),
		c = b.length;
	if (0 == c) return null;
	for (var d, e, f = null, k = [], m = null, n = 0; n < c - 1; n++)
	if (d = b[n], !(this.blocks && -1 < this.blocks.indexOf(d))) {
		var p = 0 == k.length;
		null == m && (m = d);
		for (var r = n + 1; r < c; r++)
		if (e = b[r], !(this.blocks && -1 < this.blocks.indexOf(e))) if (e.assetID == d.assetID) {
			if (LinkFinder.findLink(d.tx, d.ty, e.tx, e.ty)) return [d, e];
			p && k.push(e)
		} else p && (null == f && LinkFinder.findLink(d.tx, d.ty, e.tx, e.ty)) && (f = e)
	}
	if (0 == k.length) return null;
	b = k[Math.floor(k.length * Math.random())];
	c = cc.p(b.getPosition());
	if (null == f) {
		f = this._findEmptyNeighbor(m.tx, m.ty);
		if (null == f) throw "Dead map!!!!";
		c = this.map.getTiledPosition(f.x, f.y);
		b.parent && (c = b.parent.convertToNodeSpace(c));
		!0 === a ? b.runAction(cc.MoveTo.create(0.2, c)) : b.setPosition(c)
	} else!0 === a ? (b.runAction(cc.MoveTo.create(0.2, f.getPosition())), f.runAction(cc.MoveTo.create(0.2, c))) : (b.setPosition(f.getPosition()), f.setPosition(c));
	return [m, b]
};
LinkFinder._findEmptyNeighbor = function(a, b) {
	for (var c = null, d = 0; 4 > d && !(c = EIGHT_DIRECT_VALUE[d], c = cc.p(a + c[0], b + c[1]), this.map.isEmptyTile(c.x, c.y)); d++);
	return c
};
LinkFinder._checkDirectLink = function(a, b, c, d) {
	if (a == c && b == d) return null;
	if (a == c) {
		for (var e = !0, f = 0 < d - b ? 1 : -1, k = b + f; k != d;) {
			if (!this.map.isEmptyTile(a, k)) {
				e = !1;
				break
			}
			k += f
		}
		if (e) return [new cc.p(a, b), new cc.p(c, d)]
	}
	if (b == d) {
		e = !0;
		f = 0 < c - a ? 1 : -1;
		for (k = a + f; k != c;) {
			if (!this.map.isEmptyTile(k, b)) {
				e = !1;
				break
			}
			k += f
		}
		if (e) return [new cc.p(a, b), new cc.p(c, d)]
	}
	return null
};
LinkFinder._checkOneLink = function(a, b, c, d) {
	if (a == c || b == d) return null;
	if (this.map.isEmptyTile(a, d)) {
		var e = LinkFinder._checkDirectLink(a, b, a, d);
		if (e && (e = LinkFinder._checkDirectLink(a, d, c, d))) return [new cc.p(a, b), new cc.p(a, d), new cc.p(c, d)]
	}
	if (this.map.isEmptyTile(c, b) && (e = LinkFinder._checkDirectLink(a, b, c, b))) if (e = LinkFinder._checkDirectLink(c, b, c, d)) return [new cc.p(a, b), new cc.p(c, b), new cc.p(c, d)];
	return null
};
LinkFinder._checkTwoLink = function(a, b, c, d) {
	if (a == c && b == d) return null;
	var e = 0 <= c - a ? 1 : -1,
		f = 0 <= d - b ? 1 : -1,
		k = LinkFinder._twoLinkSearch(a, b, c, d, e, f);
	null == k && (k = LinkFinder._twoLinkSearch(a, b, c, d, -e, -f));
	null != k && k.unshift(new cc.p(a, b));
	return k
};
LinkFinder._twoLinkSearch = function(a, b, c, d, e, f) {
	for (var k = null, m = a + e, n = b + f, p = !1, r = !1; !p || !r;) {
		if (!p && (p = !this.map.isEmptyTile(m, b), !p)) {
			k = LinkFinder._checkOneLink(m, b, c, d);
			if (null != k) break;
			m += e
		}
		if (!r && (r = !this.map.isEmptyTile(a, n), !r)) {
			k = LinkFinder._checkOneLink(a, n, c, d);
			if (null != k) break;
			n += f
		}
	}
	return k
};
var HEX_NUM = "0123456789ABCDEF",
	COLOR_WHITE = cc.color(255, 255, 255),
	COLOR_BLACK = cc.color(0, 0, 0),
	COLOR_RED = cc.color(255, 0, 0),
	COLOR_GREEN = cc.color(0, 255, 0),
	COLOR_BLUE = cc.color(0, 0, 255),
	COLOR_GRAY = cc.color(128, 128, 128);

function hexToRgb(a) {
	var b = "#" == a.charAt(0) ? a.substring(1, 7) : a;
	a = parseInt(b.substring(0, 2), 16);
	var c = parseInt(b.substring(2, 4), 16),
		b = parseInt(b.substring(4, 6), 16);
	return [a, c, b]
}

function randomColor() {
	var a = hsvToRgb(Math.random(), 0.9725, 1);
	return rgbToHex(a[0], a[1], a[2]).toUpperCase()
}

function rgbToHex(a, b, c) {
	return _toHex(a) + _toHex(b) + _toHex(c)
}

function rgbToHsl(a, b, c) {
	a /= 255;
	b /= 255;
	c /= 255;
	var d = Math.max(a, b, c),
		e = Math.min(a, b, c),
		f, k = (d + e) / 2;
	if (d == e) f = e = 0;
	else {
		var m = d - e,
			e = 0.5 < k ? m / (2 - d - e) : m / (d + e);
		switch (d) {
		case a:
			f = (b - c) / m + (b < c ? 6 : 0);
			break;
		case b:
			f = (c - a) / m + 2;
			break;
		case c:
			f = (a - b) / m + 4
		}
		f /= 6
	}
	return [f, e, k]
}

function hslToRgb(a, b, c) {
	if (0 == b) c = b = a = c;
	else {
		var d = function(a, b, c) {
				0 > c && (c += 1);
				1 < c && (c -= 1);
				return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
			},
			e = 0.5 > c ? c * (1 + b) : c + b - c * b,
			f = 2 * c - e;
		c = d(f, e, a + 1 / 3);
		b = d(f, e, a);
		a = d(f, e, a - 1 / 3)
	}
	return [255 * c, 255 * b, 255 * a]
}

function rgbToHsv(a, b, c) {
	a /= 255;
	b /= 255;
	c /= 255;
	var d = Math.max(a, b, c),
		e = Math.min(a, b, c),
		f, k = d - e;
	if (d == e) f = 0;
	else {
		switch (d) {
		case a:
			f = (b - c) / k + (b < c ? 6 : 0);
			break;
		case b:
			f = (c - a) / k + 2;
			break;
		case c:
			f = (a - b) / k + 4
		}
		f /= 6
	}
	return [f, 0 == d ? 0 : k / d, d]
}

function hsvToRgb(a, b, c) {
	var d, e, f, k = Math.floor(6 * a),
		m = 6 * a - k;
	a = c * (1 - b);
	var n = c * (1 - m * b);
	b = c * (1 - (1 - m) * b);
	switch (k % 6) {
	case 0:
		d = c;
		e = b;
		f = a;
		break;
	case 1:
		d = n;
		e = c;
		f = a;
		break;
	case 2:
		d = a;
		e = c;
		f = b;
		break;
	case 3:
		d = a;
		e = n;
		f = c;
		break;
	case 4:
		d = b;
		e = a;
		f = c;
		break;
	case 5:
		d = c, e = a, f = n
	}
	return [255 * d, 255 * e, 255 * f]
}

function darkenHexColor(a, b) {
	var c = hexToRgb(a),
		c = rgbToHsl(c[0], c[1], c[2]);
	c[2] -= b;
	c = hslToRgb(c[0], c[1], c[2]);
	return rgbToHex(c[0], c[1], c[2])
}

function _toHex(a) {
	a = parseInt(a, 10);
	if (isNaN(a)) return "00";
	a = Math.max(0, Math.min(a, 255));
	return HEX_NUM.charAt((a - a % 16) / 16) + HEX_NUM.charAt(a % 16)
};
var g = g || {};
g.language = -1 == window.location.href.indexOf("bookor") ? "en" : "ch";
g.language = "ch";
var res = {
	start: "res/" + g.language + "/start.plist",
	start_png: "res/" + g.language + "/start.png",
	play: "res/" + g.language + "/play.plist",
	play_png: "res/" + g.language + "/play.png",
	over: "res/" + g.language + "/over.plist",
	over_png: "res/" + g.language + "/over.png",
	guide: "res/" + g.language + "/guider.plist",
	guide_png: "res/" + g.language + "/guider.png",
	blacksound: "res/hei.wav",
	whitesound: "res/bai.wav"
},
	res_start = [res.start, res.start_png],
	res_play = [res.play, res.play_png, res.over, res.over_png, res.blacksound, res.whitesound, res.guide, res.guide_png];
var FirstLayer = cc.Layer.extend({
	ctor: function() {
		this._super();
		for (var a = flax.assetsManager.createDisplay(res.start, "startSymbol", {
			parent: this
		}), b = 0; 2 >= b; b++) a["but" + b].id = b, flax.inputManager.addListener(a["but" + b], this.StartGame, null, this)
	},
	StartGame: function(a, b) {
		currentscene = b.target.id;
		flax.replaceScene("gamescene" + currentscene)
	}
}),
	FirstScene = cc.Scene.extend({
		onEnter: function() {
			this._super();
			var a = new FirstLayer;
			this.addChild(a)
		}
	});
var GameScene0 = cc.Scene.extend({
	winsize: null,
	pointX: null,
	pointY: null,
	startX: null,
	startY: null,
	endX: null,
	endY: null,
	spaceX: null,
	spaceY: null,
	pan: null,
	map: null,
	my: null,
	count: null,
	isPlay: null,
	history: null,
	undoNum: null,
	AIfirsthand: null,
	Ai: null,
	onEnter: function() {
		this._super();
		if (firstplay) {
			var a = new GuiderLayer;
			this.addChild(a, 1)
		}
		this.history = [];
		this.initData();
		this.map = [];
		this.map = this.CreateMap();
		this.AIfirsthand = !1;
		this.Ai = new AI
	},
	initData: function() {
		this.winsize = cc.director.getWinSize();
		this.pointY = this.pointX = 0;
		this.spaceY = this.spaceX = 29.5;
		this.startX = 35;
		this.endX = 445;
		this.startY = 215;
		this.endY = 625;
		this.my = 1;
		this.count = 0;
		this.isPlay = !1;
		this.undoNum = 0;
		var a = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			onTouchBegan: function(a, b) {
				if (!1 == b.getCurrentTarget().isPlay) return !1;
				var c = a.getLocation();
				c.x <= b.getCurrentTarget().endX + 15 && (c.x >= b.getCurrentTarget().startX - 15 && c.y <= b.getCurrentTarget().endY + 15 && c.y >= b.getCurrentTarget().startY - 15) && (b.getCurrentTarget().pointX = Math.round((c.x - b.getCurrentTarget().startX) / b.getCurrentTarget().spaceX), b.getCurrentTarget().pointY = Math.round((c.y - b.getCurrentTarget().startY) / b.getCurrentTarget().spaceY), 0 > b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 0), 14 < b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 14), 0 > b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 0), 14 < b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 14), 0 == b.getCurrentTarget().map[b.getCurrentTarget().pointX][b.getCurrentTarget().pointY] && (b.getCurrentTarget().my = 1, c = flax.assetsManager.createDisplay(res.play, "black", {
					parent: b.getCurrentTarget()
				}), c.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), b.getCurrentTarget().ring.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), cc.audioEngine.playEffect(res.blacksound, !1), b.getCurrentTarget().history.push({
					x: b.getCurrentTarget().pointX,
					y: b.getCurrentTarget().pointY,
					sprite: c
				}), b.getCurrentTarget().count++, b.getCurrentTarget().ClickPoint(b.getCurrentTarget().pointX, b.getCurrentTarget().pointY, b.getCurrentTarget().my) && b.getCurrentTarget().AIPlay()))
			}
		}),
			b = flax.assetsManager.createDisplay(res.play, "playSymbol", {
				parent: this
			});
		flax.inputManager.addListener(b.but4, this.OnClick, null, this);
		b.but4.id = 4;
		this.ring = flax.assetsManager.createDisplay(res.play, "ring", {
			parent: this
		});
		var c = flax.assetsManager.createDisplay(res.play, "firstsecond", {
			parent: this
		});
		flax.inputManager.addListener(c.but1, function() {
			var d = new cc.ScaleTo(0.3, 0.01),
				e = new cc.removeSelf;
			c.runAction(cc.sequence(d, e));
			for (d = 1; 3 >= d; d++) b["but" + d].id = d, flax.inputManager.addListener(b["but" + d], this.OnClick, null, this);
			cc.eventManager.addListener(a, this);
			this.FirstHand()
		}, null, this);
		flax.inputManager.addListener(c.but2, function() {
			var d = new cc.ScaleTo(0.3, 0.01),
				e = new cc.removeSelf;
			c.runAction(cc.sequence(d, e));
			for (d = 1; 3 >= d; d++) b["but" + d].id = d, flax.inputManager.addListener(b["but" + d], this.OnClick, null, this);
			cc.eventManager.addListener(a, this);
			this.SecondHand()
		}, null, this)
	},
	FirstHand: function() {
		this.isPlay = !0
	},
	SecondHand: function() {
		this.Ai.setFirstHand();
		this.AIPlay();
		this.Ai.setFirstHandFalse();
		this.isPlay = !1
	},
	OnClick: function(a, b) {
		switch (b.target.id) {
		case 1:
			if (this.isPlay && 2 < this.history.length) {
				var c = this.history.pop(),
					d = this.history.pop();
				this.map[c.x][c.y] = 0;
				this.map[d.x][d.y] = 0;
				this.removeChild(c.sprite);
				this.removeChild(d.sprite);
				c = this.history[this.history.length - 1];
				this.ring.setPosition(c.x * this.spaceX + this.startX, c.y * this.spaceY + this.startY)
			}
			break;
		case 2:
			50 <= this.count ? this.AddOverLayer(5) : this.label || (this.label = "ch" == g.language ? new cc.LabelTTF("开局少于50步，不能和棋!", "Arial", 30) : new cc.LabelTTF("Start step less than 50!", "Arial", 35), this.label.setColor(cc.color(139, 69, 19)), this.label.setOpacity(200), this.label.attr({
				x: this.winsize.width / 2,
				y: this.winsize.height / 1.8,
				anchor: cc.p(0.5, 0.5)
			}), this.addChild(this.label, 10), c = new cc.DelayTime(1), d = new cc.CallFunc(function() {
				this.label.removeFromParent();
				this.label = null
			}, this), this.label.runAction(cc.sequence(c, d)));
			break;
		case 3:
			2 < this.count && this.AddOverLayer(2);
			break;
		case 4:
			flax.replaceScene("startscene")
		}
	},
	CreateMap: function() {
		for (var a = [], b = 0; 15 > b; b++) {
			a[b] = [];
			for (var c = 0; 15 > c; c++) a[b][c] = 0
		}
		return a
	},
	ClickPoint: function(a, b, c) {
		this.map[a][b] = c;
		return this.isWin(a, b, c) ? (this.isPlay = !1, 1 == c ? this.AddOverLayer(1) : this.AddOverLayer(2), !1) : !0
	},
	isWin: function(a, b, c) {
		for (var d = this.map, e = [], f = 0; f < d.length; f++) e.push(d[f][b]);
		if (this.win(e, c)) return !0;
		e = d[a];
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) {
			var k = d[f][b - (a - f)];
			void 0 !== k && e.push(k)
		}
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) k = d[f][b + (a - f)], void 0 !== k && e.push(k);
		if (this.win(e, c)) return !0
	},
	win: function(a, b) {
		for (var c = 0, d = 0; d < a.length; d++)
		if (a[d] == b) {
			if (c++, 5 == c) return !0
		} else c = 0;
		return !1
	},
	AIPlay: function() {
		this.isPlay = !1;
		this.my = -1;
		var a = this.Ai.initData(this.map, this.my);
		this.scheduleOnce(function() {
			var b = flax.assetsManager.createDisplay(res.play, "white", {
				parent: this
			});
			b.setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
			this.ring.setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
			cc.audioEngine.playEffect(res.whitesound, !1);
			this.history.push({
				x: a.x,
				y: a.y,
				sprite: b
			});
			this.count++;
			this.ClickPoint(a.x, a.y, this.my) && (this.isPlay = !0, this.my = 1)
		}, 1)
	},
	AddOverLayer: function(a) {
		a = new OverLayer(a);
		this.addChild(a, 10);
		a.y = 800;
		var b = new cc.MoveBy(1, cc.p(0, -800)),
			b = new cc.EaseBounceOut(b);
		a.runAction(b)
	}
});
var GameScene1 = cc.Scene.extend({
	winsize: null,
	pointX: null,
	pointY: null,
	startX: null,
	startY: null,
	endX: null,
	endY: null,
	spaceX: null,
	spaceY: null,
	pan: null,
	map: null,
	my: null,
	count: null,
	isPlay: null,
	history: null,
	undoNum: null,
	regret: null,
	onEnter: function() {
		this._super();
		if (firstplay) {
			var a = new GuiderLayer;
			this.addChild(a, 1)
		}
		this.history = [];
		this.initData();
		this.map = [];
		this.map = this.CreateMap()
	},
	initData: function() {
		this.winsize = cc.director.getWinSize();
		this.pointY = this.pointX = 0;
		this.spaceY = this.spaceX = 29.5;
		this.startX = 35;
		this.endX = 445;
		this.startY = 215;
		this.endY = 625;
		this.my = 1;
		this.count = 0;
		this.isPlay = !0;
		this.undoNum = 0;
		this.regret = 3;
		var a = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			onTouchBegan: function(a, b) {
				if (0 == b.getCurrentTarget().count % 2) {
					if (!1 == b.getCurrentTarget().isPlay) return !1;
					var e = a.getLocation();
					e.x <= b.getCurrentTarget().endX + 15 && (e.x >= b.getCurrentTarget().startX - 15 && e.y <= b.getCurrentTarget().endY + 15 && e.y >= b.getCurrentTarget().startY - 15) && (b.getCurrentTarget().pointX = Math.round((e.x - b.getCurrentTarget().startX) / b.getCurrentTarget().spaceX), b.getCurrentTarget().pointY = Math.round((e.y - b.getCurrentTarget().startY) / b.getCurrentTarget().spaceY), 0 > b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 0), 14 < b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 14), 0 > b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 0), 14 < b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 14), 0 == b.getCurrentTarget().map[b.getCurrentTarget().pointX][b.getCurrentTarget().pointY] && (b.getCurrentTarget().my = 1, e = flax.assetsManager.createDisplay(res.play, "black", {
						parent: b.getCurrentTarget()
					}), e.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), b.getCurrentTarget().ring.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), cc.audioEngine.playEffect(res.blacksound, !1), b.getCurrentTarget().history.push({
						x: b.getCurrentTarget().pointX,
						y: b.getCurrentTarget().pointY,
						sprite: e
					}), (e = b.getCurrentTarget().ClickPoint(b.getCurrentTarget().pointX, b.getCurrentTarget().pointY, b.getCurrentTarget().my)) && b.getCurrentTarget().count++))
				} else {
					if (!1 == b.getCurrentTarget().isPlay) return !1;
					e = a.getLocation();
					e.x < b.getCurrentTarget().endX && (e.x > b.getCurrentTarget().startX && e.y < b.getCurrentTarget().endY && e.y > b.getCurrentTarget().startY) && (b.getCurrentTarget().pointX = Math.round((e.x - b.getCurrentTarget().startX) / b.getCurrentTarget().spaceX), b.getCurrentTarget().pointY = Math.round((e.y - b.getCurrentTarget().startY) / b.getCurrentTarget().spaceY), cc.log(b.getCurrentTarget().pointX, b.getCurrentTarget().pointY), 0 > b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 0), 14 < b.getCurrentTarget().pointX && (b.getCurrentTarget().pointX = 14), 0 > b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 0), 14 < b.getCurrentTarget().pointY && (b.getCurrentTarget().pointY = 14), 0 == b.getCurrentTarget().map[b.getCurrentTarget().pointX][b.getCurrentTarget().pointY] && (b.getCurrentTarget().my = -1, e = flax.assetsManager.createDisplay(res.play, "white", {
						parent: b.getCurrentTarget()
					}), e.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), b.getCurrentTarget().ring.setPosition(b.getCurrentTarget().pointX * b.getCurrentTarget().spaceX + b.getCurrentTarget().startX, b.getCurrentTarget().pointY * b.getCurrentTarget().spaceY + b.getCurrentTarget().startY), cc.audioEngine.playEffect(res.whitesound, !1), b.getCurrentTarget().history.push({
						x: b.getCurrentTarget().pointX,
						y: b.getCurrentTarget().pointY,
						sprite: e
					}), (e = b.getCurrentTarget().ClickPoint(b.getCurrentTarget().pointX, b.getCurrentTarget().pointY, b.getCurrentTarget().my)) && b.getCurrentTarget().count++))
				}
			}
		});
		cc.eventManager.addListener(a, this);
		a = flax.assetsManager.createDisplay(res.play, "playSymbol", {
			parent: this
		});
		this.ring = flax.assetsManager.createDisplay(res.play, "ring", {
			parent: this
		});
		for (var b = 1; 4 >= b; b++) a["but" + b].id = b, flax.inputManager.addListener(a["but" + b], this.OnClick, null, this)
	},
	OnClick: function(a, b) {
		switch (b.target.id) {
		case 1:
			if (this.isPlay && 2 < this.history.length) {
				var c = this.history.pop(),
					d = this.history.pop();
				this.map[c.x][c.y] = 0;
				this.map[d.x][d.y] = 0;
				this.removeChild(c.sprite);
				this.removeChild(d.sprite);
				c = this.history[this.history.length - 1];
				this.ring.setPosition(c.x * this.spaceX + this.startX, c.y * this.spaceY + this.startY)
			}
			break;
		case 2:
			50 < this.count ? this.AddOverLayer(5) : this.label || (this.label = "ch" == g.language ? new cc.LabelTTF("开局少于50步，不能和棋!", "Arial", 30) : new cc.LabelTTF("Start step less than 50!", "Arial", 35), this.label.setColor(cc.color(139, 69, 19)), this.label.setOpacity(200), this.label.attr({
				x: this.winsize.width / 2,
				y: this.winsize.height / 1.8,
				anchor: cc.p(0.5, 0.5)
			}), this.addChild(this.label, 10), c = new cc.DelayTime(1), d = new cc.CallFunc(function() {
				this.label.removeFromParent();
				this.label = null
			}, this), this.label.runAction(cc.sequence(c, d)));
			break;
		case 3:
			2 < this.count && (0 == this.count % 2 ? this.AddOverLayer(4) : this.AddOverLayer(3));
			break;
		case 4:
			flax.replaceScene("startscene")
		}
	},
	CreateMap: function() {
		for (var a = [], b = 0; 15 > b; b++) {
			a[b] = [];
			for (var c = 0; 15 > c; c++) a[b][c] = 0
		}
		return a
	},
	ClickPoint: function(a, b, c) {
		this.map[a][b] = c;
		return this.isWin(a, b, c) ? (this.isPlay = !1, 1 == c ? this.AddOverLayer(3) : this.AddOverLayer(4), !1) : !0
	},
	isWin: function(a, b, c) {
		for (var d = this.map, e = [], f = 0; f < d.length; f++) e.push(d[f][b]);
		if (this.win(e, c)) return !0;
		e = d[a];
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) {
			var k = d[f][b - (a - f)];
			void 0 !== k && e.push(k)
		}
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) k = d[f][b + (a - f)], void 0 !== k && e.push(k);
		if (this.win(e, c)) return !0
	},
	win: function(a, b) {
		for (var c = 0, d = 0; d < a.length; d++)
		if (a[d] == b) {
			if (c++, 5 == c) return !0
		} else c = 0;
		return !1
	},
	AddOverLayer: function(a) {
		a = new OverLayer(a);
		this.addChild(a, 10);
		a.y = 800;
		var b = new cc.MoveBy(1, cc.p(0, -800)),
			b = new cc.EaseBounceOut(b);
		a.runAction(b)
	}
});
var GameScene2 = cc.Scene.extend({
	winsize: null,
	pointX: null,
	pointY: null,
	startX: null,
	startY: null,
	endX: null,
	endY: null,
	spaceX: null,
	spaceY: null,
	map: null,
	my: null,
	count: null,
	Ai: null,
	Ai1: null,
	onEnter: function() {
		this._super();
		if (firstplay) {
			var a = new GuiderLayer;
			this.addChild(a, 1)
		}
		this.initData();
		this.map = [];
		this.map = this.CreateMap();
		this.Ai = new AI;
		this.Ai1 = new AI
	},
	initData: function() {
		this.winsize = cc.director.getWinSize();
		this.pointY = this.pointX = 0;
		this.spaceY = this.spaceX = 29.5;
		this.startX = 35;
		this.endX = 445;
		this.startY = 215;
		this.endY = 625;
		this.my = 1;
		this.count = 0;
		this.isPlay = !1;
		var a = flax.assetsManager.createDisplay(res.play, "playSymbol", {
			parent: this
		});
		flax.inputManager.addListener(a.but4, this.OnClick, null, this);
		this.ring = flax.assetsManager.createDisplay(res.play, "ring", {
			parent: this
		});
		this.peace = a.but2;
		var a = flax.assetsManager.createDisplay(res.play, "startsee", {
			parent: this,
			x: this.winsize.width / 2,
			y: this.winsize.height / 2
		}),
			b = new cc.FadeOut(2),
			c = new cc.CallFunc(function() {
				this.Ai1.setFirstHand();
				this.AI1Play();
				this.Ai1.setFirstHandFalse()
			}, this);
		a.runAction(cc.sequence(b, c))
	},
	OnClick: function(a, b) {
		flax.replaceScene("startscene")
	},
	CreateMap: function() {
		for (var a = [], b = 0; 15 > b; b++) {
			a[b] = [];
			for (var c = 0; 15 > c; c++) a[b][c] = 0
		}
		return a
	},
	ClickPoint: function(a, b, c) {
		this.map[a][b] = c;
		if (this.isWin(a, b, c)) 1 == c ? this.AddOverLayer(4) : this.AddOverLayer(3);
		else return !0
	},
	isWin: function(a, b, c) {
		for (var d = this.map, e = [], f = 0; f < d.length; f++) e.push(d[f][b]);
		if (this.win(e, c)) return !0;
		e = d[a];
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) {
			var k = d[f][b - (a - f)];
			void 0 !== k && e.push(k)
		}
		if (this.win(e, c)) return !0;
		e = [];
		for (f = 0; f < d.length; f++) k = d[f][b + (a - f)], void 0 !== k && e.push(k);
		if (this.win(e, c)) return !0
	},
	win: function(a, b) {
		for (var c = 0, d = 0; d < a.length; d++)
		if (a[d] == b) {
			if (c++, 5 == c) return !0
		} else c = 0;
		return !1
	},
	AIPlay: function() {
		this.my = 1;
		var a = this.Ai.initData(this.map, this.my);
		flax.assetsManager.createDisplay(res.play, "white", {
			parent: this
		}).setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
		this.ring.setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
		cc.audioEngine.playEffect(res.whitesound, !1);
		this.ClickPoint(a.x, a.y, this.my) && (169 <= ++this.count ? this.AddOverLayer(5) : this.scheduleOnce(function() {
			this.AI1Play()
		}, 1))
	},
	AI1Play: function() {
		this.my = -1;
		var a = this.Ai1.initData(this.map, this.my);
		flax.assetsManager.createDisplay(res.play, "black", {
			parent: this
		}).setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
		this.ring.setPosition(a.x * this.spaceX + this.startX, a.y * this.spaceY + this.startY);
		cc.audioEngine.playEffect(res.blacksound, !1);
		this.ClickPoint(a.x, a.y, this.my) && (169 <= ++this.count ? this.AddOverLayer(5) : this.scheduleOnce(function() {
			this.AIPlay()
		}, 1))
	},
	AddOverLayer: function(a) {
		a = new OverLayer(a);
		this.addChild(a, 10);
		a.y = 800;
		var b = new cc.MoveBy(1, cc.p(0, -800)),
			b = new cc.EaseBounceOut(b);
		a.runAction(b)
	}
});
var AI = cc.Sprite.extend({
	All: [],
	count: 0,
	firstHand: null,
	ctor: function() {
		this._super()
	},
	onEnter: function() {
		this._super()
	},
	initData: function(a, b) {
		var c = this.getAlphaBeta(a, b);
		return !0 == this.firstHand ? {
			x: 7,
			y: 7
		} : {
			x: c.x,
			y: c.y
		}
	},
	setFirstHand: function() {
		this.firstHand = !0
	},
	setFirstHandFalse: function() {
		this.firstHand = !1
	},
	getAlphaBeta: function(a, b) {
		for (var c = this.getMoves(a), d = this.All.length = 0; d < c.length; d++) {
			var e = c[d],
				f = e.x,
				e = e.y;
			a[f][e] = b;
			var k = this.getValue(a, b, f, e);
			a[f][e] = -b;
			var m = this.getValue(a, -b, f, e);
			this.All.push({
				x: f,
				y: e,
				value: k + m
			});
			a[f][e] = 0
		}
		c = this.All[0];
		for (d = 1; d < this.All.length; d++) this.All[d].value >= c.value && (c = this.All[d]);
		if (null != c) return c
	},
	getValue: function(a, b, c, d) {
		function e(b, c, d) {
			if (0 > b || 14 < b || 0 > c || 14 < c) return !1;
			b = a[b][c];
			if (b == d) return m.n++, !0;
			0 == b && m.v++;
			return !1
		}
		for (var f = Math.floor(2 * Math.random()), k = {
			11: 1,
			12: 2,
			21: 10,
			22: 20,
			31: 30,
			32: 50,
			41: 60,
			42: 100,
			50: 88888,
			51: 88888,
			52: 88888
		}, m = {
			n: 1,
			v: 0
		}, n = 1; 15 > n; n++) {
			var p = c - n;
			if (!1 == e(p, d, b)) break
		}
		for (n = 1; 15 > n && !(p = c + n, !1 == e(p, d, b)); n++);
		5 < m.n && (m.n = 5);
		f += k[10 * m.n + m.v] || 0;
		m.n = 1;
		m.v = 0;
		for (n = 1; 15 > n; n++) {
			var r = d + n;
			if (!1 == e(c, r, b)) break
		}
		for (n = 1; 15 > n && !(r = d - n, !1 == e(c, r, b)); n++);
		5 < m.n && (m.n = 5);
		f += k[10 * m.n + m.v] || 0;
		m.n = 1;
		m.v = 0;
		for (n = 1; 15 > n && !(p = c + n, r = d + n, !1 == e(p, r, b)); n++);
		for (n = 1; 15 > n && !(p = c - n, r = d - n, !1 == e(p, r, b)); n++);
		5 < m.n && (m.n = 5);
		f += k[10 * m.n + m.v] || 0;
		m.n = 1;
		m.v = 0;
		for (n = 1; 15 > n && !(p = c - n, r = d + n, !1 == e(p, r, b)); n++);
		for (n = 1; 15 > n && !(p = c + n, r = d - n, !1 == e(p, r, b)); n++);
		5 < m.n && (m.n = 5);
		return f += k[10 * m.n + m.v] || 0
	},
	getMoves: function(a) {
		for (var b = [], c = b.length = 0; 15 > c; c++)
		for (var d = 0; 15 > d; d++) 0 === a[c][d] && b.push({
			x: c,
			y: d
		});
		return b
	}
});
var OverLayer = cc.LayerColor.extend({
	ctor: function(a) {
		this._super(cc.color(10, 10, 20, 100));
		var b = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: function(a, b) {
				return !0
			}
		});
		cc.eventManager.addListener(b, this);
		var c;
		switch (a) {
		case 1:
			c = flax.assetsManager.createDisplay(res.over, "yousuccess", {
				parent: this
			});
			break;
		case 2:
			c = flax.assetsManager.createDisplay(res.over, "youfail", {
				parent: this
			});
			break;
		case 3:
			c = flax.assetsManager.createDisplay(res.over, "blacksuccess", {
				parent: this
			});
			break;
		case 4:
			c = flax.assetsManager.createDisplay(res.over, "whitesuccess", {
				parent: this
			});
			break;
		case 5:
			c = flax.assetsManager.createDisplay(res.over, "peace", {
				parent: this
			})
		}
		c.setOpacity(220);
		flax.inputManager.addListener(c.backBut, this.BackOnClick, null, this);
		flax.inputManager.addListener(c.replayBut, this.ReplayOnClick, null, this)
	},
	BackOnClick: function() {
		flax.replaceScene("startscene")
	},
	ReplayOnClick: function() {
		flax.replaceScene("gamescene" + currentscene)
	}
});
var GuiderLayer = cc.LayerColor.extend({
	ctor: function() {
		this._super(cc.color(10, 10, 20, 100));
		var a = cc.EventListener.create({
			event: cc.EventListener.TOUCH_ONE_BY_ONE,
			swallowTouches: !0,
			onTouchBegan: function(a, c) {
				return !0
			}
		});
		cc.eventManager.addListener(a, this);
		a = flax.assetsManager.createDisplay(res.guide, "newSymbol", {
			parent: this
		});
		flax.inputManager.addListener(a.closeBut, this.close, null, this);
		flax.inputManager.addListener(a.selectBut, this.select, null, this);
		a.selectBut.setOpacity(0)
	},
	close: function() {
		this.removeFromParent()
	},
	select: function(a, b) {
		firstplay ? (firstplay = !1, b.target.setOpacity(255)) : (firstplay = !0, b.target.setOpacity(0))
	}
});
var currentscene = 0,
	firstplay = !0;
cc.game.onStart = function() {
	!cc.sys.isNative && document.getElementById("cocosLoading") && document.body.removeChild(document.getElementById("cocosLoading"));
	cc.view.enableRetina(!1);
	(function() {
		flax.init(cc.ResolutionPolicy.SHOW_ALL);
		flax.registerScene("startscene", FirstScene, res_start);
		flax.registerScene("gamescene0", GameScene0, res_play);
		flax.registerScene("gamescene1", GameScene1, res_play);
		flax.registerScene("gamescene2", GameScene2, res_play);
		flax.replaceScene("startscene");
	})();
};
cc.game.run();